---
title: "数据结构"
date: 2022-01-11T14:43:18+08:00
tags: ['数据结构']
---



# 堆

堆是一种非线性结构，**可以**把堆看作一个数组，**也可以**被看作一个完全二叉树，通俗来讲堆其实就是**利用完全二叉树的结构来维护的一维数组**`但堆并不一定是完全二叉树`

按照堆的特点可以把堆分为大顶堆和小顶堆
大顶堆：每个结点的值都大于或等于其左右孩子结点的值
小顶堆：每个结点的值都小于或等于其左右孩子结点的值

## 使用堆的原因？

如果仅仅是需要得到一个有序的序列，使用排序就可以很快完成，并不需要去组织一个新的数据结构。但是如果我们的需求是对于一个随时会有更新的序列，我要随时知道这个序列的最小值或最大值是什么。显然如果是线性结构，每次插入之后，假设原数组是有序的，那使用二分把它放在正确的位置也未尝不可，但是插入的时候从数组中留出空位就需要O(n)的时间复杂度，删除的时候亦然。

## 时间复杂度

**插入和删除的时间复杂度是O(logn)**

# 环形队列(数组)

## 普通队列

普通队列，数组实现时，出队后，原来的空间就浪费了。

## 环形队列

<img src="https://pic-frank.oss-cn-beijing.aliyuncs.com/img/202111121019362.png" alt="image-20211112101924307" style="zoom:50%;" />

环形队列，数组实现时，下标用模取运算，例如最大空间为5，模取后只会有0，1，2，3，4下标，组成了循环。

1. `front` 变量的含义做一个调整： `front` 就指向队列的第一个元素, 也就是说 `arr[front]` 就是队列的第一个元素
   `front` 的初始值 = 0
2. `rear` 变量的含义做一个调整：`rear` 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.
   `rear` 的初始值 = 0
3. 当队列满时，条件是 `(rear + 1) % maxSize == front` 【满】
4. 对队列为空的条件， `rear == front` 空
5. 当我们这样分析， 队列中有效的数据的个数 `(rear + maxSize - front) % maxSize` // rear = 1 front = 0

# 时间轮

使用场景，处理大批量的定时任务

利用环形队列，队列的每个空间里存放的是任务的集合。

例如以60秒为一个轮，70秒后执行一个任务。只需要一个timer按秒去旋转时间轮，70%60=10，到达第10个槽的时候，执行内部的所有任务即可。

为了解决10秒和70秒落在同一个槽上，可以在任务身上加一个属性，圈数，例如10秒的任务圈数是0，70秒的任务是1，只有达到槽位置，并且圈数为0的任务才会被执行。

kafaka的做法是，再做一个分钟轮，先转分钟轮。再转秒的轮。

# 树

## 二叉搜索树(BST)

根节点的值大于其左子树中任意一个节点的值，小于其右节点中任意一节点的值，这一规则适用于二叉查找树中的每一个节点。

## 完全平衡二叉树(AVL)

解决二叉树极端下变成链表

## 红黑树

解决，完全平衡二叉树平衡频率过于频繁。

时间复杂度*l**o**g*(*n*)

>二叉搜索树：也称二叉查找树，或二叉排序树。定义也比较简单，要么是一颗空树，要么就是具有如下性质的二叉树：
>（1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的
>值；
>（2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的
>值；
>（3）任意节点的左、右子树也分别为二叉查找树；
>（4）没有键值相等的节点。
>
>平衡二叉树：在二叉搜索树的基础上多了两个重要的特点：
>（1）左右两子树的高度差的绝对值不能超过 1；
>（2）左右两子树也是一颗平衡二叉树。
>
>红黑树：红黑树是在普通二叉树上，对每个节点添加一个颜色属性形成的，需要同时满足一下五条性质：
>（1）节点是红色或者是黑色；
>（2）根节点是黑色；
>（3）每个叶节点（NIL 或空节点）是黑色；
>（4）每个红色节点的两个子节点都是黑色的（也就是说不存在两个连续的红色节
>点）；
>（5）从任一节点到其没个叶节点的所有路径都包含相同数目的黑色节点。
>
>区别：AVL 树需要保持平衡，但它的旋转太耗时，而红黑树就是一个没有 AVL 树 那样平衡，因此插入、删除效率会高于 AVL 树，而 AVL
>树的查找效率显然高于红黑树。

- 如果插入一个node引起了树的不平衡，AVL和RB-Tree(红黑树)都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次(因为不需要严格的平衡，从根到叶子的最长的可能路径不多于最短的可能路径的两倍长)旋转以及修改节点的颜色，只需要O(1)的复杂度。

- 其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。

IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查.
ngnix中,用红黑树管理timer,因为红黑树是有序的,可以很快的得到距离当前最小的定时器.
java中TreeMap，jdk1.8的hashmap的实现.

