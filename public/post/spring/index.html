<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Spring问题整理 - Mainroad</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring问题整理" />
<meta property="og:description" content="@Override @Nullable public Object invoke(MethodInvocation mi) throws Throwable { if (!(mi instanceof ProxyMethodInvocation)) { throw new IllegalStateException(&#34;MethodInvocation is not a Spring ProxyMethodInvocation: &#34; &#43; mi); } ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi; ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi); JoinPointMatch jpm = getJoinPointMatch(pmi); return invokeAdviceMethod(pjp, jpm, null, null); } 当在Sping中配置的Bean存在相互依赖，Spring是怎么处理的 针对原型Bean直接抛出异常，不支持。
单例Bean，Spring使用3个Map做缓存，来处理。
分别是：一级缓存Spring最终保存的单例对象Map，二级缓存建造Spring单例对象的匿名工厂对象返回的就是三级缓存需要的，三级缓存是允许提前被依赖的单例对象。
阐述一个Bean获取的流程  尝试获取单例Bean 检查一级缓存是否有，没有的话，检查当前获取的Bean是否正在创建，如果正在创建即出现了Bean互相依赖情况，检查三级缓存是否已经有提前可被依赖的对象，如果没有的话，检查二级缓存是否有其工厂，有的话，使用工厂，实例化这个Bean，放入三级缓存里。供其他Bean依赖使用 没获取到，可能是原型Bean，也可能是单例Bean没有实例化 检查如果是原型Bean，而且正在创建中，即出现了原型Bean被依赖的情况，直接抛出异常 准备BeanDefinition，如果档期工厂没有相应的BD，而且父工厂又存在BD，使用父工厂的getBean方法去获取Bean 标记Bean创建过了 从当前工厂读取BD,并且转为RootBeanDefinition，获取期间，还要检查父工厂是否也有该Bean的BD，有的话，以父工厂得BD为基础，子工厂得BD覆盖掉其属性 检查BD是不是抽象的，无法实例化的类，抛出异常 检查BD中得DependsOn属性，针对所有Depend，循环实例化，如果检查到有Depend得Bean又依赖于当前目标Bean，抛出异常，互相提前依赖了。并且建立相关关系，所以DependOn意义是，依赖于一个完全实例化完成后的Bean 如果是单例的话，开始创建单例Bean，创建匿名工厂对象 标记单例Bean正在被创建 使用工厂对象去调用getObject方法 实际上执行了createBean方法 根据之前的RootBD，解析出需要实例化的Class对象 检查MethodOverrides目标方法是否存在Class对象中 在实例化对象之前，给InstantiationAwareBeanPostProcessor机会去改变实例，调用其postProcessBeforeInstantiation，AOP就是在这里实现的，此外，如果返回了，还会调用BPP的postProcessAfterInitialization，但不会调用postProcessBeforeInitialization了 如果没有被InstantiationAwareBeanPostProcessor改变了的话，开始进入真正的实例化方法 实例化一个BeanWrapperImpl去封装实例 解析Class对象，确定Class对象有Public修饰符 如果有FactoryMethod的话，直接调用FactoryMethod返回实例，封装在BeanWrapperImpl，这里面也会初始化initBeanWrapper，将属性编辑器注入到BeanWrapperImpl身上，用于后续的属性注入 开始解析构造函数或者是FactoryMethod，如果解析过了，直接去实例化 否则进入构造函数解析 解析之前，看BPP有没有提供了构造函数，即SmartInstantiationAwareBeanPostProcessor的determineCandidateConstructors方法执行，如果返回了构造函数，就用BPP的了。 没有的话，进入默认的解析，依赖先看缓存里有没有解析过的参数，因为构造方法注入的话，很消耗性能，没有缓存的话，先看用户获取bean时有没有传入args，即构造函数的参数。没有的话，而且只有一个候选的构造函数，就直接用使用无参的了，没有的话，先去解析参数，construct-arg，既可以时Index，也可以是name。根据用户传入的arg长度，去解析。 最后解析完成后，使用实例化策略去实例化即可，这里也可使用cglib去处理，然后封装在BeanWrapperImpl中 至此，BeanWapper里已经包含了我们的目标对象的实例了 然后创建二级缓存，将上一步BeanWapper里的实例，作为二级缓存返回的对象，加载缓存里 至此，二级缓存的工厂加入 了。当在一开始获bean，一级获取不到，获取二级有工厂的时候，就会把BeanWapper的实例暴露出去，供后续使用 然后开始初始化实例 将上面暴露出来的示例进行属性注入 给InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation在属性注入之前最后一次机会，去改变Bean，并且阻止Bean的属性注入 判断属性注入的是byName还是byType，针对所有的非简单的属性，还有排除所有的ignoredDependencyInterfaces中的接口。进行getBean操作，保存到PropertyValues中 使用InstantiationAwareBeanPostProcessor的postProcessProperties，可以进行修改属性。继续使用postProcessPropertyValues，继续可以更该属性 得到所有属性后，应用属性到Bean实例身上，在应用属性的时候，会找到前工厂里的所有的TypeConverter去将属性变为需要的属性，如果变不成会报错 至此，属性赋值完毕 复制完毕后，开始初始化Bean，先激活所有的aware方法， 调用BPP的postProcessBeforeInitialization初始化之前方法，记住，这里的初始化，是Bean已经实例化之后的事情了，是执行其他事情的初始化 执行afterPropertiesSet方法，在执行init-methods方法 调用BPP的postProcessAfterInitialization初始化以后方法 至此返回暴露的bean，即getBean结束 最后处理销毁的方法，即出发destory-method的方法  Spring是如何处理掉循环依赖的  针对非单例Bean出现循环依赖直接抛出异常 单例Bean Spring存在3个缓存Map  Spring完全生成好的BeanMap，key是Bean的name，Value是实例对象 Spring生成Bean的工厂Map，key是Bean的name，value是实现了ObjectFactory接口的实例对象 Spring尚未初始化，即赋予属性或者其他初始化动作的Bean实例Map，key是Bean的name，value是工厂map的工厂的返回值，即ObjectFactory的getObject方法结果   假设存在对象A依赖于对象B，对象Bean依赖于对象A  Spring根据A的name，首先取BeanMap里找是否有A的实例，没有的话，检查A是否正在创建，如果正在创建，则说明出现了循环依赖。（需要获取A，发现A又在创建，表名有其他bean需要A），尝试从可提前依赖的BeanMap获取EarlyBeanReference，如果没有，则尝试从工厂Map里找A对应的工厂对象，如果有工厂对象，则调用工厂对象进行返回，并且将工厂返回的Bean实例作为EarlyBeanReference，放入未完全实例化结束BeanMap里，删除工厂Map对应的value。此时工厂Map为空。 此时，A没有正在创建，继续 标记A正在创建，根绝BeanDefinition生成Bean实例对象，（此时对象实例已经生成完毕，但是还没有初始化），并且把A的创建工厂，放入工厂Map，而这个创建工厂getObject返回值就是刚才生成的实例对象，并且给SmartInstantiationAwareBeanPostProcessor接口机会取改变这个EarlyBeanReference对象。 得到实例化后的A对象，开始注入A的属性，发现A的属性b，需要B对象。 B对象开始获取（此时，A还没有结束，即一级缓存中没有A，二级缓存中有A的工厂Map） B的获取如上述一致， 直至B实例化结束，开始注入B的属性，发现B的属性a，需要A对象 又到了A对象开始获取 此时，进入第一个流程，发现一级缓存里没有A，而A又正在创建中，出现循环依赖，去二级缓存里找A的工厂Map，调用工厂Map方法去，得到了EarlyBeanReference，放入三级缓存里，返回回去 即此时，B注入属性成功，并且返回了一个EarlyBeanReference，即当前正在创建的A对象实例。 B注入成功属性后，B实例化完全结束，结束后，清除B的二三级缓存，加入一级缓存并返回 此时回到了A的注入B属性逻辑中，A得到了B实例。而这个实例里的A属性对象，和当前获取A的对象是一个 A继续完成初始化动作，最后A实例化完全结束，清楚A的二三级缓存，加入一级缓存并返回   只有2个缓存行吗？为什么一定要3个  BeanMap无用质疑是需要的 如果只有工厂Map而没有，可提前依赖的BeanMap的话，那么在一开始从缓存中获取Bean，一级缓存无法获取到，直接就有工厂Bean，一旦有工厂就调用工厂返回的值，这样是不行的，因为在工厂调用Bean的时候，有很多动作就会进行重复，比如工厂获取的时候，可以给SmartInstantiationAwareBeanPostProcessor机会去更改EarlyBeanReference对象，重复执行了。第二，与工厂模式的思想违背，工厂只需要制造一次，而不是每次都制造。 如果只有可提前依赖的BeanMap，而没有工厂Map。实际上是可以的，只不过没有工厂的话，会将大部分工作都抛给创建Bean的流程里，例如SmartInstantiationAwareBeanPostProcessor等工厂应该负责的工作    ApplicationContext的Refresh方法  Enviroment，环境参数，根据不同的环境，实现Environment不同的子类，例如Web环境会实现，StandardServletEnvironment，默认是实现StandardEnvironment，包含很多环境变量，系统变量，java环境变量，Servlet环境变量 创建beanFactory作为成员变量，ApplicationContext自身也实现了BeanFactory接口，只不过具体实现的方法是成员变量的beanFactory的方法、 填充工厂  增加SPEL表达式解析器 属性编辑器注入 增加一个ApplicationContextAwareProcessor的BPP，在Bean实例化之后，激活实现了aware接口的方法的一个BPP 配置忽略某些类型的属性自动注入，增加某些类型自动注入   postProcessBeanFactory：留给子类去实现 记录启动路径 激活BeanFactoryPostProcessor，invokeBeanFactoryPostProcessors 注册BeanPostProcessor 初始化国际化文件 初始化initApplicationEventMulticaster，事件传送器，用于发送事件 注册事件监听器 设置ConversionService 锁定所有BeanDefinitions，防止改变 实例化剩下所有的no-lazy实例 调用所有实现LifeCycle接口的bean 发送ContextRefreshedEvent事件  BeanFactoryPostProcessor和BeanPostProcessor区别   BeanFactoryPostProcessor是可以修改Bean的元数据，是控制BeanFactory的，而BeanPostProcessor是Bean实例的处理器，可以修改Bean的实例" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sunhao1256.github.io/post/spring/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-11T14:43:18+08:00" />
<meta property="article:modified_time" content="2022-01-11T14:43:18+08:00" />


		<meta itemprop="name" content="Spring问题整理">
<meta itemprop="description" content="@Override @Nullable public Object invoke(MethodInvocation mi) throws Throwable { if (!(mi instanceof ProxyMethodInvocation)) { throw new IllegalStateException(&#34;MethodInvocation is not a Spring ProxyMethodInvocation: &#34; &#43; mi); } ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi; ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi); JoinPointMatch jpm = getJoinPointMatch(pmi); return invokeAdviceMethod(pjp, jpm, null, null); } 当在Sping中配置的Bean存在相互依赖，Spring是怎么处理的 针对原型Bean直接抛出异常，不支持。
单例Bean，Spring使用3个Map做缓存，来处理。
分别是：一级缓存Spring最终保存的单例对象Map，二级缓存建造Spring单例对象的匿名工厂对象返回的就是三级缓存需要的，三级缓存是允许提前被依赖的单例对象。
阐述一个Bean获取的流程  尝试获取单例Bean 检查一级缓存是否有，没有的话，检查当前获取的Bean是否正在创建，如果正在创建即出现了Bean互相依赖情况，检查三级缓存是否已经有提前可被依赖的对象，如果没有的话，检查二级缓存是否有其工厂，有的话，使用工厂，实例化这个Bean，放入三级缓存里。供其他Bean依赖使用 没获取到，可能是原型Bean，也可能是单例Bean没有实例化 检查如果是原型Bean，而且正在创建中，即出现了原型Bean被依赖的情况，直接抛出异常 准备BeanDefinition，如果档期工厂没有相应的BD，而且父工厂又存在BD，使用父工厂的getBean方法去获取Bean 标记Bean创建过了 从当前工厂读取BD,并且转为RootBeanDefinition，获取期间，还要检查父工厂是否也有该Bean的BD，有的话，以父工厂得BD为基础，子工厂得BD覆盖掉其属性 检查BD是不是抽象的，无法实例化的类，抛出异常 检查BD中得DependsOn属性，针对所有Depend，循环实例化，如果检查到有Depend得Bean又依赖于当前目标Bean，抛出异常，互相提前依赖了。并且建立相关关系，所以DependOn意义是，依赖于一个完全实例化完成后的Bean 如果是单例的话，开始创建单例Bean，创建匿名工厂对象 标记单例Bean正在被创建 使用工厂对象去调用getObject方法 实际上执行了createBean方法 根据之前的RootBD，解析出需要实例化的Class对象 检查MethodOverrides目标方法是否存在Class对象中 在实例化对象之前，给InstantiationAwareBeanPostProcessor机会去改变实例，调用其postProcessBeforeInstantiation，AOP就是在这里实现的，此外，如果返回了，还会调用BPP的postProcessAfterInitialization，但不会调用postProcessBeforeInitialization了 如果没有被InstantiationAwareBeanPostProcessor改变了的话，开始进入真正的实例化方法 实例化一个BeanWrapperImpl去封装实例 解析Class对象，确定Class对象有Public修饰符 如果有FactoryMethod的话，直接调用FactoryMethod返回实例，封装在BeanWrapperImpl，这里面也会初始化initBeanWrapper，将属性编辑器注入到BeanWrapperImpl身上，用于后续的属性注入 开始解析构造函数或者是FactoryMethod，如果解析过了，直接去实例化 否则进入构造函数解析 解析之前，看BPP有没有提供了构造函数，即SmartInstantiationAwareBeanPostProcessor的determineCandidateConstructors方法执行，如果返回了构造函数，就用BPP的了。 没有的话，进入默认的解析，依赖先看缓存里有没有解析过的参数，因为构造方法注入的话，很消耗性能，没有缓存的话，先看用户获取bean时有没有传入args，即构造函数的参数。没有的话，而且只有一个候选的构造函数，就直接用使用无参的了，没有的话，先去解析参数，construct-arg，既可以时Index，也可以是name。根据用户传入的arg长度，去解析。 最后解析完成后，使用实例化策略去实例化即可，这里也可使用cglib去处理，然后封装在BeanWrapperImpl中 至此，BeanWapper里已经包含了我们的目标对象的实例了 然后创建二级缓存，将上一步BeanWapper里的实例，作为二级缓存返回的对象，加载缓存里 至此，二级缓存的工厂加入 了。当在一开始获bean，一级获取不到，获取二级有工厂的时候，就会把BeanWapper的实例暴露出去，供后续使用 然后开始初始化实例 将上面暴露出来的示例进行属性注入 给InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation在属性注入之前最后一次机会，去改变Bean，并且阻止Bean的属性注入 判断属性注入的是byName还是byType，针对所有的非简单的属性，还有排除所有的ignoredDependencyInterfaces中的接口。进行getBean操作，保存到PropertyValues中 使用InstantiationAwareBeanPostProcessor的postProcessProperties，可以进行修改属性。继续使用postProcessPropertyValues，继续可以更该属性 得到所有属性后，应用属性到Bean实例身上，在应用属性的时候，会找到前工厂里的所有的TypeConverter去将属性变为需要的属性，如果变不成会报错 至此，属性赋值完毕 复制完毕后，开始初始化Bean，先激活所有的aware方法， 调用BPP的postProcessBeforeInitialization初始化之前方法，记住，这里的初始化，是Bean已经实例化之后的事情了，是执行其他事情的初始化 执行afterPropertiesSet方法，在执行init-methods方法 调用BPP的postProcessAfterInitialization初始化以后方法 至此返回暴露的bean，即getBean结束 最后处理销毁的方法，即出发destory-method的方法  Spring是如何处理掉循环依赖的  针对非单例Bean出现循环依赖直接抛出异常 单例Bean Spring存在3个缓存Map  Spring完全生成好的BeanMap，key是Bean的name，Value是实例对象 Spring生成Bean的工厂Map，key是Bean的name，value是实现了ObjectFactory接口的实例对象 Spring尚未初始化，即赋予属性或者其他初始化动作的Bean实例Map，key是Bean的name，value是工厂map的工厂的返回值，即ObjectFactory的getObject方法结果   假设存在对象A依赖于对象B，对象Bean依赖于对象A  Spring根据A的name，首先取BeanMap里找是否有A的实例，没有的话，检查A是否正在创建，如果正在创建，则说明出现了循环依赖。（需要获取A，发现A又在创建，表名有其他bean需要A），尝试从可提前依赖的BeanMap获取EarlyBeanReference，如果没有，则尝试从工厂Map里找A对应的工厂对象，如果有工厂对象，则调用工厂对象进行返回，并且将工厂返回的Bean实例作为EarlyBeanReference，放入未完全实例化结束BeanMap里，删除工厂Map对应的value。此时工厂Map为空。 此时，A没有正在创建，继续 标记A正在创建，根绝BeanDefinition生成Bean实例对象，（此时对象实例已经生成完毕，但是还没有初始化），并且把A的创建工厂，放入工厂Map，而这个创建工厂getObject返回值就是刚才生成的实例对象，并且给SmartInstantiationAwareBeanPostProcessor接口机会取改变这个EarlyBeanReference对象。 得到实例化后的A对象，开始注入A的属性，发现A的属性b，需要B对象。 B对象开始获取（此时，A还没有结束，即一级缓存中没有A，二级缓存中有A的工厂Map） B的获取如上述一致， 直至B实例化结束，开始注入B的属性，发现B的属性a，需要A对象 又到了A对象开始获取 此时，进入第一个流程，发现一级缓存里没有A，而A又正在创建中，出现循环依赖，去二级缓存里找A的工厂Map，调用工厂Map方法去，得到了EarlyBeanReference，放入三级缓存里，返回回去 即此时，B注入属性成功，并且返回了一个EarlyBeanReference，即当前正在创建的A对象实例。 B注入成功属性后，B实例化完全结束，结束后，清除B的二三级缓存，加入一级缓存并返回 此时回到了A的注入B属性逻辑中，A得到了B实例。而这个实例里的A属性对象，和当前获取A的对象是一个 A继续完成初始化动作，最后A实例化完全结束，清楚A的二三级缓存，加入一级缓存并返回   只有2个缓存行吗？为什么一定要3个  BeanMap无用质疑是需要的 如果只有工厂Map而没有，可提前依赖的BeanMap的话，那么在一开始从缓存中获取Bean，一级缓存无法获取到，直接就有工厂Bean，一旦有工厂就调用工厂返回的值，这样是不行的，因为在工厂调用Bean的时候，有很多动作就会进行重复，比如工厂获取的时候，可以给SmartInstantiationAwareBeanPostProcessor机会去更改EarlyBeanReference对象，重复执行了。第二，与工厂模式的思想违背，工厂只需要制造一次，而不是每次都制造。 如果只有可提前依赖的BeanMap，而没有工厂Map。实际上是可以的，只不过没有工厂的话，会将大部分工作都抛给创建Bean的流程里，例如SmartInstantiationAwareBeanPostProcessor等工厂应该负责的工作    ApplicationContext的Refresh方法  Enviroment，环境参数，根据不同的环境，实现Environment不同的子类，例如Web环境会实现，StandardServletEnvironment，默认是实现StandardEnvironment，包含很多环境变量，系统变量，java环境变量，Servlet环境变量 创建beanFactory作为成员变量，ApplicationContext自身也实现了BeanFactory接口，只不过具体实现的方法是成员变量的beanFactory的方法、 填充工厂  增加SPEL表达式解析器 属性编辑器注入 增加一个ApplicationContextAwareProcessor的BPP，在Bean实例化之后，激活实现了aware接口的方法的一个BPP 配置忽略某些类型的属性自动注入，增加某些类型自动注入   postProcessBeanFactory：留给子类去实现 记录启动路径 激活BeanFactoryPostProcessor，invokeBeanFactoryPostProcessors 注册BeanPostProcessor 初始化国际化文件 初始化initApplicationEventMulticaster，事件传送器，用于发送事件 注册事件监听器 设置ConversionService 锁定所有BeanDefinitions，防止改变 实例化剩下所有的no-lazy实例 调用所有实现LifeCycle接口的bean 发送ContextRefreshedEvent事件  BeanFactoryPostProcessor和BeanPostProcessor区别   BeanFactoryPostProcessor是可以修改Bean的元数据，是控制BeanFactory的，而BeanPostProcessor是Bean实例的处理器，可以修改Bean的实例"><meta itemprop="datePublished" content="2022-01-11T14:43:18+08:00" />
<meta itemprop="dateModified" content="2022-01-11T14:43:18+08:00" />
<meta itemprop="wordCount" content="715">
<meta itemprop="keywords" content="Spring," />
		<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Spring问题整理"/>
<meta name="twitter:description" content="@Override @Nullable public Object invoke(MethodInvocation mi) throws Throwable { if (!(mi instanceof ProxyMethodInvocation)) { throw new IllegalStateException(&#34;MethodInvocation is not a Spring ProxyMethodInvocation: &#34; &#43; mi); } ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi; ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi); JoinPointMatch jpm = getJoinPointMatch(pmi); return invokeAdviceMethod(pjp, jpm, null, null); } 当在Sping中配置的Bean存在相互依赖，Spring是怎么处理的 针对原型Bean直接抛出异常，不支持。
单例Bean，Spring使用3个Map做缓存，来处理。
分别是：一级缓存Spring最终保存的单例对象Map，二级缓存建造Spring单例对象的匿名工厂对象返回的就是三级缓存需要的，三级缓存是允许提前被依赖的单例对象。
阐述一个Bean获取的流程  尝试获取单例Bean 检查一级缓存是否有，没有的话，检查当前获取的Bean是否正在创建，如果正在创建即出现了Bean互相依赖情况，检查三级缓存是否已经有提前可被依赖的对象，如果没有的话，检查二级缓存是否有其工厂，有的话，使用工厂，实例化这个Bean，放入三级缓存里。供其他Bean依赖使用 没获取到，可能是原型Bean，也可能是单例Bean没有实例化 检查如果是原型Bean，而且正在创建中，即出现了原型Bean被依赖的情况，直接抛出异常 准备BeanDefinition，如果档期工厂没有相应的BD，而且父工厂又存在BD，使用父工厂的getBean方法去获取Bean 标记Bean创建过了 从当前工厂读取BD,并且转为RootBeanDefinition，获取期间，还要检查父工厂是否也有该Bean的BD，有的话，以父工厂得BD为基础，子工厂得BD覆盖掉其属性 检查BD是不是抽象的，无法实例化的类，抛出异常 检查BD中得DependsOn属性，针对所有Depend，循环实例化，如果检查到有Depend得Bean又依赖于当前目标Bean，抛出异常，互相提前依赖了。并且建立相关关系，所以DependOn意义是，依赖于一个完全实例化完成后的Bean 如果是单例的话，开始创建单例Bean，创建匿名工厂对象 标记单例Bean正在被创建 使用工厂对象去调用getObject方法 实际上执行了createBean方法 根据之前的RootBD，解析出需要实例化的Class对象 检查MethodOverrides目标方法是否存在Class对象中 在实例化对象之前，给InstantiationAwareBeanPostProcessor机会去改变实例，调用其postProcessBeforeInstantiation，AOP就是在这里实现的，此外，如果返回了，还会调用BPP的postProcessAfterInitialization，但不会调用postProcessBeforeInitialization了 如果没有被InstantiationAwareBeanPostProcessor改变了的话，开始进入真正的实例化方法 实例化一个BeanWrapperImpl去封装实例 解析Class对象，确定Class对象有Public修饰符 如果有FactoryMethod的话，直接调用FactoryMethod返回实例，封装在BeanWrapperImpl，这里面也会初始化initBeanWrapper，将属性编辑器注入到BeanWrapperImpl身上，用于后续的属性注入 开始解析构造函数或者是FactoryMethod，如果解析过了，直接去实例化 否则进入构造函数解析 解析之前，看BPP有没有提供了构造函数，即SmartInstantiationAwareBeanPostProcessor的determineCandidateConstructors方法执行，如果返回了构造函数，就用BPP的了。 没有的话，进入默认的解析，依赖先看缓存里有没有解析过的参数，因为构造方法注入的话，很消耗性能，没有缓存的话，先看用户获取bean时有没有传入args，即构造函数的参数。没有的话，而且只有一个候选的构造函数，就直接用使用无参的了，没有的话，先去解析参数，construct-arg，既可以时Index，也可以是name。根据用户传入的arg长度，去解析。 最后解析完成后，使用实例化策略去实例化即可，这里也可使用cglib去处理，然后封装在BeanWrapperImpl中 至此，BeanWapper里已经包含了我们的目标对象的实例了 然后创建二级缓存，将上一步BeanWapper里的实例，作为二级缓存返回的对象，加载缓存里 至此，二级缓存的工厂加入 了。当在一开始获bean，一级获取不到，获取二级有工厂的时候，就会把BeanWapper的实例暴露出去，供后续使用 然后开始初始化实例 将上面暴露出来的示例进行属性注入 给InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation在属性注入之前最后一次机会，去改变Bean，并且阻止Bean的属性注入 判断属性注入的是byName还是byType，针对所有的非简单的属性，还有排除所有的ignoredDependencyInterfaces中的接口。进行getBean操作，保存到PropertyValues中 使用InstantiationAwareBeanPostProcessor的postProcessProperties，可以进行修改属性。继续使用postProcessPropertyValues，继续可以更该属性 得到所有属性后，应用属性到Bean实例身上，在应用属性的时候，会找到前工厂里的所有的TypeConverter去将属性变为需要的属性，如果变不成会报错 至此，属性赋值完毕 复制完毕后，开始初始化Bean，先激活所有的aware方法， 调用BPP的postProcessBeforeInitialization初始化之前方法，记住，这里的初始化，是Bean已经实例化之后的事情了，是执行其他事情的初始化 执行afterPropertiesSet方法，在执行init-methods方法 调用BPP的postProcessAfterInitialization初始化以后方法 至此返回暴露的bean，即getBean结束 最后处理销毁的方法，即出发destory-method的方法  Spring是如何处理掉循环依赖的  针对非单例Bean出现循环依赖直接抛出异常 单例Bean Spring存在3个缓存Map  Spring完全生成好的BeanMap，key是Bean的name，Value是实例对象 Spring生成Bean的工厂Map，key是Bean的name，value是实现了ObjectFactory接口的实例对象 Spring尚未初始化，即赋予属性或者其他初始化动作的Bean实例Map，key是Bean的name，value是工厂map的工厂的返回值，即ObjectFactory的getObject方法结果   假设存在对象A依赖于对象B，对象Bean依赖于对象A  Spring根据A的name，首先取BeanMap里找是否有A的实例，没有的话，检查A是否正在创建，如果正在创建，则说明出现了循环依赖。（需要获取A，发现A又在创建，表名有其他bean需要A），尝试从可提前依赖的BeanMap获取EarlyBeanReference，如果没有，则尝试从工厂Map里找A对应的工厂对象，如果有工厂对象，则调用工厂对象进行返回，并且将工厂返回的Bean实例作为EarlyBeanReference，放入未完全实例化结束BeanMap里，删除工厂Map对应的value。此时工厂Map为空。 此时，A没有正在创建，继续 标记A正在创建，根绝BeanDefinition生成Bean实例对象，（此时对象实例已经生成完毕，但是还没有初始化），并且把A的创建工厂，放入工厂Map，而这个创建工厂getObject返回值就是刚才生成的实例对象，并且给SmartInstantiationAwareBeanPostProcessor接口机会取改变这个EarlyBeanReference对象。 得到实例化后的A对象，开始注入A的属性，发现A的属性b，需要B对象。 B对象开始获取（此时，A还没有结束，即一级缓存中没有A，二级缓存中有A的工厂Map） B的获取如上述一致， 直至B实例化结束，开始注入B的属性，发现B的属性a，需要A对象 又到了A对象开始获取 此时，进入第一个流程，发现一级缓存里没有A，而A又正在创建中，出现循环依赖，去二级缓存里找A的工厂Map，调用工厂Map方法去，得到了EarlyBeanReference，放入三级缓存里，返回回去 即此时，B注入属性成功，并且返回了一个EarlyBeanReference，即当前正在创建的A对象实例。 B注入成功属性后，B实例化完全结束，结束后，清除B的二三级缓存，加入一级缓存并返回 此时回到了A的注入B属性逻辑中，A得到了B实例。而这个实例里的A属性对象，和当前获取A的对象是一个 A继续完成初始化动作，最后A实例化完全结束，清楚A的二三级缓存，加入一级缓存并返回   只有2个缓存行吗？为什么一定要3个  BeanMap无用质疑是需要的 如果只有工厂Map而没有，可提前依赖的BeanMap的话，那么在一开始从缓存中获取Bean，一级缓存无法获取到，直接就有工厂Bean，一旦有工厂就调用工厂返回的值，这样是不行的，因为在工厂调用Bean的时候，有很多动作就会进行重复，比如工厂获取的时候，可以给SmartInstantiationAwareBeanPostProcessor机会去更改EarlyBeanReference对象，重复执行了。第二，与工厂模式的思想违背，工厂只需要制造一次，而不是每次都制造。 如果只有可提前依赖的BeanMap，而没有工厂Map。实际上是可以的，只不过没有工厂的话，会将大部分工作都抛给创建Bean的流程里，例如SmartInstantiationAwareBeanPostProcessor等工厂应该负责的工作    ApplicationContext的Refresh方法  Enviroment，环境参数，根据不同的环境，实现Environment不同的子类，例如Web环境会实现，StandardServletEnvironment，默认是实现StandardEnvironment，包含很多环境变量，系统变量，java环境变量，Servlet环境变量 创建beanFactory作为成员变量，ApplicationContext自身也实现了BeanFactory接口，只不过具体实现的方法是成员变量的beanFactory的方法、 填充工厂  增加SPEL表达式解析器 属性编辑器注入 增加一个ApplicationContextAwareProcessor的BPP，在Bean实例化之后，激活实现了aware接口的方法的一个BPP 配置忽略某些类型的属性自动注入，增加某些类型自动注入   postProcessBeanFactory：留给子类去实现 记录启动路径 激活BeanFactoryPostProcessor，invokeBeanFactoryPostProcessors 注册BeanPostProcessor 初始化国际化文件 初始化initApplicationEventMulticaster，事件传送器，用于发送事件 注册事件监听器 设置ConversionService 锁定所有BeanDefinitions，防止改变 实例化剩下所有的no-lazy实例 调用所有实现LifeCycle接口的bean 发送ContextRefreshedEvent事件  BeanFactoryPostProcessor和BeanPostProcessor区别   BeanFactoryPostProcessor是可以修改Bean的元数据，是控制BeanFactory的，而BeanPostProcessor是Bean实例的处理器，可以修改Bean的实例"/>

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/custom.css">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="/" title="Mainroad" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="/img/placeholder.png">
				</div><div class="logo__item logo__text">
					<div class="logo__title">Mainroad</div>
					<div class="logo__tagline">Just another site</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">About</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring问题整理</h1>
			<div class="post__meta meta"><div class="meta__item-author meta__item">
	<svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2 0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class="meta__text">Frank Silva</span>
</div>
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2022-01-11T14:43:18&#43;08:00">2022-01-11</time></div></div>
		</header>
		
<div class="post__toc toc">
	<div class="toc__title">Page content</div>
	<div class="toc__menu">
		<nav id="TableOfContents">
  <ul>
    <li><a href="#为什么在controller的方法参数里写httpservletrequest就可以获得到请求对象以及requestbody和requestparam">为什么在Controller的方法参数里，写HttpServletRequest就可以获得到请求对象，以及@RequestBody和@RequestParam</a></li>
  </ul>

  <ul>
    <li><a href="#拦截器和过滤器的区别">拦截器和过滤器的区别</a></li>
  </ul>

  <ul>
    <li><a href="#什么是mybatis的懒加载">什么是mybatis的懒加载</a></li>
    <li><a href="#mybatis的mapper是如何与数据库连接的">mybatis的mapper是如何与数据库连接的</a></li>
  </ul>
</nav>
	</div>
</div><div class="content post__content clearfix">
			<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Override</span>
<span style="color:#a6e22e">@Nullable</span>
<span style="color:#66d9ef">public</span> Object <span style="color:#a6e22e">invoke</span><span style="color:#f92672">(</span>MethodInvocation mi<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Throwable <span style="color:#f92672">{</span>
   <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!(</span>mi <span style="color:#66d9ef">instanceof</span> ProxyMethodInvocation<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalStateException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;MethodInvocation is not a Spring ProxyMethodInvocation: &#34;</span> <span style="color:#f92672">+</span> mi<span style="color:#f92672">);</span>
   <span style="color:#f92672">}</span>
   ProxyMethodInvocation pmi <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>ProxyMethodInvocation<span style="color:#f92672">)</span> mi<span style="color:#f92672">;</span>
   ProceedingJoinPoint pjp <span style="color:#f92672">=</span> lazyGetProceedingJoinPoint<span style="color:#f92672">(</span>pmi<span style="color:#f92672">);</span>
   JoinPointMatch jpm <span style="color:#f92672">=</span> getJoinPointMatch<span style="color:#f92672">(</span>pmi<span style="color:#f92672">);</span>
   <span style="color:#66d9ef">return</span> invokeAdviceMethod<span style="color:#f92672">(</span>pjp<span style="color:#f92672">,</span> jpm<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><h1 id="当在sping中配置的bean存在相互依赖spring是怎么处理的">当在Sping中配置的Bean存在相互依赖，Spring是怎么处理的</h1>
<p>针对原型Bean直接抛出异常，不支持。</p>
<p>单例Bean，Spring使用3个Map做缓存，来处理。</p>
<p>分别是：一级缓存Spring最终保存的单例对象Map，二级缓存建造Spring单例对象的匿名工厂对象返回的就是三级缓存需要的，三级缓存是允许提前被依赖的单例对象。</p>
<h1 id="阐述一个bean获取的流程">阐述一个Bean获取的流程</h1>
<ul>
<li>尝试获取单例Bean</li>
<li>检查一级缓存是否有，没有的话，检查当前获取的Bean是否正在创建，如果正在创建即出现了Bean互相依赖情况，检查三级缓存是否已经有提前可被依赖的对象，如果没有的话，检查二级缓存是否有其工厂，有的话，使用工厂，实例化这个Bean，放入三级缓存里。供其他Bean依赖使用</li>
<li>没获取到，可能是原型Bean，也可能是单例Bean没有实例化</li>
<li>检查如果是原型Bean，而且正在创建中，即出现了原型Bean被依赖的情况，直接抛出异常</li>
<li>准备BeanDefinition，如果档期工厂没有相应的BD，而且父工厂又存在BD，使用父工厂的getBean方法去获取Bean</li>
<li>标记Bean创建过了</li>
<li>从当前工厂读取BD,并且转为RootBeanDefinition，获取期间，还要检查父工厂是否也有该Bean的BD，有的话，以父工厂得BD为基础，子工厂得BD覆盖掉其属性</li>
<li>检查BD是不是抽象的，无法实例化的类，抛出异常</li>
<li>检查BD中得DependsOn属性，针对所有Depend，循环实例化，如果检查到有Depend得Bean又依赖于当前目标Bean，抛出异常，互相提前依赖了。并且建立相关关系，所以DependOn意义是，依赖于一个完全实例化完成后的Bean</li>
<li>如果是单例的话，开始创建单例Bean，创建匿名工厂对象</li>
<li>标记单例Bean正在被创建</li>
<li>使用工厂对象去调用getObject方法</li>
<li>实际上执行了createBean方法</li>
<li>根据之前的RootBD，解析出需要实例化的Class对象</li>
<li>检查MethodOverrides目标方法是否存在Class对象中</li>
<li><strong>在实例化对象之前，给InstantiationAwareBeanPostProcessor机会去改变实例，调用其postProcessBeforeInstantiation，AOP就是在这里实现的，此外，如果返回了，还会调用BPP的postProcessAfterInitialization，但不会调用postProcessBeforeInitialization了</strong></li>
<li>如果没有被InstantiationAwareBeanPostProcessor改变了的话，开始进入真正的实例化方法</li>
<li>实例化一个BeanWrapperImpl去封装实例</li>
<li>解析Class对象，确定Class对象有Public修饰符</li>
<li>如果有FactoryMethod的话，直接调用FactoryMethod返回实例，封装在BeanWrapperImpl，这里面也会初始化initBeanWrapper，将属性编辑器注入到BeanWrapperImpl身上，用于后续的属性注入</li>
<li>开始解析构造函数或者是FactoryMethod，如果解析过了，直接去实例化</li>
<li>否则进入构造函数解析</li>
<li>解析之前，看BPP有没有提供了构造函数，即SmartInstantiationAwareBeanPostProcessor的determineCandidateConstructors方法执行，如果返回了构造函数，就用BPP的了。</li>
<li>没有的话，进入默认的解析，依赖先看缓存里有没有解析过的参数，因为构造方法注入的话，很消耗性能，没有缓存的话，先看用户获取bean时有没有传入args，即构造函数的参数。没有的话，而且只有一个候选的构造函数，就直接用使用无参的了，没有的话，先去解析参数，construct-arg，既可以时Index，也可以是name。根据用户传入的arg长度，去解析。</li>
<li>最后解析完成后，使用实例化策略去实例化即可，这里也可使用cglib去处理，然后封装在BeanWrapperImpl中</li>
<li>至此，BeanWapper里已经包含了我们的目标对象的实例了</li>
<li>然后创建二级缓存，将上一步BeanWapper里的实例，作为二级缓存返回的对象，加载缓存里</li>
<li>至此，二级缓存的工厂加入 了。当在一开始获bean，一级获取不到，获取二级有工厂的时候，就会把BeanWapper的实例暴露出去，供后续使用</li>
<li>然后开始初始化实例</li>
<li>将上面暴露出来的示例进行属性注入</li>
<li>给InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation在属性注入之前最后一次机会，去改变Bean，并且阻止Bean的属性注入</li>
<li>判断属性注入的是byName还是byType，针对所有的非简单的属性，还有排除所有的ignoredDependencyInterfaces中的接口。进行getBean操作，保存到PropertyValues中</li>
<li>使用InstantiationAwareBeanPostProcessor的postProcessProperties，可以进行修改属性。继续使用postProcessPropertyValues，继续可以更该属性</li>
<li>得到所有属性后，应用属性到Bean实例身上，在应用属性的时候，会找到前工厂里的所有的TypeConverter去将属性变为需要的属性，如果变不成会报错</li>
<li>至此，属性赋值完毕</li>
<li>复制完毕后，开始初始化Bean，先激活所有的aware方法，</li>
<li>调用BPP的postProcessBeforeInitialization初始化之前方法，记住，这里的初始化，是Bean已经实例化之后的事情了，是执行其他事情的初始化</li>
<li>执行afterPropertiesSet方法，在执行init-methods方法</li>
<li>调用BPP的postProcessAfterInitialization初始化以后方法</li>
<li>至此返回暴露的bean，即getBean结束</li>
<li>最后处理销毁的方法，即出发destory-method的方法</li>
</ul>
<h1 id="spring是如何处理掉循环依赖的">Spring是如何处理掉循环依赖的</h1>
<ul>
<li>针对非单例Bean出现循环依赖直接抛出异常</li>
<li>单例Bean</li>
<li>Spring存在3个缓存Map
<ul>
<li>Spring完全生成好的BeanMap，key是Bean的name，Value是实例对象</li>
<li>Spring生成Bean的工厂Map，key是Bean的name，value是实现了ObjectFactory接口的实例对象</li>
<li>Spring尚未初始化，即赋予属性或者其他初始化动作的Bean实例Map，key是Bean的name，value是工厂map的工厂的返回值，即ObjectFactory的getObject方法结果</li>
</ul>
</li>
<li>假设存在对象A依赖于对象B，对象Bean依赖于对象A
<ul>
<li>Spring根据A的name，首先取BeanMap里找是否有A的实例，没有的话，检查A是否正在创建，如果正在创建，则说明出现了循环依赖。（需要获取A，发现A又在创建，表名有其他bean需要A），尝试从可提前依赖的BeanMap获取EarlyBeanReference，如果没有，则尝试从工厂Map里找A对应的工厂对象，如果有工厂对象，则调用工厂对象进行返回，并且将工厂返回的Bean实例作为EarlyBeanReference，放入未完全实例化结束BeanMap里，删除工厂Map对应的value。此时工厂Map为空。</li>
<li>此时，A没有正在创建，继续</li>
<li>标记A正在创建，根绝BeanDefinition生成Bean实例对象，（此时对象实例已经生成完毕，但是还没有初始化），并且把A的创建工厂，放入工厂Map，而这个创建工厂getObject返回值就是刚才生成的实例对象，并且给SmartInstantiationAwareBeanPostProcessor接口机会取改变这个EarlyBeanReference对象。</li>
<li>得到实例化后的A对象，开始注入A的属性，发现A的属性b，需要B对象。</li>
<li>B对象开始获取（此时，A还没有结束，即一级缓存中没有A，二级缓存中有A的工厂Map）</li>
<li>B的获取如上述一致，</li>
<li>直至B实例化结束，开始注入B的属性，发现B的属性a，需要A对象</li>
<li>又到了A对象开始获取</li>
<li>此时，进入第一个流程，发现一级缓存里没有A，而A又正在创建中，出现循环依赖，去二级缓存里找A的工厂Map，调用工厂Map方法去，得到了EarlyBeanReference，放入三级缓存里，返回回去</li>
<li>即此时，B注入属性成功，并且返回了一个EarlyBeanReference，即当前正在创建的A对象实例。</li>
<li>B注入成功属性后，B实例化完全结束，结束后，清除B的二三级缓存，加入一级缓存并返回</li>
<li>此时回到了A的注入B属性逻辑中，A得到了B实例。而这个实例里的A属性对象，和当前获取A的对象是一个</li>
<li>A继续完成初始化动作，最后A实例化完全结束，清楚A的二三级缓存，加入一级缓存并返回</li>
</ul>
</li>
<li>只有2个缓存行吗？为什么一定要3个
<ul>
<li>BeanMap无用质疑是需要的</li>
<li>如果只有工厂Map而没有，可提前依赖的BeanMap的话，那么在一开始从缓存中获取Bean，一级缓存无法获取到，直接就有工厂Bean，一旦有工厂就调用工厂返回的值，这样是不行的，因为在工厂调用Bean的时候，有很多动作就会进行重复，比如工厂获取的时候，可以给SmartInstantiationAwareBeanPostProcessor机会去更改EarlyBeanReference对象，重复执行了。第二，与工厂模式的思想违背，工厂只需要制造一次，而不是每次都制造。</li>
<li>如果只有可提前依赖的BeanMap，而没有工厂Map。实际上是可以的，只不过没有工厂的话，会将大部分工作都抛给创建Bean的流程里，例如SmartInstantiationAwareBeanPostProcessor等工厂应该负责的工作</li>
</ul>
</li>
</ul>
<h1 id="applicationcontext的refresh方法">ApplicationContext的Refresh方法</h1>
<ul>
<li>Enviroment，环境参数，根据不同的环境，实现Environment不同的子类，例如Web环境会实现，StandardServletEnvironment，默认是实现StandardEnvironment，包含很多环境变量，系统变量，java环境变量，Servlet环境变量</li>
<li>创建beanFactory作为成员变量，ApplicationContext自身也实现了BeanFactory接口，只不过具体实现的方法是成员变量的beanFactory的方法、</li>
<li>填充工厂
<ul>
<li>增加SPEL表达式解析器</li>
<li>属性编辑器注入</li>
<li>增加一个ApplicationContextAwareProcessor的BPP，在Bean实例化之后，激活实现了aware接口的方法的一个BPP</li>
<li>配置忽略某些类型的属性自动注入，增加某些类型自动注入</li>
</ul>
</li>
<li>postProcessBeanFactory：留给子类去实现</li>
<li>记录启动路径</li>
<li>激活BeanFactoryPostProcessor，invokeBeanFactoryPostProcessors</li>
<li>注册BeanPostProcessor</li>
<li>初始化国际化文件</li>
<li>初始化initApplicationEventMulticaster，事件传送器，用于发送事件</li>
<li>注册事件监听器</li>
<li>设置ConversionService</li>
<li>锁定所有BeanDefinitions，防止改变</li>
<li>实例化剩下所有的no-lazy实例</li>
<li>调用所有实现LifeCycle接口的bean</li>
<li>发送ContextRefreshedEvent事件</li>
</ul>
<h1 id="beanfactorypostprocessor和beanpostprocessor区别">BeanFactoryPostProcessor和BeanPostProcessor区别</h1>
<ul>
<li>
<p>BeanFactoryPostProcessor是可以修改Bean的元数据，是控制BeanFactory的，而BeanPostProcessor是Bean实例的处理器，可以修改Bean的实例</p>
</li>
<li>
<p>以PropertySourcesPlaceholderConfigurer为例</p>
<p>很明显，作用就是对于Beanfactory的所有Beandefintion进行处理，即在xml里中配置的${}属性</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">	<span style="color:#a6e22e">@Override</span>
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">postProcessBeanFactory</span><span style="color:#f92672">(</span>ConfigurableListableBeanFactory beanFactory<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> BeansException <span style="color:#f92672">{</span>
		<span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
			Properties mergedProps <span style="color:#f92672">=</span> mergeProperties<span style="color:#f92672">();</span>

			<span style="color:#75715e">// Convert the merged properties, if necessary.
</span><span style="color:#75715e"></span>			convertProperties<span style="color:#f92672">(</span>mergedProps<span style="color:#f92672">);</span>

			<span style="color:#75715e">// Let the subclass process the properties.
</span><span style="color:#75715e"></span>			processProperties<span style="color:#f92672">(</span>beanFactory<span style="color:#f92672">,</span> mergedProps<span style="color:#f92672">);</span>
		<span style="color:#f92672">}</span>
		<span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException ex<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
			<span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> BeanInitializationException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Could not load properties&#34;</span><span style="color:#f92672">,</span> ex<span style="color:#f92672">);</span>
		<span style="color:#f92672">}</span>
	<span style="color:#f92672">}</span>


	<span style="color:#a6e22e">@Override</span>
	<span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">processProperties</span><span style="color:#f92672">(</span>ConfigurableListableBeanFactory beanFactoryToProcess<span style="color:#f92672">,</span> Properties props<span style="color:#f92672">)</span>
			<span style="color:#66d9ef">throws</span> BeansException <span style="color:#f92672">{</span>

		StringValueResolver valueResolver <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> PlaceholderResolvingStringValueResolver<span style="color:#f92672">(</span>props<span style="color:#f92672">);</span>
		doProcessProperties<span style="color:#f92672">(</span>beanFactoryToProcess<span style="color:#f92672">,</span> valueResolver<span style="color:#f92672">);</span>
	<span style="color:#f92672">}</span>

	<span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doProcessProperties</span><span style="color:#f92672">(</span>ConfigurableListableBeanFactory beanFactoryToProcess<span style="color:#f92672">,</span>
			StringValueResolver valueResolver<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

		BeanDefinitionVisitor visitor <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BeanDefinitionVisitor<span style="color:#f92672">(</span>valueResolver<span style="color:#f92672">);</span>

		String<span style="color:#f92672">[]</span> beanNames <span style="color:#f92672">=</span> beanFactoryToProcess<span style="color:#f92672">.</span><span style="color:#a6e22e">getBeanDefinitionNames</span><span style="color:#f92672">();</span>
		<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>String curName <span style="color:#f92672">:</span> beanNames<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
			<span style="color:#75715e">// Check that we&#39;re not parsing our own bean definition,
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// to avoid failing on unresolvable placeholders in properties file locations.
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#f92672">(!(</span>curName<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">beanName</span><span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> beanFactoryToProcess<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">beanFactory</span><span style="color:#f92672">)))</span> <span style="color:#f92672">{</span>
				BeanDefinition bd <span style="color:#f92672">=</span> beanFactoryToProcess<span style="color:#f92672">.</span><span style="color:#a6e22e">getBeanDefinition</span><span style="color:#f92672">(</span>curName<span style="color:#f92672">);</span>
				<span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
					visitor<span style="color:#f92672">.</span><span style="color:#a6e22e">visitBeanDefinition</span><span style="color:#f92672">(</span>bd<span style="color:#f92672">);</span>
				<span style="color:#f92672">}</span>
				<span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>Exception ex<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
					<span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> BeanDefinitionStoreException<span style="color:#f92672">(</span>bd<span style="color:#f92672">.</span><span style="color:#a6e22e">getResourceDescription</span><span style="color:#f92672">(),</span> curName<span style="color:#f92672">,</span> ex<span style="color:#f92672">.</span><span style="color:#a6e22e">getMessage</span><span style="color:#f92672">(),</span> ex<span style="color:#f92672">);</span>
				<span style="color:#f92672">}</span>
			<span style="color:#f92672">}</span>
		<span style="color:#f92672">}</span>

		<span style="color:#75715e">// New in Spring 2.5: resolve placeholders in alias target names and aliases as well.
</span><span style="color:#75715e"></span>		beanFactoryToProcess<span style="color:#f92672">.</span><span style="color:#a6e22e">resolveAliases</span><span style="color:#f92672">(</span>valueResolver<span style="color:#f92672">);</span>

		<span style="color:#75715e">// New in Spring 3.0: resolve placeholders in embedded values such as annotation attributes.
</span><span style="color:#75715e"></span>		beanFactoryToProcess<span style="color:#f92672">.</span><span style="color:#a6e22e">addEmbeddedValueResolver</span><span style="color:#f92672">(</span>valueResolver<span style="color:#f92672">);</span>
	<span style="color:#f92672">}</span>


	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">visitBeanDefinition</span><span style="color:#f92672">(</span>BeanDefinition beanDefinition<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
		visitParentName<span style="color:#f92672">(</span>beanDefinition<span style="color:#f92672">);</span>
		visitBeanClassName<span style="color:#f92672">(</span>beanDefinition<span style="color:#f92672">);</span>
		visitFactoryBeanName<span style="color:#f92672">(</span>beanDefinition<span style="color:#f92672">);</span>
		visitFactoryMethodName<span style="color:#f92672">(</span>beanDefinition<span style="color:#f92672">);</span>
		visitScope<span style="color:#f92672">(</span>beanDefinition<span style="color:#f92672">);</span>
		<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>beanDefinition<span style="color:#f92672">.</span><span style="color:#a6e22e">hasPropertyValues</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
			visitPropertyValues<span style="color:#f92672">(</span>beanDefinition<span style="color:#f92672">.</span><span style="color:#a6e22e">getPropertyValues</span><span style="color:#f92672">());</span>
		<span style="color:#f92672">}</span>
		<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>beanDefinition<span style="color:#f92672">.</span><span style="color:#a6e22e">hasConstructorArgumentValues</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
			ConstructorArgumentValues cas <span style="color:#f92672">=</span> beanDefinition<span style="color:#f92672">.</span><span style="color:#a6e22e">getConstructorArgumentValues</span><span style="color:#f92672">();</span>
			visitIndexedArgumentValues<span style="color:#f92672">(</span>cas<span style="color:#f92672">.</span><span style="color:#a6e22e">getIndexedArgumentValues</span><span style="color:#f92672">());</span>
			visitGenericArgumentValues<span style="color:#f92672">(</span>cas<span style="color:#f92672">.</span><span style="color:#a6e22e">getGenericArgumentValues</span><span style="color:#f92672">());</span>
		<span style="color:#f92672">}</span>
	<span style="color:#f92672">}</span>

</code></pre></div></li>
<li>
<p>上面的例子即可以看出BeanFactoryPostProcessor是对BeanFactory进行操作，是Bean还没实例化之前的动作</p>
</li>
</ul>
<h1 id="原理spring-aop">原理Spring AOP</h1>
<ul>
<li>
<p>Xml方式中，aspectj-autoproxy，标签默认创建一个AnnotationAwareAspectJAutoProxyCreator的BeanDefinition，注册到BeanDefinitionRegistry中</p>
</li>
<li>
<p>通过事件发送，通知到注册了</p>
</li>
<li>
<p>在Application的refresh中的finishBeanFactoryInitialization，会实例化该bean</p>
</li>
<li>
<p>AnnotationAwareAspectJAutoProxyCreator实现了Spring的BPP接口</p>
</li>
<li>
<p>正常情况下，AOP会在postProcessAfterInitialization方法执行后，wrapIfNecessary，会去找当前容器里所有的增强器，一个增强器里包含了，切入点，切入方法</p>
</li>
<li>
<p>首先会找到容器里所有的增强器，做缓存处理，对于每一个要获取的Bean都会走这个方法。具体的寻找方法，包括Spring老式的配置，即在XML里配置Bean，使用aop:config里的aop:ref和aop:point_cut，配置出来的，以及现在十分方便的使用aspectJ注解的@Aspect配合@PointCut，@Around，@Before，@After，@Throw</p>
</li>
<li>
<p>然后根据Bean的属性。检查找到的增强其里面是否有满足条件的。即查看是否满足AOP，表达式的，方法</p>
</li>
<li>
<p>如果这个bean有满足的增强器</p>
</li>
<li>
<p>则取获取代理对象，Spring有2中实现代理的方式，JDK自带的Proxy类，以及CGlib</p>
</li>
<li>
<p>JDK和GClib区别</p>
<ul>
<li>JDK只能针对实现了接口的类，生成代理，实现同样的接口方法，但里面调用的还是目标对象的方法</li>
<li>CGLIB是针对类实现代理，通过修改字节码方式，对目标对象生成一个其子类，覆写父类的方法，从而达到代理，所以类不能声明为final</li>
</ul>
</li>
<li>
<p>Spring可以强制使用cglib，配置proxyTargetClass属性为true即可</p>
</li>
<li>
<p>根据上述找到的增强器，Spring根据配置，创建对应的AopProxy，JdkDynamicAopProxy或者CglibAopProxy</p>
</li>
<li>
<p>调用AopProxy的getProxy方法</p>
</li>
<li>
<p>JdkDynamicAopProxy</p>
<ul>
<li>
<p>使用JDK自带的Proxy.newProxyInstance方式创建代理对象</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Proxy<span style="color:#f92672">.</span><span style="color:#a6e22e">newProxyInstance</span><span style="color:#f92672">(</span>classLoader<span style="color:#f92672">,</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">proxiedInterfaces</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
</code></pre></div></li>
<li>
<p>最后一个参数this，说明JdkDynamicAopProxy肯定实现了InvocationHandler，最后执行的目标方法就是invoke方法</p>
</li>
<li>
<p>在这里面处理了expose-proxy属性</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">//AopContext 自身无法获取代理对象的处理 exposeProxy
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">advised</span><span style="color:#f92672">.</span><span style="color:#a6e22e">exposeProxy</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
   <span style="color:#75715e">// Make invocation available if necessary.
</span><span style="color:#75715e"></span>   oldProxy <span style="color:#f92672">=</span> AopContext<span style="color:#f92672">.</span><span style="color:#a6e22e">setCurrentProxy</span><span style="color:#f92672">(</span>proxy<span style="color:#f92672">);</span>
   setProxyContext <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p>然后根据传入的增强器，使用ReflectiveMethodInvocation封装，方法链，逐个调用。不同的advistor使用不同的实现类去实现，例如</p>
<ul>
<li>
<pre tabindex="0"><code>AspectJAroundAdvice
</code></pre><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Override</span>
<span style="color:#a6e22e">@Nullable</span>
<span style="color:#66d9ef">public</span> Object <span style="color:#a6e22e">invoke</span><span style="color:#f92672">(</span>MethodInvocation mi<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Throwable <span style="color:#f92672">{</span>
   <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!(</span>mi <span style="color:#66d9ef">instanceof</span> ProxyMethodInvocation<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalStateException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;MethodInvocation is not a Spring ProxyMethodInvocation: &#34;</span> <span style="color:#f92672">+</span> mi<span style="color:#f92672">);</span>
   <span style="color:#f92672">}</span>
   ProxyMethodInvocation pmi <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>ProxyMethodInvocation<span style="color:#f92672">)</span> mi<span style="color:#f92672">;</span>
   ProceedingJoinPoint pjp <span style="color:#f92672">=</span> lazyGetProceedingJoinPoint<span style="color:#f92672">(</span>pmi<span style="color:#f92672">);</span>
   JoinPointMatch jpm <span style="color:#f92672">=</span> getJoinPointMatch<span style="color:#f92672">(</span>pmi<span style="color:#f92672">);</span>
   <span style="color:#66d9ef">return</span> invokeAdviceMethod<span style="color:#f92672">(</span>pjp<span style="color:#f92672">,</span> jpm<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这也就是为什么@Around的方法，入参可以是ProceedingJoinPoint</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">invokeAdviceMethodWithGivenArgs<span style="color:#f92672">(</span>argBinding<span style="color:#f92672">(</span>jp<span style="color:#f92672">,</span> jpMatch<span style="color:#f92672">,</span> returnValue<span style="color:#f92672">,</span> t<span style="color:#f92672">));</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>直至所有的方法链调用结束</p>
</li>
<li>
<p>最后执行目标方法</p>
</li>
<li>
<p>处理返回对象</p>
</li>
</ul>
</li>
</ul>
<h1 id="springmvc流程">SpringMVC流程</h1>
<p>SpringMvc会使用DispatcherServlet作为请求的入口。</p>
<p>作为一个Servlet，init方法，执行后，DispatcherServlet会创建自己的IOC容器，并且把ServletContext中的IOC作为父容器，所以MVC的相关内容，例如Controller可以放在MVC的IOC中，而其余的，dao，service可以放在SevletContext里的IOC，好处就是隔离开了M层，如果要还Struts，可以直接更换，而不用考虑dao和service了。</p>
<p>init方法，除了创建MVC自己的容器，还根据DispatchServlet.properties里的内容，进行一系列的初始化动作。</p>
<p>DispatcherServlet继承于FrameworkServlet。集成HttpServlet，最后从Servlet会执行到DispatchServlet的processRequest方法。processRequest中，Spring会将当前的请求requestAttributes放在RequestContextHolder中用ThreadLocal保存，所以后续的Controller都可以使用。</p>
<p>随后走到doDispatch中，做一些必要的检查，然后根据容器里的handerMapping找到对应的hanlder，使用HandlerExecutionChain将符合该请求的拦截器，封装在一起，跨域也是在这里增加另一个拦截器</p>
<p>准备好HandlerExecutionChain之后，进入流程。先调用所有的拦截器preHandler方法</p>
<p>Handler有很多种，最后使用适配器模式，创建handlerAdapter去调用不同handler的具体执行方法。从而得到modelAndView</p>
<p>然后调用拦截器的postHandler方法</p>
<p>得到modelAndView，之后会使用ViewRovler解析view，最后获取requestDispatcher，forward或者是重定向到新的路径，并且把model，放入request的attribute里，从而进入下一个请求了，可以是reward也可以是redirect</p>
<h2 id="为什么在controller的方法参数里写httpservletrequest就可以获得到请求对象以及requestbody和requestparam">为什么在Controller的方法参数里，写HttpServletRequest就可以获得到请求对象，以及@RequestBody和@RequestParam</h2>
<p>不管是xml中配置<a href="mvc:annotation-driven/">mvc:annotation-driven/</a>，还是使用注解@EnableWebMvc，本质上都是在容器中注入了RequestMappingHandlerMapping这样的实例。实例实现了initalizingBean接口，在容器中实例化的时候，会将容器中所有的Bean找出来，检查Class是否被@Controller或者@RequestMapping修饰，找到即作为一个handler。</p>
<p>然后去找到Hanlder对应的adapter，RequestMappingHandlerAdapter，Adapter的handler方法。</p>
<p>hanlder方法的核心是，invokeHandlerMethod，通过反射调用目标方法，并且通过一些列配置，将方法需要的配置传入进去，其中解析方法参数的就是一些列的argumentResolvers。</p>
<p>Spring依然是在RequestMappingHandlerAdapter的afterPropertiesSet()方法之后，。初始化了argumentResolvers</p>
<p>如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> List<span style="color:#f92672">&lt;</span>HandlerMethodArgumentResolver<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">getDefaultArgumentResolvers</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
   List<span style="color:#f92672">&lt;</span>HandlerMethodArgumentResolver<span style="color:#f92672">&gt;</span> resolvers <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;(</span>30<span style="color:#f92672">);</span>

   <span style="color:#75715e">// Annotation-based argument resolution
</span><span style="color:#75715e"></span>   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> RequestParamMethodArgumentResolver<span style="color:#f92672">(</span>getBeanFactory<span style="color:#f92672">(),</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">));</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> RequestParamMapMethodArgumentResolver<span style="color:#f92672">());</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> PathVariableMethodArgumentResolver<span style="color:#f92672">());</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> PathVariableMapMethodArgumentResolver<span style="color:#f92672">());</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> MatrixVariableMethodArgumentResolver<span style="color:#f92672">());</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> MatrixVariableMapMethodArgumentResolver<span style="color:#f92672">());</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ServletModelAttributeMethodProcessor<span style="color:#f92672">(</span><span style="color:#66d9ef">false</span><span style="color:#f92672">));</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> RequestResponseBodyMethodProcessor<span style="color:#f92672">(</span>getMessageConverters<span style="color:#f92672">(),</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">requestResponseBodyAdvice</span><span style="color:#f92672">));</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> RequestPartMethodArgumentResolver<span style="color:#f92672">(</span>getMessageConverters<span style="color:#f92672">(),</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">requestResponseBodyAdvice</span><span style="color:#f92672">));</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> RequestHeaderMethodArgumentResolver<span style="color:#f92672">(</span>getBeanFactory<span style="color:#f92672">()));</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> RequestHeaderMapMethodArgumentResolver<span style="color:#f92672">());</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ServletCookieValueMethodArgumentResolver<span style="color:#f92672">(</span>getBeanFactory<span style="color:#f92672">()));</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ExpressionValueMethodArgumentResolver<span style="color:#f92672">(</span>getBeanFactory<span style="color:#f92672">()));</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> SessionAttributeMethodArgumentResolver<span style="color:#f92672">());</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> RequestAttributeMethodArgumentResolver<span style="color:#f92672">());</span>

   <span style="color:#75715e">// Type-based argument resolution
</span><span style="color:#75715e"></span>   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ServletRequestMethodArgumentResolver<span style="color:#f92672">());</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ServletResponseMethodArgumentResolver<span style="color:#f92672">());</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> HttpEntityMethodProcessor<span style="color:#f92672">(</span>getMessageConverters<span style="color:#f92672">(),</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">requestResponseBodyAdvice</span><span style="color:#f92672">));</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> RedirectAttributesMethodArgumentResolver<span style="color:#f92672">());</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ModelMethodProcessor<span style="color:#f92672">());</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> MapMethodProcessor<span style="color:#f92672">());</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ErrorsMethodArgumentResolver<span style="color:#f92672">());</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> SessionStatusMethodArgumentResolver<span style="color:#f92672">());</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> UriComponentsBuilderMethodArgumentResolver<span style="color:#f92672">());</span>
   <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>KotlinDetector<span style="color:#f92672">.</span><span style="color:#a6e22e">isKotlinPresent</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
      resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ContinuationHandlerMethodArgumentResolver<span style="color:#f92672">());</span>
   <span style="color:#f92672">}</span>

   <span style="color:#75715e">// Custom arguments
</span><span style="color:#75715e"></span>   <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>getCustomArgumentResolvers<span style="color:#f92672">()</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">addAll</span><span style="color:#f92672">(</span>getCustomArgumentResolvers<span style="color:#f92672">());</span>
   <span style="color:#f92672">}</span>

   <span style="color:#75715e">// Catch-all
</span><span style="color:#75715e"></span>   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> PrincipalMethodArgumentResolver<span style="color:#f92672">());</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> RequestParamMethodArgumentResolver<span style="color:#f92672">(</span>getBeanFactory<span style="color:#f92672">(),</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">));</span>
   resolvers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ServletModelAttributeMethodProcessor<span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">));</span>

   <span style="color:#66d9ef">return</span> resolvers<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>通过 HandlerMethodArgumentResolver的supportsParameter方法</p>
<p>以RequestParam为例</p>
<p>首先RequestParamMethodArgumentResolver的父类AbstractNamedValueMethodArgumentResolver，进行校验，校验Hanlder的参数是否是必填，会将@RequestParams的required进行校验，从HttpServletRequest里的parameter进行校验。校验成功，会通过反射执行handler，并将参数传入Handler中。</p>
<p>@RequestBody也是一样，使用的RequestResponseBodyMethodProcessor去处理参数的</p>
<p>在处理@RequestBody的时候，RequestMappingHandlerAdapter的所有messageConverters，找到符合的，我们常用的application/json就是MappingJackson2HttpMessageConverter，需要引入jackson的核心包</p>
<p>至于其他的Httpservlet都是是同对应的argumentResolve处理的</p>
<h1 id="springboot的工作原理">SpringBoot的工作原理</h1>
<p>Spring在诞生之初，配置类一直是令开发者吐槽的模块，当java5推出注解后，可以使用java类进行配置了，但依然很繁琐。而SpringBoot的最大的一个特点，就是解决复杂的配置。</p>
<p>SpringBoot推出了一系列注解，他们可以将各类Spring boot starter，无感的注入到容器中。</p>
<p>SpringBoot在SpringBoot的run方法里，完成了一些列工作。</p>
<p>首先是构造方法会根据当前类路径下是否包含webflux，或者servlet相关类，从而决定实例化的容器对象。</p>
<p>以常见的servlet为例，SpringBoot会实例化AnnotationConfigServletWebServerApplicationContext</p>
<p>而在SpringBoot构造函数触发时，会寻找类路径下META/Spring.factories文件，下所有的ApplicationContextInitializer实例，和ApplicationListener实例，并且放入当前对象的属性中</p>
<ul>
<li>
<p>核心的run方法，里首先还是从spring.factories里找到所有的SpringApplicationRunListener，调用其starting方法，</p>
</li>
<li>
<p>然后封装main方法的arg参数，校验环境，即我们可以在外部指明spring的profile.active=prod就是在这里指明的</p>
</li>
<li>
<p>准备好main的arg以及sytem的相关属性后，会调用所有SpringApplicationRunListener的environmentPrepared，也就是在这里面进行了Spring配置文件，application.yml或者是application.properties的处理</p>
</li>
<li>
<p>打印Banner</p>
</li>
<li>
<p>根据上述得到的实例化Class，实例化IOC容器</p>
</li>
<li>
<p>从spring.factories里找到SpringBootExceptionReporter用于异常打印</p>
</li>
<li>
<p>准备名称生成器，资源加载器，类加载器等。</p>
</li>
<li>
<p>调用Spring.factories里的ApplicationContextInitializer的initialize方法</p>
</li>
<li>
<p>调用ApplicationContextInitializer的contextPrepared方法</p>
</li>
<li>
<p>打印启动类信息，打印profile信息</p>
</li>
<li>
<p>加载启动类的注解信息，即启动类也可以是一个组件，<strong>注入到容器中</strong>，默认情况下，@SpringBootApplication里的@SpringBootConfiguration里有@Component注解，Spring会通过注解方式将其注入到容器中，细节就不说了，核心是@SpringBootConfiguration身上有@Configuration，而且有@Import注解，引入的是AutoConfigurationImportSelector</p>
<p>SpringBoot在启动的时候，注入了ConfigurationClassPostProcessor该类实现了BeanDefinitionRegistryPostProcessor会在容器的refresh里的invokeBeanFactoryPostProcesser，里触发</p>
<p>postProcessBeanDefinitionRegistry方法，会找到容器里所有的@Configuration实例，这里此时容器里有的就是启动类本身，然后会处理，@Configuration上的@Import，并且执行@Import类的process方法，即，最后依然调用的是selectImports方法，得到的就是Spring.factories里配置的**org.springframework.boot.autoconfigure.EnableAutoConfiguration=**的值，然后逐步解析所有的类，这样容器里就有第三方调用的所有信息了</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">process</span><span style="color:#f92672">(</span>AnnotationMetadata annotationMetadata<span style="color:#f92672">,</span>
      DeferredImportSelector deferredImportSelector<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
   Assert<span style="color:#f92672">.</span><span style="color:#a6e22e">state</span><span style="color:#f92672">(</span>
         deferredImportSelector <span style="color:#66d9ef">instanceof</span> AutoConfigurationImportSelector<span style="color:#f92672">,</span>
         <span style="color:#f92672">()</span> <span style="color:#f92672">-&gt;</span> String<span style="color:#f92672">.</span><span style="color:#a6e22e">format</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Only %s implementations are supported, got %s&#34;</span><span style="color:#f92672">,</span>
               AutoConfigurationImportSelector<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getSimpleName</span><span style="color:#f92672">(),</span>
               deferredImportSelector<span style="color:#f92672">.</span><span style="color:#a6e22e">getClass</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()));</span>
   AutoConfigurationEntry autoConfigurationEntry <span style="color:#f92672">=</span> <span style="color:#f92672">((</span>AutoConfigurationImportSelector<span style="color:#f92672">)</span> deferredImportSelector<span style="color:#f92672">)</span>
         <span style="color:#f92672">.</span><span style="color:#a6e22e">getAutoConfigurationEntry</span><span style="color:#f92672">(</span>getAutoConfigurationMetadata<span style="color:#f92672">(),</span>
               annotationMetadata<span style="color:#f92672">);</span>
   <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">autoConfigurationEntries</span><span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>autoConfigurationEntry<span style="color:#f92672">);</span>
   <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>String importClassName <span style="color:#f92672">:</span> autoConfigurationEntry<span style="color:#f92672">.</span><span style="color:#a6e22e">getConfigurations</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">entries</span><span style="color:#f92672">.</span><span style="color:#a6e22e">putIfAbsent</span><span style="color:#f92672">(</span>importClassName<span style="color:#f92672">,</span> annotationMetadata<span style="color:#f92672">);</span>
   <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">protected</span> AutoConfigurationEntry <span style="color:#a6e22e">getAutoConfigurationEntry</span><span style="color:#f92672">(</span>
      AutoConfigurationMetadata autoConfigurationMetadata<span style="color:#f92672">,</span>
      AnnotationMetadata annotationMetadata<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
   <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>isEnabled<span style="color:#f92672">(</span>annotationMetadata<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">return</span> EMPTY_ENTRY<span style="color:#f92672">;</span>
   <span style="color:#f92672">}</span>
   AnnotationAttributes attributes <span style="color:#f92672">=</span> getAttributes<span style="color:#f92672">(</span>annotationMetadata<span style="color:#f92672">);</span>
   List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> configurations <span style="color:#f92672">=</span> getCandidateConfigurations<span style="color:#f92672">(</span>annotationMetadata<span style="color:#f92672">,</span><span style="color:#75715e">//获取到所有的/META-INF/spring-factories中的configuration
</span><span style="color:#75715e"></span>         attributes<span style="color:#f92672">);</span>
   configurations <span style="color:#f92672">=</span> removeDuplicates<span style="color:#f92672">(</span>configurations<span style="color:#f92672">);</span><span style="color:#75715e">//删除重复的
</span><span style="color:#75715e"></span>   Set<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> exclusions <span style="color:#f92672">=</span> getExclusions<span style="color:#f92672">(</span>annotationMetadata<span style="color:#f92672">,</span> attributes<span style="color:#f92672">);</span>
   checkExcludedClasses<span style="color:#f92672">(</span>configurations<span style="color:#f92672">,</span> exclusions<span style="color:#f92672">);</span><span style="color:#75715e">//根据上面的属性excclusion
</span><span style="color:#75715e"></span>   configurations<span style="color:#f92672">.</span><span style="color:#a6e22e">removeAll</span><span style="color:#f92672">(</span>exclusions<span style="color:#f92672">);</span>
   configurations <span style="color:#f92672">=</span> filter<span style="color:#f92672">(</span>configurations<span style="color:#f92672">,</span> autoConfigurationMetadata<span style="color:#f92672">);</span>
   fireAutoConfigurationImportEvents<span style="color:#f92672">(</span>configurations<span style="color:#f92672">,</span> exclusions<span style="color:#f92672">);</span><span style="color:#75715e">//通知导入成功
</span><span style="color:#75715e"></span>   <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> AutoConfigurationEntry<span style="color:#f92672">(</span>configurations<span style="color:#f92672">,</span> exclusions<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
</ul>
<h1 id="spring事务">Spring事务</h1>
<ul>
<li>
<p>Spring使用注解@Transactional放在方法，或者类上</p>
</li>
<li>
<p>@Transactional属性有</p>
<ul>
<li>transactionManager指明事务管理器，在多数据源的时候，需要指明</li>
<li>propagation传播行为默认是Propagation.REQUIRED，即当前如果存在事务，则用同一个事务，否则开启一个新事务</li>
<li>isolation隔离级别，默认是数据库的隔离级别，mysql默认时可重复度，幻读是通过MVCC和间隙锁解决的</li>
<li>timeout超时时间</li>
<li>readOnly是否只读</li>
<li>rollbackFor发生什么异常才会会滚，默认是RuntimeException</li>
<li>rollbackForClassName</li>
<li>noRollbackFor</li>
<li>noRollbackForClassName</li>
</ul>
</li>
<li>
<p>原理，@Transactional注解是基于AOP原理，容器在获取相应bean的时候，会去使用wrapifNecessary包装bean，Spring的流程是，从容器里找到所有的adviser，而@Transactional会在容器里注入BeanFactoryTransactionAttributeSourceAdvisor，从而最后得到的是代理对象，而代理对象针对于满足切面条件的bean，会做处理，@Transactional就是切面条件，会在目标方法执行之前开启一个事务，执行之后提交或者回滚一个事务，操作事务的都是TransactionManager</p>
</li>
<li>
<p>提问</p>
<ul>
<li>
<p>如果在一个方法里异常被try-catch了，还会会滚吗？不会了，因为Sping处理提交事务是在切面的AfterRunning之后提交的，在那之前会使用try-catch捕捉，而目标自己捕捉过的话，Spring就捕捉不到了，除非在catch里再抛出</p>
</li>
<li>
<p>如果自己使用TransactionManager重新在获取一个事务，手动提交之前，抛出异常的话，会会滚吗？不会，会被Spring捕捉到</p>
</li>
<li>
<p>如果在抛出异常之前，就手动提交了，Spring会回滚吗，可能会 也可能不会，这和Spring事务的传播行为有关，默认情况下传播行为是，如果当前有事务了，就用当前事务，否则开启一个新事务。</p>
<p>如果有@Transactional注解了，意味着Spring已经开启了一个事务了，后续自己手动开启的事务，就是之前的事务了，并非一个新事务，Spring在提交事务之前，会判断是否为一个新事务，是的话，才会进行提交，否则不会有动作。所有如果传播行为不变的话，会回滚的，如果是强制开启新的事务的传播行为，则不会会滚</p>
</li>
</ul>
</li>
</ul>
<h1 id="讲讲你会的设计模式spring里面用到了哪些设计模式">讲讲你会的设计模式，Spring里面用到了哪些设计模式</h1>
<h1 id="java中的date是线程安全的吗你是如何保证线程安全的">Java中的Date是线程安全的吗？你是如何保证线程安全的</h1>
<h1 id="讲讲threadlocal-和java的内存模型吧">讲讲ThreadLocal 和java的内存模型吧</h1>
<h1 id="webasynctask">WebAsyncTask</h1>
<p>WebAsyncTask，是基于Servlet3.0异步Servlet的特性，用于提高容器的吞吐量，客户端请求进来时，当前的容器分配的线程会直接返回，并会开启一个新线程用于处理客户端请求，当新线程结束时，客户端才会收到请求。而容器的线程就可以回收用于新的请求，提高了吞吐量</p>
<h2 id="拦截器和过滤器的区别">拦截器和过滤器的区别</h2>
<p>首先，拦截器与过滤器不是一起的，拦截器是Spring的，而过滤器filter是javax提供的，filter会在拦截器之前执行，拦截器可以达到更细粒控制请求。拦截器可以获得到具体执行的handler，可以对handler做个性化操作。过滤器可以做的，拦截器都可以做到，拦截器做的，过滤器做不了。</p>
<h1 id="聊一下mybatis">聊一下mybatis</h1>
<h2 id="什么是mybatis的懒加载">什么是mybatis的懒加载</h2>
<h2 id="mybatis的mapper是如何与数据库连接的">mybatis的mapper是如何与数据库连接的</h2>
<h1 id="什么是索引索引为什么可以加查询">什么是索引，索引为什么可以加查询</h1>
<h1 id="innodb索引实现">Innodb索引实现</h1>
<h1 id="b树和b树">B树和B+树</h1>
<h1 id="redis使用部署哨兵">Redis使用，部署，哨兵</h1>
<h1 id="tcp三次握手">TCP三次握手</h1>
<h1 id="乐观锁悲观锁举例">乐观锁，悲观锁，举例</h1>
<h1 id="设计模式">设计模式</h1>
<h1 id="redis扩容">Redis扩容</h1>
<h1 id="cas概念原子类的实现">CAS概念，原子类的实现</h1>
<h1 id="synchronize-底层原理">Synchronize 底层原理</h1>
<h1 id="aqs">AQS</h1>
<h1 id="网络模型你知道的网络协议">网络模型，你知道的网络协议</h1>
<h1 id="https的连接过程ssl">HTTPS的连接过程，SSL</h1>
<h1 id="单链表算法反转查找">单链表算法，反转，查找</h1>
<h1 id="jvm垃圾回收机制">jvm垃圾回收机制</h1>
<h1 id="工作流引擎">工作流引擎</h1>
<h1 id="spring-mvc-webflux">Spring MVC webFlux</h1>
<h1 id="netty">netty</h1>
<h1 id="redis为什么这么快">redis为什么这么快</h1>
<h1 id="mysql的explain">Mysql的explain</h1>
<h1 id="k8s">K8S</h1>
<h1 id="讲一讲反射以及你工作中用到的地方">讲一讲反射，以及你工作中用到的地方</h1>
<p>java反射，提供给我们方式去动态创建类，或者是动态执行方法，当我们因为某些条件，不知道目标应该执行什么方法的时候，就可以使用反射。</p>
<p>例如，请假，如果超过2天，就执行某方法，否则执行另一个方法，我们就可以用反射</p>
<p>反射也被大量应用于mybatis和spring之中，spring中aop，创建bean的动作都是反射，因为他们无论是执行方法还是构建实例都是未知的参数和条件</p>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/spring/" rel="tag">Spring</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="Frank Silva avatar" src="/img/avatar.png" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">About Frank Silva</span>
	</div>
	<div class="authorbox__description">
		Pursue Consummate Coding.
	</div>
</div>

<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/post/%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">八股文</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/post/reactor/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Reactor响应式编程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 Frank Silva.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
<script src="/js/custom.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>
</body>
</html>