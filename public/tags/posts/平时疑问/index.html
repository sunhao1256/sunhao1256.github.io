<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>平时疑问 - Luluhome - a blog for sh , &#39;lulu&#39; is my cat</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="sh" /><meta name="description" content="平时疑问 浏览器输入一个地址，整个流程 如果线上流量暴增，全都打到一个 upstream 上了，怎么排查 如何在 nginx 的 access log 中查出请求前 10 的 ip 台阶问题，假如对于上台阶，" /><meta name="keywords" content="luluhome, java, blog" />






<meta name="generator" content="Hugo 0.89.0 with theme even" />


<link rel="canonical" href="http://luluhome.site/posts/%E5%B9%B3%E6%97%B6%E7%96%91%E9%97%AE/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="平时疑问" />
<meta property="og:description" content="平时疑问 浏览器输入一个地址，整个流程 如果线上流量暴增，全都打到一个 upstream 上了，怎么排查 如何在 nginx 的 access log 中查出请求前 10 的 ip 台阶问题，假如对于上台阶，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://luluhome.site/posts/%E5%B9%B3%E6%97%B6%E7%96%91%E9%97%AE/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-11T14:43:18+08:00" />
<meta property="article:modified_time" content="2022-01-11T14:43:18+08:00" />

<meta itemprop="name" content="平时疑问">
<meta itemprop="description" content="平时疑问 浏览器输入一个地址，整个流程 如果线上流量暴增，全都打到一个 upstream 上了，怎么排查 如何在 nginx 的 access log 中查出请求前 10 的 ip 台阶问题，假如对于上台阶，"><meta itemprop="datePublished" content="2022-01-11T14:43:18+08:00" />
<meta itemprop="dateModified" content="2022-01-11T14:43:18+08:00" />
<meta itemprop="wordCount" content="14814">
<meta itemprop="keywords" content="自问自答," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="平时疑问"/>
<meta name="twitter:description" content="平时疑问 浏览器输入一个地址，整个流程 如果线上流量暴增，全都打到一个 upstream 上了，怎么排查 如何在 nginx 的 access log 中查出请求前 10 的 ip 台阶问题，假如对于上台阶，"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">luluhome</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">luluhome</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <div class="post-content">
    <h1 id="平时疑问">平时疑问</h1>
<ul>
<li>
<p>浏览器输入一个地址，整个流程</p>
</li>
<li>
<p>如果线上流量暴增，全都打到一个 upstream 上了，怎么排查</p>
</li>
<li>
<p>如何在 nginx 的 access log 中查出请求前 10 的 ip</p>
</li>
<li>
<p>台阶问题，假如对于上台阶，可以一次上一阶，也可以一次上两阶，写一个方法，实现输入台阶数，输出可以有多少种上法。</p>
</li>
<li>
<p>广度优先和深度优先</p>
</li>
<li>
<p>spring reactive，响应式聊下，什么时候适合用？背压是什么东西，backpress</p>
</li>
<li>
<p>压缩算法，怎么就“压缩”了？如何减少体积的？</p>
</li>
<li>
<p>实时一致性，最终一致性是什么？什么场景下用那种，如何实现的？</p>
<ul>
<li>
<p>实时一致性:</p>
<p>微服务中，场景用户使用积分兑换优惠券，积分service先扣除积分，优惠券service再进行发券动作，如果网络问题，积分扣成功了，但是优惠券发失败了。用户会投诉，必须要证优惠券和积分要在同一个分布式事务中.</p>
<p>解决方案：市面上的分布式事务，阿里的seata</p>
</li>
<li>
<p>最终一致性:</p>
<p>微服务中，用户选择商品下单，商品service进行库存扣件，订单service生成订单，交易service生成交易订单。如果网络原因导致，交易service生成交易订单失败了。并没有影响，只需要通过措施重新弥补交易service去生成交易订单即可。</p>
<p>解决方法：mq，通过mq的重试机制以及持久化等特性，每一个微服务与下游微服务进行交互动作都是通过mq的消息。保证消息能够被消费，长时间未消费可以告警。</p>
</li>
</ul>
</li>
<li>
<p>消息堆积如何处理？以及产生的危害。</p>
</li>
<li>
<p>怎么保证接口幂等</p>
</li>
<li>
<p>如何评判一个服务的好坏？你是如何进行压测的？查看了哪些指标</p>
</li>
<li>
<p>对象存储，文件存储，块存储。区别</p>
</li>
<li>
<p>服务器卡了，字都快打不动了，咋回事，怎么排查</p>
</li>
<li>
<p>用过mysql行锁吗</p>
<p>用过，在一些比较简单的微服务场景，或者无法使用其他中间件的前提下。如果需要部署多节点的话，最方便的分布式锁就是mysql，因为我们的db库基本都是单节点的mysql或者mariadb。使用起来其实很简单，就是一个update语句，更新version字段。也就是所谓的乐观锁。开启一个事务，先select锁，然后尝试更新锁，在没完成业务的之前是不提交锁的，所以，其他线程会在获取锁的时候就停下来。因为update，delete，insert默认都是带for update，即行锁的。当然select不会阻塞，除非主动的设置for update。这样就是最基础的一个分布式锁了。切记锁字段必须要有索引，否则锁整个表。就G了</p>
</li>
<li>
<p>netty玩过吗，玩过哪些东西，能干啥</p>
</li>
<li>
<p>你看过一个springboot的启动内存吗？大吗？为啥这么大，怎么瘦身呢，为什么一个go就只要几十M</p>
</li>
<li>
<p>activity7了解过吗</p>
</li>
<li>
<p>规则引擎了解了解？</p>
</li>
<li>
<p>git cherry-pick是啥</p>
</li>
<li>
<p>你们平时是如何开发的，用jira，说说jira的几个问题类型，epic，之类的。</p>
</li>
<li>
<p>大量sql都超过了200ms。怎么排查</p>
</li>
<li>
<p>你写了一个服务，怎么压测的？怎么得到qps,qps的计算公式</p>
</li>
<li>
<p>为什么main线程执行结束了，jvm虚拟机还不退出。</p>
<p>jvm退出的条件是，当前虚拟机中只存在守护线程了，只要存活非守护线程，则jvm不会退出直到线程执行完毕。所以，如果你用了一个有多线程功能的包，但是测试的时候，main线程结束的，整个jvm都退出了，原因就是这个包，创建线程的时候是守护线程。当然main线程是不可以设为守护线程的。</p>
</li>
<li>
<p>字典树有什么场景可以使用？</p>
</li>
<li>
<p>amd64,arm64,x86_64,aarch,都是啥</p>
</li>
<li>
<p>背压理解吗，微服务中下游服务扛不住并发会崩了。有实战过吗</p>
<p>场景：A服务调用B服务某个接口。耗时，并且需要资源巨大的接口。B不一定是你自己的微服务，可能是别人提供的部署在公网环境的服务。客户端通过A接口调用B，现在要求B不能崩，而且A的接口需要全部请求下来，不能丢，可以异步。
方案：mq</p>
</li>
<li>
<p>GRPC是什么，用过吗</p>
</li>
<li>
<p>脑裂</p>
</li>
<li>
<p>rabbitmq怎么保证顺序消费</p>
</li>
<li>
<p>laas、paas、saas</p>
<p><strong>IaaS（Infrastructure as a Service，基础架构即服务）是基础层。</strong></p>
<p>在这一层，通过虚拟化、动态化将IT基础资源（计算、网络、存储）聚合形成资源池。</p>
<p>资源池即计算能力的集合，终端用户（企业）可以通过网络获得自己需要的计算资源，运行自己的业务系统。</p>
<p>这种方式使用户不必自己建设这些基础设施，而是通过付费即可使用这些资源。</p>
<p><strong>在IaaS层之上的是PaaS（Platform as a Service，平台即服务）层。</strong></p>
<p>这一层除了提供基础计算能力，还具备了业务的开发运行环境，提供包括应用代码、SDK、操作系统以及API在内的IT组件，供个人开发者和企业将相应功能模块嵌入软件或硬件，以提高开发效率。</p>
<p>对于企业或终端用户而言，这一层的服务可以为业务创新提供快速、低成本的环境。</p>
<p><strong>最上层是SaaS（Software as a Service，软件即服务）。</strong></p>
<p>实际上，SaaS在云计算概念出现之前就已经存在，并随着云计算技术的发展得到了更好的发展。</p>
<p>SaaS的软件是**“拿来即用”**的，不需要用户安装，软件升级与维护也无须终端用户参与。</p>
<p>同时，它还是按需使用的软件，与传统软件购买后就无法退货相较具有无可比拟的优势。</p>
</li>
<li>
<p>k8s为什么要有pod这一层概念</p>
</li>
<li>
<p>tcp协议和upd协议的区别，各自的特性，怎么实现的，例如tcp的顺序是如何保证的</p>
</li>
<li>
<p>redis是如何做高可用的</p>
</li>
<li>
<p>什么是ACID，redis的事务怎么保证</p>
</li>
<li>
<p>mysql是怎么实现可重复度的，又是怎么解决幻读的</p>
</li>
<li>
<p>什么是xss攻击，如何避免</p>
</li>
<li>
<p>ddos怎么避免</p>
</li>
<li>
<p>redis的数据结构，你用过哪些</p>
</li>
<li>
<p>怎么限流</p>
</li>
<li>
<p>hashmap的实现，红黑树变链表，等操作具体</p>
</li>
<li>
<p>jvm你能说出多少，生产上遇到过什么问题吗？怎么排查的</p>
</li>
<li>
<p>http1.0，http1.1，http2.0的区别，https的交互流程</p>
</li>
<li>
<p>什么是长链接，http的keepAlive和tcp的keepAlive区别？</p>
</li>
<li>
<p>rpc是什么，你用过什么rpc框架，他们有什么区别。thrift，gprc？</p>
</li>
<li>
<p>聊聊设计模式。</p>
</li>
<li>
<p>new一个对象，jvm里面做了哪些事情</p>
</li>
<li>
<p>voliate关键字</p>
</li>
<li>
<p>java锁相关知识</p>
</li>
<li>
<p>class是如何加载的；</p>
</li>
<li>
<p>对jvm的了解，参数的相关设置，如何调优；</p>
</li>
<li>
<p>内存突然达到100%，再脱离查看日志的情况下，如何定位系统的问题，快速找到相应代码问题；</p>
</li>
<li>
<p>线程的执行过程，线程是如何判定死亡的，如何回收的；</p>
</li>
<li>
<p>线程池的种类有多少种，相关参数的了解；</p>
</li>
<li>
<p>mysql索引的实现原理，建立索引的原则，对排序的认识；</p>
</li>
<li>
<p>动态sql的了解，对#和$的了解，有什么区别，为什么#会防止sql注入，是如何实现的；</p>
</li>
<li>
<p>mybatis的实现原理，sql如何执行的，执行器有多少种；</p>
</li>
<li>
<p>对集合的了解，如何考虑线程安全问题；</p>
</li>
<li>
<p>谈谈对设计模式的了解；</p>
</li>
<li>
<p>过滤器采用了什么设计模式；</p>
</li>
<li>
<p>数据消费如何保证数据顺序，非rabbitmq，kafka如何保证顺序；</p>
</li>
<li>
<p>接口设计如何确保安全，谈谈对api安全设计；</p>
</li>
<li>
<p>redis不采用集群模式下，如何考虑单点问题；</p>
</li>
<li>
<p>redis乐观锁的实现，调用什么方法；</p>
</li>
<li>
<p>redis的数据格式有多少种，常用方法有</p>
</li>
<li>
<p>如何处理依赖冲突</p>
</li>
<li>
<p>nginx权重策略有多少种，分配权重使用什么模块</p>
</li>
<li>
<p>多台服务下如何指定相应请求只会请求到固定服务</p>
</li>
<li>
<p>nginx限流如何实现的</p>
</li>
<li>
<p>springboot如何如何控制加载不同环境的配置的</p>
</li>
<li>
<p>常用依赖注入用什么注解；</p>
</li>
<li>
<p>spring容器有多少种；</p>
</li>
<li>
<p>工厂模式产出物是什么；</p>
</li>
<li>
<p>mysql有哪些情况是不走索引的；</p>
</li>
<li>
<p>mysql为什么通配符不走索引？怎么使用才走索引？</p>
<p>通配符即%，</p>
<p>正确用法是WHERE Title LIKE &lsquo;cake%';不能是WHERE Title LIKE &lsquo;%cake%';</p>
<p>如果我非要%cake%查询呢，怎么做？</p>
</li>
<li>
<p>分散性大的数据建索引还是小的？</p>
<p>大的，如果是小的，你想一下索引的数据结构。B+tree，</p>
</li>
<li>
<p>graphql知道是啥吗</p>
</li>
<li>
<p>一个类是怎么加载进jvm的</p>
<p>同样的问题，.java文件是怎么加载进jvm的？</p>
<p>.java文件通过4个步骤</p>
<ol>
<li>
<p>编译</p>
<p>将.java源文件,编译成JVM可以解释的class文件, 编译过程包括语法分析,语义分析,注解处理. 然后才生成字节码文件(.class文件). 我们常用的lombok就是在这个环节生成字节码文件的.</p>
</li>
<li>
<p>加载</p>
</li>
<li>
<p>解释</p>
</li>
<li>
<p>执行</p>
</li>
</ol>
</li>
<li>
<p>gc的回收过程</p>
</li>
<li>
<p>jvm的各个区作用</p>
</li>
<li>
<p>你平时用@Autowired还是构造方法注入bean，有什么区别</p>
<p>都可以使用, 但是构造方法比属性注入来说又一下几个好处,而官方也更推荐用构造函数注入</p>
<ul>
<li>使用构造函数能够清晰表明,当前这个bean的依赖关系,更好的排查. 当在config类下注入bean的时候,是没有办法丢是构造参数的</li>
<li>所有的依赖可以写成final, 这提高了程序的健壮性并且线程安全.
<ul>
<li>提问final修饰有什么不一样的? 在多线程的情况下如果不通过其他例如Synchronized或者Volatile的方式, 一个线程创建的对象,另一个线程来看的话可能是不可用,或者看不到的, 主要原因是语意重排了.</li>
</ul>
</li>
<li>你不需要反射去创建这些依赖了,可以直接通过构造函数创建.</li>
</ul>
</li>
<li>
<p>为什么spring还要prototype?</p>
<ol>
<li>首先使用prototype的常用方式是注解@scope, value是”prototype“.</li>
<li>我们用spring 的目的是什么? 使用spring 提供的AOP和IOC功能, 那这个前提就必须是你的bean得是spring托管的, 因此当我们使用多例的时候,如果直接new关键字, 那就不能走spring了, 那你的@autowired注解就都实效了</li>
<li>我们一个java项目不可能全部都是单例的bean,  我之前做过需要动态创建task任务, 内部需要引用到redistemplate或者其他Spring容器里的bean, 我如果用new关键字, 我得一个一个传, 那不就是手写了. 所以spring提供了prototype就是为了让我们需要创建多例bean的时候,依然可以使用到spring的整个功能.</li>
</ol>
</li>
<li>
<p>讲一下java的注解</p>
<p>注解实际上是对代码的一种标记. 我们最常用的Spring框架里就包含很多注解,例如@Autowired,@Controller等. 而Java原生的注解有@Overried,@Deprecated,@FunctionalInterface. 这些原生注解多用于检查和标记.</p>
<p>Java还提供给了元注解.@Retention,@Target,<strong>@Retention</strong>注解可以简单理解为设置注解的生命周期，而**@Target**表示这个注解可以修饰哪些地方（比如方法、还是成员变量、还是包等等）</p>
<p>@Retention可以有SOURCE,CLASS和RUNNTIME3的枚举可选,而我们常用的lombok提供的各种注解,都是SOURCE</p>
<blockquote>
<p>SOURCE代表注解仅保留在源码级别,并由编译器忽略.  CLASS代表着注解在编译时保留,但是在JVM中会忽略, 而 RUNNTIME就是标记注解由JVM保留,所以我们能在运行时通过反射获取到它,如果我们想要在编译期间处理相关逻辑的话,就得继承AbstractProcessor,而Lombok就是实现了他自己的AnnotationProcessor,这里可以看到内部的逻辑</p>
</blockquote>
<p>这也就是为什么我们写一个@Data就能够有set/get方法了.而平时我们,用的最多的就是RUNNTIME的注解,配合上SpringAOP,可以做很多事情,例如日志的采集,异常的处理等等</p>
</li>
<li>
<p>说一下HashMap吧</p>
<p>首先HashMap采用的是key/value的结构,通过一个key获取一个value的时候,时间复杂度可以达到O(1),赋值的时候也是一样快,但是它是不安全的,且是无序的.</p>
<blockquote>
<p>为什么是无序呢?</p>
<p>HashMap中元素的遍历是按照从数组起始位置开始,首先将当前bucket下的所有元素遍历完成,然后到下一个bucket,bucket与bucket之间如果为空就跳到下一个bucket,直到将所有的元素遍历出来.显而易见,元素插入的位置并不是这样的顺序,因此才说HashMap是无序的</p>
</blockquote>
<p>HashMap中,采用的的数据结构是<strong>数组+链表+红黑树</strong>,插入的一个逻辑是,算出Key的hash值,在数组中找到hash值对应的位置,这个位置称为桶,如果这个位置有数据了,则通过链表的方式链接在这个数据之后.当单个桶链表的长度大于等于8个并且桶的数量大于64的时候,会进化成红黑树.当红黑树的个数小于等于6的时候,则退化为链表.</p>
<blockquote>
<p>数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数，所以当元素数量非常多的时候，转化为红黑树能极大地提高效率。</p>
</blockquote>
<p>至于为什么6退化,而8进化,我也不是很清楚&hellip;.</p>
</li>
<li>
<p>说一下java的泛型</p>
<p>泛型其实就是在创建对象或者调用方法的时候,才会具体明确具体的类型,具体到代码里就是不需要强制转换,代码更加简洁.  程序会更加健壮,在编译器没有警告,运行的时候就不会出现ClassCastException的异常了</p>
<p>平时也有用过,最常见的Spring的JPA,或者Mybatis Plus里也有BaseMapper. 平时自己写的时候,用到泛型离不开反射(能在运行时获取信息),一般都会通过反射去判断类型,获取属性值,再进行业务逻辑操作的</p>
</li>
<li>
<p>不和你多逼逼,先说说各种IO吧</p>
</li>
<li>
<p>gc说说吧,CMS是什么</p>
<p>首先说下CMS,CMS是一种GC算法,全称是Concurrent-Mark-Sweep.是我们最常用的垃圾回收算法</p>
<blockquote>
<p>CMS 是一种基于并发、使用标记清除算法的垃圾回收器。CMS 会尽可能让 GC 线程与用户线程并发执行，可以消除长时间的 GC 停顿（STW）。</p>
</blockquote>
</li>
<li>
<p>你能写出多少种排序算法?二分写下吧</p>
<ul>
<li>冒泡</li>
</ul>
</li>
<li>
<p>TCP和UDP?</p>
<ul>
<li>
<p>UDP</p>
<ol>
<li>
<p>UDP首先他不是面向连接的, 因此他不需要像TCP一样需要通过三次握手建立连接, 想发数据就直接发了, 并不关心对方是否收到, 也不关心是否完整.UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>
</li>
<li>
<blockquote>
<p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p>
<p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p>
<p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>
</blockquote>
</li>
<li>
<p>UDP是面向报文的, 发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p>
</li>
<li>
<p><img src="https://image.fundebug.com/2019-03-21-03.png" alt=""></p>
<p>UDP 头部包含了以下几个数据：</p>
<ul>
<li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li>
<li>整个数据报文的长度</li>
<li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li>
</ul>
<p>因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的</p>
</li>
</ol>
</li>
<li>
<p>TCP</p>
<ul>
<li>
<p>面向连接</p>
<p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p>
</li>
<li>
<p>仅支持单播传输</p>
</li>
</ul>
<p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p>
<ul>
<li>面向字节流</li>
</ul>
<p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p>
<ul>
<li>
<p>可靠传输</p>
<p>对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p>
</li>
<li>
<p>提供拥塞控制</p>
</li>
</ul>
<p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</p>
<ul>
<li>TCP提供全双工通信</li>
</ul>
<p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p>
<table>
<thead>
<tr>
<th style="text-align: left"></th>
<th style="text-align: left">UDP</th>
<th style="text-align: left">TCP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">是否连接</td>
<td style="text-align: left">无连接</td>
<td style="text-align: left">面向连接</td>
</tr>
<tr>
<td style="text-align: left">是否可靠</td>
<td style="text-align: left">不可靠传输，不使用流量控制和拥塞控制</td>
<td style="text-align: left">可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr>
<td style="text-align: left">连接对象个数</td>
<td style="text-align: left">支持一对一，一对多，多对一和多对多交互通信</td>
<td style="text-align: left">只能是一对一通信</td>
</tr>
<tr>
<td style="text-align: left">传输方式</td>
<td style="text-align: left">面向报文</td>
<td style="text-align: left">面向字节流</td>
</tr>
<tr>
<td style="text-align: left">首部开销</td>
<td style="text-align: left">首部开销小，仅8字节</td>
<td style="text-align: left">首部最小20字节，最大60字节</td>
</tr>
<tr>
<td style="text-align: left">适用场景</td>
<td style="text-align: left">适用于实时应用（IP电话、视频会议、直播等）</td>
<td style="text-align: left">适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>再说一次三次握手吧</p>
<p><img src="https://image.fundebug.com/2019-03-21-04.png" alt=""></p>
<img src="https://pic-frank.oss-cn-beijing.aliyuncs.com/img/202208291649296.png" alt="image-20220829164940255" style="zoom:50%;" />
<p>3次握手</p>
<ol>
<li>client向server发送报文,tcp的报文头固定20字节中的, 标识位会设置为SYN, 发送完毕后client会进入 SYN-SENT状态, 等待一个ACK的报文, 这是第一次握手</li>
<li>server收到SYN后, 发送SYN+ACK给client, server进入SYN-RECEIVED状态, 这是第二次握手</li>
<li>client接收到server发送的SYN+ACK的时候,发送ACK确认收到, 进入ESTABLISHED状态, 这是第三次握手</li>
<li>server接收到ACK, 进入 ESTABLSHED状态. 三次握手结束</li>
</ol>
<p><strong>为什么一定是3次,不能2次吗</strong>,如果是2次,没有第三次client发给server的话,也许第二次握手完,server就进入established状态,但是此时客户端可能连接失效了,是为了防止失效的报文也被server接收导致错误.</p>
<img src="https://image.fundebug.com/2019-03-21-06.png" style="zoom:80%;" />
<p>4次挥手</p>
<ol>
<li>client向server发送报文,标识位为FIN, 表示要关闭连接, 这是第一次挥手</li>
<li>server收到FIN, 进入CLOSE_AWAIT状态, 不再接受client的数据, 但此时client依然可以继续发送, 并且发送ACK给Client.这是第二次挥手</li>
<li>如果server还有没发送完的数据,会继续发送,最后发送FIN给client, 进入 last_ack状态这是第三次挥手</li>
<li>client收到FIN后, 会进入time-wait状态, 等待2MSL, 如果这个时间内 server没有再发送请求, 就进入close状态,并且发送ACK到server, server接收到ack也进入close, 这是第四次挥手</li>
</ol>
</li>
<li>
<p>NIO是什么,JavaNIO又有什么区别,写点demo吧</p>
</li>
<li>
<p>map与flatMap的区别</p>
<p>map会作用于整个stream的序列上, flatMap会避免出现嵌套式的stream&lt;stream&gt;, 扁平化处理, 相当于不破坏最外层的结构, 给内部的每个元素再一次 stream的机会. 达到avoid nested stream structure</p>
</li>
<li>
<p>java1.8 11 区别，你平时了解java新版本的特性吗？协程知道么</p>
</li>
<li>
<p>mysql为什么一定要有聚簇索引呢</p>
</li>
<li>
<p>jvm如何判断一个对象死了?可以回收</p>
<ol>
<li>引用计数法,顾名思义一个对象被引用过一次，就计数+1，如果是0了，则可以回收，但是这种方法不能够解决相互引用带来的问题。</li>
<li>可达性分析，将JVM中某些对象作为GC_ROOT,任何一个对象如果和GC_ROOT没有引用的链路，则判断是可以回收的，但是可以回收之前有两次标记，第一次是如果没有GC_ROOT引用链路标记一次，第二次是检查该对象的finalize方法是否被调用过，如果没有调用过，则把对象放在F-QUEUE里，执行finalize方法，所以finalize是一个对象最后可以自救的方法。</li>
</ol>
</li>
<li>
<p>jvm为什么要采用分代的策略呢</p>
<p>使用分代的策略，则可以将所有的对象分为两种类型，一种是朝生夕死的，我们将这种类型的对象放在一起，进行回收的时候，只需要关注如何保留少量的需要存活的对象，而不是花费力气去标记那些大量的需要回收的对象，就能以比较低的代价回收大量的内存空间。而另一种就是难以消亡的对象，把他们集中在一起，虚拟机就可以使用较低的频率回收这个区域，这样就同时兼顾了垃圾回收的时间开销和内存空间的有效利用。分代了之后，垃圾回收器才可以每次只回收其中一个或某些部分的区域，才有‘MinorGC’ ，‘MajorGC’，’FullGC‘这样的回收类型</p>
</li>
<li>
<p>jvm有哪些垃圾回收算法</p>
<ol>
<li>
<p>标记-清除</p>
<p>标记清楚是第一代出现的算法，后续出现的算法大都基于它。对于内存空间，直接标记哪些对象需要回收，然后直接回收，这样会带来2个问题，首先是标记和回收的效率会随着对象的数量不断降低。其次是，回收过某个对象后，也有可能有些对象没有回收，导致出现大量的内存碎片。从而导致，没有足够大的内存空间而触发第二次的内存回收。</p>
</li>
<li>
<p>标记-复制</p>
<p>标记-清除的问题主要是随着对象数量变大而降低效率，以及产生大量内存碎片的问题。标记-复制的逻辑，首先是将内存空间分为2份，当需要内存分配的时候，只使用一半的内存空间，当触发gc的时候，直接将一半的空间里所有的对象，复制到另一半中，在复制的时候，直接通过指针移动，将对象连接到一块，不会产生碎片。然后直接清除掉当前的整个一半内存空间。不需要标记和清除这部分带来的时间消耗了。</p>
<p>当然随着JVM发展，发现并不需要1:1的比例，这样浪费了太大的内存空间，有研究发现，90%以上的对象都会被清除，所以后续的HotSpot虚拟机，将新生代分为eden，survivor区。比例为8：1：1，survivor的10%作为复制的地方。当gc的时候，会讲eden和survivor的10%内存活的对象都复制到另10%的survivor中。但是不能每次都保证不会有超过10%的对象存活下来，此时需要一块地方去处理这些对象，即老年代。</p>
<p>带来的问题很明显，极端情况下，整个内存空间的对象都是需要存活的，那么复制的这个动作效率将会极大下降。</p>
</li>
<li>
<p>标记-整理</p>
<p>标记-复制带来的极端情况下，复制效率低的问题，通过标记-整理来解决。</p>
<p>标记-整理与标记-清除类似，前期是一样的标记，但是后续清除时，并非直接清除从而导致内存碎片产生。而是多了一步移动的操作，移动这个操作是优缺点并存的。如果移动对象，尤其是在老年代这种有大量对象存活的地区，移动对象并且更新所有引用对象的地方，会是很负重的操作。此时必须全部暂停用户应用程序才能进行。这种停顿被称为“stop the world”</p>
<p>但是如果不考虑移动的话，就会像标记-清除一样造成大量的内存碎片。则需要更为复杂的内存分配器等方式来解决这个问题，但是内存是用户程序访问最为频繁的地方，如果这里复杂了，那么带来的则是应用程序的吞吐受到影响。</p>
<p>基于上面两点，无论是否移动都有利有弊，所以不同的垃圾回收器采用了不同的算法，HotSpot里关注吞吐量的Parallel Scavenge收集器采用的就是标记-整理法，而关于延迟的CMS则采用的是标记-清除法，当然，CMS采用了折中的方式解决掉碎片，就是先采用标记-清除法，当内存空间达到一定程度的时候，再采用一次标记-整理法。</p>
</li>
</ol>
</li>
<li>
<p>JVM中哪些对象可以作为GCROOT</p>
<p>常量，静态变量，栈帧中的本地变量表中的引用对象，各个线程调用方法堆栈中的参数，局部变量，临时变量等。还有被同步锁Synchronized持有的对象。等</p>
<p>在进行GCROOT枚举的时候，依然会产生STW的，因为不同的线程看到的GCROOT一定得是一样的，这就意味着枚举的时候需要产生一个快照，在这个过程，其他线程是无法对这些对象进行操作的，即产生了GCROOT，如果不进行STW，那么线程A可能用到的引用，在B线程就得不到了。会产生引用之间的问题。</p>
</li>
<li>
<p>分散性大的，还是小的的数据适合建立索引？</p>
<p>分散性大的适合建立索引，如果是sex这种只会有2种结果的字段，索引效果很低。只会多一次回表的动作，反而慢了，具体还是要看业务</p>
</li>
<li>
<p>你们公司平时的机器内存是多大的，怎么分配堆内存的，给你32g的机器，你怎么分。</p>
<blockquote>
<p>tips：从应用类型考虑，有些应用直接使用的对外内存。考察Jvm常用的几个对内存参数，以及对堆内存模型的划分。答案没有百分百正确，需要压测。</p>
</blockquote>
</li>
<li>
<p>having和where区别</p>
<p>having是对结果集，where是对所有数据筛选。</p>
<p>例如查找1号发售的并且平均收入大于50的商品</p>
</li>
<li>
<p>为什么simpleDateformat不安全，如何解决呢</p>
</li>
<li>
<p>distinct和groupby区别</p>
<p>groupby聚合，可以让你有机会使用聚合函数，例如sum，avg。而distinct只是单纯的删除duplicate的数据</p>
</li>
<li>
<p>qps和tps什么区别，你平时写的服务能有多大的数据，怎么计算的？并发数是怎么得来的？吞吐？pv，uv</p>
<ul>
<li>pv：pageview，每一次访问页面或接口都会计数+1</li>
<li>uv：userview，用户访问计数，通常是同一个session，或者同一个ip访问接口计数+1</li>
<li>qps：query per second，每秒查询次数，指服务器每秒可以执行的查询次数。他是一个服务器在指定时间内能处理多少流量的指标</li>
<li>tps：tps is the abbreviation of transcation per second，每秒事务的个数，从客户端发送send request到客户端接response的时间算作一个事务。</li>
<li>jmter进行的压测</li>
<li>httprunner进行的自动化测试</li>
<li>写 各个语言的 unit test</li>
</ul>
</li>
<li>
<p>MongoDB用过吗？为什么用它？</p>
</li>
<li>
<p>k8s的各个组件给我讲下呢</p>
</li>
<li>
<p>什么是rpc，你用过rpc框架吗</p>
</li>
<li>
<p>es为什么搜索这么快？</p>
</li>
<li>
<p>nacos的client和server是如何交互的？我在server上发布了一个新的配置，给到客户端的时候，会被一些安全框架拦截吗？例如spring-security</p>
</li>
<li>
<p>说一下网络模型</p>
<ul>
<li>
<p>OSI的标准模型，分为7层</p>
<img src="https://pic-frank.oss-cn-beijing.aliyuncs.com/img/202209221625606.png" alt="image-20220922162547534" style="zoom: 33%;" />
<ul>
<li>
<p>应用层</p>
<p>应用层是OSI模型的最后一层，非常靠近软件，他充当终端用于与应用之间的窗户，帮助从网络上获取数据展示信息给用户。</p>
<p>常用的应用层协议HTTP，FTP，DNS，SNMP</p>
</li>
<li>
<p>表示层</p>
<p>表示层，提供两个网络系统之间数据交换的语法与语义，格式。相当于是翻译的一层。他还确保了数据的隐私，通过提供加密和解密。他还有有助于减少需要展示的数据的体积，这个过程叫压缩。</p>
<p>为了确保数据的隐私，常用的表示层协议是TSL，和SSL</p>
</li>
<li>
<p>会话层</p>
<p>会话层用于建立一个链接，维护和同步设备之间的通话，他还提供了身份验证。</p>
<p>当通过分段的方式发送数据的时候，会话层会添加一些同步点，当传输过程中数据发生异常，则会从最后一个同步点重新发送。这个过程被称为同步和恢复。</p>
<p>会话层还扮演者对话控制的角色，他允许全双工和半双工的方式在两个系统之间通信。为了允许应用程序与不同的计算机进行通信，会话层使用 NetBIOS 或 PPTP 等网络协议。</p>
</li>
<li>
<p>传输层</p>
<p>出书层在网络层和应用层之间，它确保数据端到端传输和数据完整。当数据传输结束的时候，他会发送一个确认给发送端。如果中间发生了错误的话，传输层会重新传输。传输层受到网络层传来的数据包会讲数据分为更小的包，这个包叫segment，过程叫分块，segmentation，他还控制数据的流转和错误，帮助数据正确的抵达接受者。传输层接以分段的方式接收数据，他重新组装segment，并且确认数据是否正确接受了。</p>
<p>通常使用TCP，UDP协议来实现传输层</p>
</li>
<li>
<p>网络层</p>
<p>网络层传输数据从一个传输点到另一个，有助于选择从一个host到另一个host的最短路径以便方便交付数据，这个过程称为路由。他将发送地址和接受地址的ip放在的帧的header种。网络层提供了一个在不同的设备之间提供了逻辑地址。在地址这方便起到占很重要的角色。网络层通常使用各种各样的协议，例如IPV4/IPV6，ARP，ICMP来实现它的功能</p>
</li>
<li>
<p>数据链路层</p>
<p>数据链路层负责两个直接连接的节点之间数据的传输。当物理层收到数据，会转为二进制bit，发送给数据链路层。数据链路层确保从物理层接受的数据或者包没有错误后从一个节点传输数据到另一个节点，数据链路层通过<strong>MAC地址</strong>将包发送到另一个node。</p>
<p>数据链路层进一步可以划分为LLC，逻辑链路控制层和MAC，Media Access Controller。LLC层负责检查接受到的数据包里是否有错，并且同步帧。</p>
<p>mac控制网络设备对传输介质的访问，他还允许将数据从一个node传输到另一个node。</p>
<p>一旦数据从物理层到达数据链路层，他会将原始数据转为数据包，这个包称为帧。帧会有header和trailer，header和trailer里包含了硬件的目的和原地址的信息，通过这样的方式，帮助数据包发送到目的地。假设数据从一个高的传输能力服务器到一个低传输能力服务器，数据链路层需要确保传输的rate满足两边的机器，并且没有任何数据损坏。</p>
<p>在数据链路层中最流行的网络技术是以太网<strong>Ethernet</strong></p>
</li>
<li>
<p>物理层</p>
<p>作为最底层是非常重要的，控制者传输速率，当其他的设备发送数据到物理层的时候，物理层会讲数据转为bit，二进制数据，发送给数据链路层。</p>
<p>定义了数据在两个设备之间的传输模式，物理层还定义了物理拓扑，一个物理拓扑通常是由实际的计算机电缆或者其他物理设备，在物理层传输的网络协议有<a href="https://en.wikipedia.org/wiki/RS-232">RS-232</a>, <a href="https://en.wikipedia.org/wiki/Twisted_pair">UTP cables</a>, <a href="https://techterms.com/definition/dsl">DSL</a>.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>那么OSI和TCP/IP的关系？，TCP/IP和HTTP关系？</p>
<p>OSI是一个模型，理论上。可以理解是接口。而TCP/IP是实现。TCP/IP讲OSI最上面的应用层，表示层，会话层认为是一个应用层，最后的数据链路和物理层合起来叫网络接口层。从而变成4层</p>
<p>IP是网络层协议，TCP是传输层协议，HTTP是包含了TCP的应用层协议，而应用层协议则是由软件自行实现的，而TCP是网卡认的协议。</p>
<p><strong>HTTP是在TCP的上层，TCP告诉你传了一堆数据，HTTP则告诉你这堆数据是啥。所以你抓浏览器的包，发现是TCP协议完全没有任何冲突的地方。</strong></p>
<p>HTTP 协议是一种无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系的。对于 HTTP 服务器，是不能识别两次请求是来自同一个客户端的。为了解决这一问题，Web 程序引入了 Cookie 来维护连接的可持续。</p>
</li>
<li>
<p>正则写的怎么样</p>
</li>
<li>
<p>es，mongodb，mysql</p>
<p>当我们存放的数据存在树状的关系时，mysql就不太适合，例如商品的评论信息，评论有自己的内容，还有给评论点赞的一些信息。1-&gt;n-&gt;m。这种如果直接用文档存的话，就只需要一个大的json即可。此时适合用mongodb。而用mysql的话，需要给每一层都建一个表。</p>
<p>当业务模型存在n-m，如果还用mongodb，就需要给每个实体创建一个集合。查询关联信息的时候就会很麻烦。而使用mysql的话，只需要维护关系表即可。</p>
<p>es，专门为搜索而生的，他有缺点，就是他是一个准实时的nosql数据库。意味着，如果需要强一致性的数据，那就不可以用es了。and vice versa。</p>
<p>因此，一个特别庞大的系统的话，需要搜索，数据量很大，实体之间关系又很复杂。可以同时使用这三种数据库，command操作的时候，根据实体关系，直接操作mysql或者mongodb，然后通过其他中间件，例如canal来同步mysql到es的数据</p>
</li>
<li>
<p>写过go，说下go和java的区别，比如垃圾回收？协程等</p>
</li>
</ul>
<h1 id="jvm">JVM</h1>
<ul>
<li>
<p>说一下java虚拟机运行时数据区域，或者说JVM运行时的数据都存放在哪里的。</p>
<ul>
<li>
<p>本地方法栈</p>
<p>和虚拟机栈是非常相似的，只不过虚拟机栈是服务于本地方法即native修饰过的方法。一样也是线程私有的。</p>
</li>
<li>
<p>虚拟机栈</p>
<p>与程序计数器一样，也是线程私有的，他的生命周期与线程相同，虚拟机栈描述的是Java方法执行的线程内存模型。每个方法执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表（java的基本数据类型，byte，init，short，long，double，char，float，boolen，以及reference对象引用类型），操作数栈，动态链接，方法出口等信息。每个方法被调用直至执行完毕的过程。就对应着一个栈帧在虚拟机栈中的入栈和出栈过程。那么当线程请求的栈深度大于虚拟机所允许的深度，将会抛出StackoverflowError。当然也会出现OOM，只要虚拟机容量支持动态扩展。</p>
</li>
<li>
<p>堆</p>
<p>堆是整个虚拟机中占地最大的一块区域。堆是<strong>线程共享</strong>一块地方。目前Java所有的对象实例都是在在堆上分配的。目前的垃圾回收器大部分都是基于分代理论设计的。所以堆中会被区分为“新生代”，“老年代”，“永久代”。这里的分代技术，只是一部分垃圾回收器的共同风格，并不是说JVM规范Java堆存在分代。目前有些新的垃圾回收期已经采用了不分代的设计。目前主流的JVM都可以通过-Xmx和-Xms来限制Java堆的大小。当然如果java堆中内存不够再分配实例的时候，则会抛出OOM异常。</p>
</li>
<li>
<p>程序计数器</p>
<p>记录当前线程的行指示器（执行到哪一行了）。字节码解释器工作时就是通过改变这个计数器的值来选取下一条要执行的字节码指令，它是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要这个计数器来完成。为了线程切换后能恢复到正确的执行位置，每条线程都有自己独立的程序计数器，所以程序计数器是线程私有的。不会出现OOM</p>
</li>
<li>
<p>方法区</p>
<p>和java堆一样，是<strong>线程共享</strong>的地方，用于存储已经被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据。在JDK8之前，方法区被称为是“永久代”，这个时候，方法区被归纳为到堆中。因此在这之前很容易出现内存溢出的错误。（因为永久代有默认的上限设置），到JDK8的时候，放弃了“永久代”的概念，改为“元空间”的概念，而“元空间”从而原来的JVM内存一部分，改成使用本地内存“native memory“来存放。</p>
<ul>
<li>运行时常量池，是方法区的一部分，Class文件除了类的信息描述，类的模版信息、字段，方法，接口等信息，还有一个常量池表，用于存放编辑期生成的各种字面量与符号引用。这部分内容，将在类加载后存放到方法区的运行时常量池。运行时也可以将变量放入常量池中，常见有String 的intern()方法，这就意味着会受到内存的限制，所以也会出现OOM的异常。</li>
</ul>
</li>
<li>
<p>直接内存，并非是JVM规范中提及到的内存区域，但是会经常使用，例如JDK1.4之后提出的NIO类，引入了一种基于内存通道Channel和缓冲区buffer的IO方式，它可以直接使用native方法分配堆外内存，通过一个存放在堆中的DirectBypeBuffer的对象进行使用，这样能在一些场景中提高性能，因为<strong>避免了</strong>在Java堆和Native堆中来回复制数据</p>
</li>
</ul>
</li>
<li>
<p>Java中一个对象是如何创建的</p>
<ul>
<li>
<p>当JVM遇到一个字节码new指令时，首先去检查这个指令的参数是否能从”常量池“中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析、初始化过，如果没有则执行类的加载过程。</p>
</li>
<li>
<p>在类的加载检查通过之后，将为新生对象分配内存，而对象所需内存的大小，在类加载完成之后便已经确定了，而为其分配内存实际上是从Java堆中划分出来的。假设Java堆内存是绝对规整的，一边放着使用过的内存，另一边放着空闲的内存，中间放一个指针用于标记空间分界点。那么分配一次内存，只是简单的移动指针到空闲区域需要大小的距离就可以了，这种方式叫做”指针碰撞“。但如果Java堆内存不是规整的话，虚拟机就要维护这个列表，标记着那些内存块是可以使用的，哪些是不可以使用的。分配的时候，需要从列表中找到足够大的空间划分给实例对象，并且更新列表的记录，这种方式叫做”空闲列表“。选择那种分配方式由java堆是否规整来决定。因此当使用Serial，ParNew等带压缩整理的垃圾回收器时，对象分配的方式就是”指针碰撞“。而使用CMS这种基于标记清除算法的的收集器时，理论上就只能使用”空闲列表“的方式来分配。</p>
<p>分配内存的过程也不是线程安全的，当线程A正在分配内存，指针还没来得及修改，B线程同时又修改了原指针。有2个方案，一种是对分配内存的动作进行同步，虚拟机采用的CAS配合失败重试的方式来保证更新操作的原子性，另一种方式是把内存分配到不同的空间，<strong>即在每个线程在Java堆中预先分配一小块内存，称为本地内存分配缓冲（Thread Local Allocation Buffer）</strong>。</p>
</li>
<li>
<p>分配内存完成后，JVM还要对这个对象进行必要的设置，例如这个对象是哪个类的实例、如何找到类的元数据信息，对象的hashcode（实际上hashcode是调用Object::hashCode才会计算），对象的GC分代年龄信息等。这些信息会被放在对象的object header中。</p>
</li>
<li>
<p>从虚拟机视角，这个对象已经诞生了，从java程序来看这个对象才刚开始，构造函数，即Class文件中的init方法还没有执行，所有的字段都是零值，对象所需要的其他资源和状态信息还没有按照预定的意图构造好。</p>
</li>
</ul>
</li>
<li>
<p>对象的布局</p>
<p>一个对象，分为3个部分，对象头（Header），实例数据（Instance Data）和对齐填充（Padding）。对象头，自身的数据，例如hashCode，GC年龄，锁的状态，偏向线程ID，线程持有的锁。另一部分信息是类型指针，即对象指向它元数据的指针，<strong>Java通过这个指针来确定这个对象是哪个类的实例</strong></p>
</li>
</ul>

  </div>
</article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:sunhao1256@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://twitter.com/Frank12990735" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://github.com/sunhao1256" class="iconfont icon-github" title="github"></a>
  <a href="http://luluhome.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2019 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>sh</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>








</body>
</html>
