<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>ConcurrentHashMap - Lulu</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ConcurrentHashMap" />
<meta property="og:description" content="摘自：https://www.cnblogs.com/tong-yuan/p/ConcurrentHashMap-resize.html
 简介 ConcurrentHashMap是HashMap的线程安全版本，内部也是使用（数组 &#43; 链表 &#43; 红黑树）的结构来存储元素。
相比于同样线程安全的HashTable来说，效率等各方面都有极大地提高。
构造函数 public ConcurrentHashMap() { } public ConcurrentHashMap(int initialCapacity) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(); int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity &#43; (initialCapacity &gt;&gt;&gt; 1) &#43; 1)); this.sizeCtl = cap; } public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) { this.sizeCtl = DEFAULT_CAPACITY; putAll(m); } public ConcurrentHashMap(int initialCapacity, float loadFactor) { this(initialCapacity, loadFactor, 1); } public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) { if (!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sunhao1256.github.io/post/concurrenthashmap/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-10-12T21:55:51+08:00" />
<meta property="article:modified_time" content="2021-10-12T21:55:51+08:00" />


		<meta itemprop="name" content="ConcurrentHashMap">
<meta itemprop="description" content="摘自：https://www.cnblogs.com/tong-yuan/p/ConcurrentHashMap-resize.html
 简介 ConcurrentHashMap是HashMap的线程安全版本，内部也是使用（数组 &#43; 链表 &#43; 红黑树）的结构来存储元素。
相比于同样线程安全的HashTable来说，效率等各方面都有极大地提高。
构造函数 public ConcurrentHashMap() { } public ConcurrentHashMap(int initialCapacity) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(); int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity &#43; (initialCapacity &gt;&gt;&gt; 1) &#43; 1)); this.sizeCtl = cap; } public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) { this.sizeCtl = DEFAULT_CAPACITY; putAll(m); } public ConcurrentHashMap(int initialCapacity, float loadFactor) { this(initialCapacity, loadFactor, 1); } public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) { if (!"><meta itemprop="datePublished" content="2021-10-12T21:55:51+08:00" />
<meta itemprop="dateModified" content="2021-10-12T21:55:51+08:00" />
<meta itemprop="wordCount" content="2231">
<meta itemprop="keywords" content="java基础," />
		<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ConcurrentHashMap"/>
<meta name="twitter:description" content="摘自：https://www.cnblogs.com/tong-yuan/p/ConcurrentHashMap-resize.html
 简介 ConcurrentHashMap是HashMap的线程安全版本，内部也是使用（数组 &#43; 链表 &#43; 红黑树）的结构来存储元素。
相比于同样线程安全的HashTable来说，效率等各方面都有极大地提高。
构造函数 public ConcurrentHashMap() { } public ConcurrentHashMap(int initialCapacity) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(); int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity &#43; (initialCapacity &gt;&gt;&gt; 1) &#43; 1)); this.sizeCtl = cap; } public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) { this.sizeCtl = DEFAULT_CAPACITY; putAll(m); } public ConcurrentHashMap(int initialCapacity, float loadFactor) { this(initialCapacity, loadFactor, 1); } public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) { if (!"/>

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/custom.css">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="/" title="Lulu" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="/img/placeholder.png">
				</div><div class="logo__item logo__text">
					<div class="logo__title">Lulu</div>
					<div class="logo__tagline">Lulu is arrongant cat</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">About</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ConcurrentHashMap</h1>
			<div class="post__meta meta"><div class="meta__item-author meta__item">
	<svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2 0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class="meta__text">Frank Silva</span>
</div>
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2021-10-12T21:55:51&#43;08:00">2021-10-12</time></div></div>
		</header>
		
<div class="post__toc toc">
	<div class="toc__title">Page content</div>
	<div class="toc__menu">
		<nav id="TableOfContents">
  <ul>
    <li><a href="#提问">提问</a></li>
  </ul>

  <ul>
    <li><a href="#提问-1">提问</a></li>
  </ul>
</nav>
	</div>
</div><div class="content post__content clearfix">
			<blockquote>
<p>摘自：https://www.cnblogs.com/tong-yuan/p/ConcurrentHashMap-resize.html</p>
</blockquote>
<h1 id="简介">简介</h1>
<p>ConcurrentHashMap是HashMap的线程安全版本，内部也是使用（数组 + 链表 + 红黑树）的结构来存储元素。</p>
<p>相比于同样线程安全的HashTable来说，效率等各方面都有极大地提高。</p>
<h1 id="构造函数">构造函数</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ConcurrentHashMap</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ConcurrentHashMap</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> initialCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>initialCapacity <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">int</span> cap <span style="color:#f92672">=</span> <span style="color:#f92672">((</span>initialCapacity <span style="color:#f92672">&gt;=</span> <span style="color:#f92672">(</span>MAXIMUM_CAPACITY <span style="color:#f92672">&gt;&gt;&gt;</span> 1<span style="color:#f92672">))</span> <span style="color:#f92672">?</span>
            MAXIMUM_CAPACITY <span style="color:#f92672">:</span>
            tableSizeFor<span style="color:#f92672">(</span>initialCapacity <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>initialCapacity <span style="color:#f92672">&gt;&gt;&gt;</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">));</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">sizeCtl</span> <span style="color:#f92672">=</span> cap<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ConcurrentHashMap</span><span style="color:#f92672">(</span>Map<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">extends</span> K<span style="color:#f92672">,</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">extends</span> V<span style="color:#f92672">&gt;</span> m<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">sizeCtl</span> <span style="color:#f92672">=</span> DEFAULT_CAPACITY<span style="color:#f92672">;</span>
    putAll<span style="color:#f92672">(</span>m<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ConcurrentHashMap</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> initialCapacity<span style="color:#f92672">,</span> <span style="color:#66d9ef">float</span> loadFactor<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">(</span>initialCapacity<span style="color:#f92672">,</span> loadFactor<span style="color:#f92672">,</span> 1<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ConcurrentHashMap</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> initialCapacity<span style="color:#f92672">,</span>
                         <span style="color:#66d9ef">float</span> loadFactor<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> concurrencyLevel<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!(</span>loadFactor <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">0f</span><span style="color:#f92672">)</span> <span style="color:#f92672">||</span> initialCapacity <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span> concurrencyLevel <span style="color:#f92672">&lt;=</span> 0<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>initialCapacity <span style="color:#f92672">&lt;</span> concurrencyLevel<span style="color:#f92672">)</span>   <span style="color:#75715e">// Use at least as many bins
</span><span style="color:#75715e"></span>        initialCapacity <span style="color:#f92672">=</span> concurrencyLevel<span style="color:#f92672">;</span>   <span style="color:#75715e">// as estimated threads
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">long</span> size <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">long</span><span style="color:#f92672">)(</span>1<span style="color:#f92672">.</span><span style="color:#a6e22e">0</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">long</span><span style="color:#f92672">)</span>initialCapacity <span style="color:#f92672">/</span> loadFactor<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">int</span> cap <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>size <span style="color:#f92672">&gt;=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">long</span><span style="color:#f92672">)</span>MAXIMUM_CAPACITY<span style="color:#f92672">)</span> <span style="color:#f92672">?</span>
            MAXIMUM_CAPACITY <span style="color:#f92672">:</span> tableSizeFor<span style="color:#f92672">((</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)</span>size<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">sizeCtl</span> <span style="color:#f92672">=</span> cap<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

</code></pre></div><p>ConcurrentHashMap没有了原来hashmap里面的thresold和loadFactor，扩容门槛和负载因子，使用的是sizeCtl来控制容量</p>
<p>（1）-1，表示有线程正在进行初始化操作</p>
<p>（2）-(1 + nThreads)，表示有n个线程正在一起扩容</p>
<p>（3）0，默认值，后续在真正初始化的时候使用默认容量</p>
<p>（4）&gt; 0，初始化或扩容完成后下一次的扩容门槛</p>
<h1 id="添加元素">添加元素</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> putVal<span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">final</span> V <span style="color:#a6e22e">putVal</span><span style="color:#f92672">(</span>K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> onlyIfAbsent<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// key和value都不能为null
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> value <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException<span style="color:#f92672">();</span>
    <span style="color:#75715e">// 计算hash值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> hash <span style="color:#f92672">=</span> spread<span style="color:#f92672">(</span>key<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">());</span>
    <span style="color:#75715e">// 要插入的元素所在桶的元素个数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> binCount <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 死循环，结合CAS使用（如果CAS失败，则会重新取整个桶进行下面的流程）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab <span style="color:#f92672">=</span> table<span style="color:#f92672">;;)</span> <span style="color:#f92672">{</span>
        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> f<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> fh<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tab <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span>
            <span style="color:#75715e">// 如果桶未初始化或者桶个数为0，则初始化桶
</span><span style="color:#75715e"></span>            tab <span style="color:#f92672">=</span> initTable<span style="color:#f92672">();</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>f <span style="color:#f92672">=</span> tabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> hash<span style="color:#f92672">))</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 如果要插入的元素所在的桶还没有元素，则把这个元素插入到这个桶中
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>casTabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span>
                    <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)))</span>
                <span style="color:#75715e">// 如果使用CAS插入元素时，发现已经有元素了，则进入下一次循环，重新操作
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// 如果使用CAS插入元素成功，则break跳出循环，流程结束
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>                   <span style="color:#75715e">// no lock when adding to empty bin
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>fh <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> MOVED<span style="color:#f92672">)</span>
            <span style="color:#75715e">// 如果要插入的元素所在的桶的第一个元素的hash是MOVED，则当前线程帮忙一起迁移元素
</span><span style="color:#75715e"></span>            tab <span style="color:#f92672">=</span> helpTransfer<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> f<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 如果这个桶不为空且不在迁移元素，则锁住这个桶（分段锁）
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 并查找要插入的元素是否在这个桶中
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 存在，则替换值（onlyIfAbsent=false）
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 不存在，则插入到链表结尾或插入树中
</span><span style="color:#75715e"></span>            V oldVal <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>f<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 再次检测第一个元素是否有变化，如果有变化则进入下一次循环，从头来过
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> f<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    <span style="color:#75715e">// 如果第一个元素的hash值大于等于0（说明不是在迁移，也不是树）
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// 那就是桶中的元素使用的是链表方式存储
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>fh <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        <span style="color:#75715e">// 桶中元素个数赋值为1
</span><span style="color:#75715e"></span>                        binCount <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
                        <span style="color:#75715e">// 遍历整个桶，每次结束binCount加1
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e <span style="color:#f92672">=</span> f<span style="color:#f92672">;;</span> <span style="color:#f92672">++</span>binCount<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                            K ek<span style="color:#f92672">;</span>
                            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> hash <span style="color:#f92672">&amp;&amp;</span>
                                    <span style="color:#f92672">((</span>ek <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span>
                                            <span style="color:#f92672">(</span>ek <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>ek<span style="color:#f92672">))))</span> <span style="color:#f92672">{</span>
                                <span style="color:#75715e">// 如果找到了这个元素，则赋值了新值（onlyIfAbsent=false）
</span><span style="color:#75715e"></span>                                <span style="color:#75715e">// 并退出循环
</span><span style="color:#75715e"></span>                                oldVal <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>
                                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>onlyIfAbsent<span style="color:#f92672">)</span>
                                    e<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
                                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                            <span style="color:#f92672">}</span>
                            Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> pred <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
                            <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>e <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                                <span style="color:#75715e">// 如果到链表尾部还没有找到元素
</span><span style="color:#75715e"></span>                                <span style="color:#75715e">// 就把它插入到链表结尾并退出循环
</span><span style="color:#75715e"></span>                                pred<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span>
                                        value<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
                                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                            <span style="color:#f92672">}</span>
                        <span style="color:#f92672">}</span>
                    <span style="color:#f92672">}</span>
                    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>f <span style="color:#66d9ef">instanceof</span> TreeBin<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        <span style="color:#75715e">// 如果第一个元素是树节点
</span><span style="color:#75715e"></span>                        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> p<span style="color:#f92672">;</span>
                        <span style="color:#75715e">// 桶中元素个数赋值为2
</span><span style="color:#75715e"></span>                        binCount <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span>
                        <span style="color:#75715e">// 调用红黑树的插入方法插入元素
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// 如果成功插入则返回null
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// 否则返回寻找到的节点
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">((</span>TreeBin<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span>f<span style="color:#f92672">).</span><span style="color:#a6e22e">putTreeVal</span><span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span>
                                value<span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                            <span style="color:#75715e">// 如果找到了这个元素，则赋值了新值（onlyIfAbsent=false）
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">// 并退出循环
</span><span style="color:#75715e"></span>                            oldVal <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>
                            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>onlyIfAbsent<span style="color:#f92672">)</span>
                                p<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
                        <span style="color:#f92672">}</span>
                    <span style="color:#f92672">}</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
            <span style="color:#75715e">// 如果binCount不为0，说明成功插入了元素或者寻找到了元素
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>binCount <span style="color:#f92672">!=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 如果链表元素个数达到了8，则尝试树化
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// 因为上面把元素插入到树中时，binCount只赋值了2，并没有计算整个树中元素的个数
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// 所以不会重复树化
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>binCount <span style="color:#f92672">&gt;=</span> TREEIFY_THRESHOLD<span style="color:#f92672">)</span>
                    treeifyBin<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">);</span>
                <span style="color:#75715e">// 如果要插入的元素已经存在，则返回旧值
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>oldVal <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                    <span style="color:#66d9ef">return</span> oldVal<span style="color:#f92672">;</span>
                <span style="color:#75715e">// 退出外层大循环，流程结束
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 成功插入元素，元素个数加1（是否要扩容在这个里面）
</span><span style="color:#75715e"></span>        addCount<span style="color:#f92672">(</span>1L<span style="color:#f92672">,</span> binCount<span style="color:#f92672">);</span>
        <span style="color:#75715e">// 成功插入元素返回null
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

</code></pre></div><h2 id="提问">提问</h2>
<p>为什么Put方法是CAS+Synchronized而不是CAS+CAS，或者Synchronized+Synchronized？</p>
<ul>
<li>
<p>CAS是通过自旋来实现的无锁，如果在竞争很激烈的情况下，想象一下是不是很多线程都会阻塞在这个循环里。这个时候直接使用互斥锁Synchronized带来的性能收益要远高于CAS，</p>
</li>
<li>
<p>而ConcurrentHashMap是在找桶的时候使用CAS，此时竞争不激烈，只是简单尝试一下CAS操作(CAS是利用CPU提供的原子指令操作实现的)。这个时候用Synchronized性能肯定不如CAS的。</p>
</li>
<li>
<p>而在后面已经找到桶的情况下，形成了链表或者红黑树场景下，首先此时再进到这段代码，已经意味着在竞争很激烈的场景下了，此时如果自旋CAS大部分都会失败，这个时候Synchronized的性能远高于CAS，并且此时CAS比较的是整个链表或者树了。</p>
</li>
<li>
<p>这里也就是用了“分段锁”，实际上只是针对每个桶，即链表或者是树进行加锁。</p>
</li>
</ul>
<h1 id="初始化">初始化</h1>
<p>第一次放元素的时候，会检查数组是否为空，然后进行初始化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> <span style="color:#a6e22e">initTable</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> sc<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>tab <span style="color:#f92672">=</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>sc <span style="color:#f92672">=</span> sizeCtl<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
            <span style="color:#75715e">// 如果sizeCtl&lt;0说明正在初始化或者扩容，让出CPU
</span><span style="color:#75715e"></span>            Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">yield</span><span style="color:#f92672">();</span> <span style="color:#75715e">// lost initialization race; just spin
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>U<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSwapInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> SIZECTL<span style="color:#f92672">,</span> sc<span style="color:#f92672">,</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 如果把sizeCtl原子更新为-1成功，则当前线程进入初始化
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 如果原子更新失败则说明有其它线程先一步进入初始化了，则进入下一次循环
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 如果下一次循环时还没初始化完毕，则sizeCtl&lt;0进入上面if的逻辑让出CPU
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 如果下一次循环更新完毕了，则table.length!=0，退出循环
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 再次检查table是否为空，防止ABA问题
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>tab <span style="color:#f92672">=</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    <span style="color:#75715e">// 如果sc为0则使用默认值16
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>sc <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> sc <span style="color:#f92672">:</span> DEFAULT_CAPACITY<span style="color:#f92672">;</span>
                    <span style="color:#75715e">// 新建数组
</span><span style="color:#75715e"></span>                    <span style="color:#a6e22e">@SuppressWarnings</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;unchecked&#34;</span><span style="color:#f92672">)</span>
                    Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> nt <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[])</span><span style="color:#66d9ef">new</span> Node<span style="color:#f92672">&lt;?,?&gt;[</span>n<span style="color:#f92672">];</span>
                    <span style="color:#75715e">// 赋值给table桶数组
</span><span style="color:#75715e"></span>                    table <span style="color:#f92672">=</span> tab <span style="color:#f92672">=</span> nt<span style="color:#f92672">;</span>
                    <span style="color:#75715e">// 设置sc为数组长度的0.75倍
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// n - (n &gt;&gt;&gt; 2) = n - n/4 = 0.75n
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// 可见这里装载因子和扩容门槛都是写死了的
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// 这也正是没有threshold和loadFactor属性的原因
</span><span style="color:#75715e"></span>                    sc <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&gt;&gt;&gt;</span> 2<span style="color:#f92672">);</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 把sc赋值给sizeCtl，这时存储的是扩容门槛
</span><span style="color:#75715e"></span>                sizeCtl <span style="color:#f92672">=</span> sc<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> tab<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

</code></pre></div><p>（1）使用CAS锁控制只有一个线程初始化桶数组；</p>
<p>（2）sizeCtl在初始化后存储的是扩容门槛；</p>
<p>（3）扩容门槛写死的是桶数组大小的0.75倍，桶数组大小即map的容量，也就是最多存储多少个元素。</p>
<h1 id="判断是否需要扩容">判断是否需要扩容</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addCount</span><span style="color:#f92672">(</span><span style="color:#66d9ef">long</span> x<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> check<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    CounterCell<span style="color:#f92672">[]</span> as<span style="color:#f92672">;</span> <span style="color:#66d9ef">long</span> b<span style="color:#f92672">,</span> s<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 这里使用的思想跟LongAdder类是一模一样的（后面会讲）
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 把数组的大小存储根据不同的线程存储到不同的段上（也是分段锁的思想）
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 并且有一个baseCount，优先更新baseCount，如果失败了再更新不同线程对应的段
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这样可以保证尽量小的减少冲突
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// 先尝试把数量加到baseCount上，如果失败再加到分段的CounterCell上
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>as <span style="color:#f92672">=</span> counterCells<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span>
            <span style="color:#f92672">!</span>U<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSwapLong</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> BASECOUNT<span style="color:#f92672">,</span> b <span style="color:#f92672">=</span> baseCount<span style="color:#f92672">,</span> s <span style="color:#f92672">=</span> b <span style="color:#f92672">+</span> x<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
        CounterCell a<span style="color:#f92672">;</span> <span style="color:#66d9ef">long</span> v<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> m<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">boolean</span> uncontended <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 如果as为空
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 或者长度为0
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 或者当前线程所在的段为null
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 或者在当前线程的段上加数量失败
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>as <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>m <span style="color:#f92672">=</span> as<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span>
                <span style="color:#f92672">(</span>a <span style="color:#f92672">=</span> as<span style="color:#f92672">[</span>ThreadLocalRandom<span style="color:#f92672">.</span><span style="color:#a6e22e">getProbe</span><span style="color:#f92672">()</span> <span style="color:#f92672">&amp;</span> m<span style="color:#f92672">])</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span>
                <span style="color:#f92672">!(</span>uncontended <span style="color:#f92672">=</span>
                        U<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSwapLong</span><span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> CELLVALUE<span style="color:#f92672">,</span> v <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">,</span> v <span style="color:#f92672">+</span> x<span style="color:#f92672">)))</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 强制增加数量（无论如何数量是一定要加上的，并不是简单地自旋）
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 不同线程对应不同的段都更新失败了
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 说明已经发生冲突了，那么就对counterCells进行扩容
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 以减少多个线程hash到同一个段的概率
</span><span style="color:#75715e"></span>            fullAddCount<span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> uncontended<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>check <span style="color:#f92672">&lt;=</span> 1<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 计算元素个数
</span><span style="color:#75715e"></span>        s <span style="color:#f92672">=</span> sumCount<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>check <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab<span style="color:#f92672">,</span> nt<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">,</span> sc<span style="color:#f92672">;</span>
        <span style="color:#75715e">// 如果元素个数达到了扩容门槛，则进行扩容
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 注意，正常情况下sizeCtl存储的是扩容门槛，即容量的0.75倍
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>s <span style="color:#f92672">&gt;=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">long</span><span style="color:#f92672">)(</span>sc <span style="color:#f92672">=</span> sizeCtl<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>tab <span style="color:#f92672">=</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span>
                <span style="color:#f92672">(</span>n <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> MAXIMUM_CAPACITY<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// rs是扩容时的一个邮戳标识
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> rs <span style="color:#f92672">=</span> resizeStamp<span style="color:#f92672">(</span>n<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>sc <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// sc&lt;0说明正在扩容中
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>sc <span style="color:#f92672">&gt;&gt;&gt;</span> RESIZE_STAMP_SHIFT<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> rs <span style="color:#f92672">||</span> sc <span style="color:#f92672">==</span> rs <span style="color:#f92672">+</span> 1 <span style="color:#f92672">||</span>
                        sc <span style="color:#f92672">==</span> rs <span style="color:#f92672">+</span> MAX_RESIZERS <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>nt <span style="color:#f92672">=</span> nextTable<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span>
                        transferIndex <span style="color:#f92672">&lt;=</span> 0<span style="color:#f92672">)</span>
                    <span style="color:#75715e">// 扩容已经完成了，退出循环
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// 正常应该只会触发nextTable==null这个条件，其它条件没看出来何时触发
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>

                <span style="color:#75715e">// 扩容未完成，则当前线程加入迁移元素中
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// 并把扩容线程数加1
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>U<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSwapInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> SIZECTL<span style="color:#f92672">,</span> sc<span style="color:#f92672">,</span> sc <span style="color:#f92672">+</span> 1<span style="color:#f92672">))</span>
                    transfer<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> nt<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>U<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSwapInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> SIZECTL<span style="color:#f92672">,</span> sc<span style="color:#f92672">,</span>
                    <span style="color:#f92672">(</span>rs <span style="color:#f92672">&lt;&lt;</span> RESIZE_STAMP_SHIFT<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 2<span style="color:#f92672">))</span>
                <span style="color:#75715e">// 这里是触发扩容的那个线程进入的地方
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// sizeCtl的高16位存储着rs这个扩容邮戳
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// sizeCtl的低16位存储着扩容线程数加1，即(1+nThreads)
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// 所以官方说的扩容时sizeCtl的值为 -(1+nThreads)是错误的
</span><span style="color:#75715e"></span>
                <span style="color:#75715e">// 进入迁移元素
</span><span style="color:#75715e"></span>                transfer<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
            <span style="color:#75715e">// 重新计算元素个数
</span><span style="color:#75715e"></span>            s <span style="color:#f92672">=</span> sumCount<span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

</code></pre></div><p>（1）元素个数的存储方式类似于LongAdder类，存储在不同的段上，减少不同线程同时更新size时的冲突；</p>
<p>（2）计算元素个数时把这些段的值及baseCount相加算出总的元素个数；</p>
<p>（3）正常情况下sizeCtl存储着扩容门槛，扩容门槛为容量的0.75倍；</p>
<p>（4）扩容时sizeCtl高位存储扩容邮戳(resizeStamp)，低位存储扩容线程数加1（1+nThreads）；</p>
<p>（5）其它线程添加元素后如果发现存在扩容，也会加入的扩容行列中来；</p>
<h1 id="迁移元素">迁移元素</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">transfer</span><span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab<span style="color:#f92672">,</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> nextTab<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">,</span> stride<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>stride <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>NCPU <span style="color:#f92672">&gt;</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&gt;&gt;&gt;</span> 3<span style="color:#f92672">)</span> <span style="color:#f92672">/</span> NCPU <span style="color:#f92672">:</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> MIN_TRANSFER_STRIDE<span style="color:#f92672">)</span>
        stride <span style="color:#f92672">=</span> MIN_TRANSFER_STRIDE<span style="color:#f92672">;</span> <span style="color:#75715e">// subdivide range
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nextTab <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>            <span style="color:#75715e">// initiating
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 如果nextTab为空，说明还没开始迁移
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 就新建一个新桶数组
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 新桶数组是原桶的两倍
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">@SuppressWarnings</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;unchecked&#34;</span><span style="color:#f92672">)</span>
            Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> nt <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[])</span><span style="color:#66d9ef">new</span> Node<span style="color:#f92672">&lt;?,?&gt;[</span>n <span style="color:#f92672">&lt;&lt;</span> 1<span style="color:#f92672">];</span>
            nextTab <span style="color:#f92672">=</span> nt<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>Throwable ex<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>      <span style="color:#75715e">// try to cope with OOME
</span><span style="color:#75715e"></span>            sizeCtl <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        nextTable <span style="color:#f92672">=</span> nextTab<span style="color:#f92672">;</span>
        transferIndex <span style="color:#f92672">=</span> n<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// 新桶数组大小
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> nextn <span style="color:#f92672">=</span> nextTab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">// 新建一个ForwardingNode类型的节点，并把新桶数组存储在里面
</span><span style="color:#75715e"></span>    ForwardingNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> fwd <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ForwardingNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>nextTab<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">boolean</span> advance <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">boolean</span> finishing <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span> <span style="color:#75715e">// to ensure sweep before committing nextTab
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">,</span> bound <span style="color:#f92672">=</span> 0<span style="color:#f92672">;;)</span> <span style="color:#f92672">{</span>
        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> f<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> fh<span style="color:#f92672">;</span>
        <span style="color:#75715e">// 整个while循环就是在算i的值，过程太复杂，不用太关心
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// i的值会从n-1依次递减，感兴趣的可以打下断点就知道了
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 其中n是旧桶数组的大小，也就是说i从15开始一直减到1这样去迁移元素
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>advance<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> nextIndex<span style="color:#f92672">,</span> nextBound<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(--</span>i <span style="color:#f92672">&gt;=</span> bound <span style="color:#f92672">||</span> finishing<span style="color:#f92672">)</span>
                advance <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>nextIndex <span style="color:#f92672">=</span> transferIndex<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                i <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>
                advance <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>U<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSwapInt</span>
                    <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> TRANSFERINDEX<span style="color:#f92672">,</span> nextIndex<span style="color:#f92672">,</span>
                            nextBound <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>nextIndex <span style="color:#f92672">&gt;</span> stride <span style="color:#f92672">?</span>
                                    nextIndex <span style="color:#f92672">-</span> stride <span style="color:#f92672">:</span> 0<span style="color:#f92672">)))</span> <span style="color:#f92672">{</span>
                bound <span style="color:#f92672">=</span> nextBound<span style="color:#f92672">;</span>
                i <span style="color:#f92672">=</span> nextIndex <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
                advance <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span> i <span style="color:#f92672">&gt;=</span> n <span style="color:#f92672">||</span> i <span style="color:#f92672">+</span> n <span style="color:#f92672">&gt;=</span> nextn<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 如果一次遍历完成了
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 也就是整个map所有桶中的元素都迁移完成了
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> sc<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>finishing<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 如果全部迁移完成了，则替换旧桶数组
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// 并设置下一次扩容门槛为新桶数组容量的0.75倍
</span><span style="color:#75715e"></span>                nextTable <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
                table <span style="color:#f92672">=</span> nextTab<span style="color:#f92672">;</span>
                sizeCtl <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&lt;&lt;</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">-</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&gt;&gt;&gt;</span> 1<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>U<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSwapInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> SIZECTL<span style="color:#f92672">,</span> sc <span style="color:#f92672">=</span> sizeCtl<span style="color:#f92672">,</span> sc <span style="color:#f92672">-</span> 1<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 当前线程扩容完成，把扩容线程数-1
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>sc <span style="color:#f92672">-</span> 2<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> resizeStamp<span style="color:#f92672">(</span>n<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;&lt;</span> RESIZE_STAMP_SHIFT<span style="color:#f92672">)</span>
                    <span style="color:#75715e">// 扩容完成两边肯定相等
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
                <span style="color:#75715e">// 把finishing设置为true
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// finishing为true才会走到上面的if条件
</span><span style="color:#75715e"></span>                finishing <span style="color:#f92672">=</span> advance <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                <span style="color:#75715e">// i重新赋值为n
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// 这样会再重新遍历一次桶数组，看看是不是都迁移完成了
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// 也就是第二次遍历都会走到下面的(fh = f.hash) == MOVED这个条件
</span><span style="color:#75715e"></span>                i <span style="color:#f92672">=</span> n<span style="color:#f92672">;</span> <span style="color:#75715e">// recheck before commit
</span><span style="color:#75715e"></span>            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>f <span style="color:#f92672">=</span> tabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">))</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
            <span style="color:#75715e">// 如果桶中无数据，直接放入ForwardingNode标记该桶已迁移
</span><span style="color:#75715e"></span>            advance <span style="color:#f92672">=</span> casTabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> fwd<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>fh <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> MOVED<span style="color:#f92672">)</span>
            <span style="color:#75715e">// 如果桶中第一个元素的hash值为MOVED
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 说明它是ForwardingNode节点
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 也就是该桶已迁移
</span><span style="color:#75715e"></span>            advance <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span> <span style="color:#75715e">// already processed
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 锁定该桶并迁移元素
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>f<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 再次判断当前桶第一个元素是否有修改
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// 也就是可能其它线程先一步迁移了元素
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> f<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    <span style="color:#75715e">// 把一个链表分化成两个链表
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// 规则是桶中各元素的hash与桶大小n进行与操作
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// 等于0的放到低位链表(low)中，不等于0的放到高位链表(high)中
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// 其中低位链表迁移到新桶中的位置相对旧桶不变
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// 高位链表迁移到新桶中位置正好是其在旧桶的位置加n
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// 这也正是为什么扩容时容量在变成两倍的原因
</span><span style="color:#75715e"></span>                    Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> ln<span style="color:#f92672">,</span> hn<span style="color:#f92672">;</span>
                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>fh <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        <span style="color:#75715e">// 第一个元素的hash值大于等于0
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// 说明该桶中元素是以链表形式存储的
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// 这里与HashMap迁移算法基本类似
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// 唯一不同的是多了一步寻找lastRun
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// 这里的lastRun是提取出链表后面不用处理再特殊处理的子链表
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// 比如所有元素的hash值与桶大小n与操作后的值分别为 0 0 4 4 0 0 0
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// 则最后后面三个0对应的元素肯定还是在同一个桶中
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// 这时lastRun对应的就是倒数第三个节点
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// 至于为啥要这样处理，我也没太搞明白
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">int</span> runBit <span style="color:#f92672">=</span> fh <span style="color:#f92672">&amp;</span> n<span style="color:#f92672">;</span>
                        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> lastRun <span style="color:#f92672">=</span> f<span style="color:#f92672">;</span>
                        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> p <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span> p <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> p <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                            <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">&amp;</span> n<span style="color:#f92672">;</span>
                            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>b <span style="color:#f92672">!=</span> runBit<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                                runBit <span style="color:#f92672">=</span> b<span style="color:#f92672">;</span>
                                lastRun <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
                            <span style="color:#f92672">}</span>
                        <span style="color:#f92672">}</span>
                        <span style="color:#75715e">// 看看最后这几个元素归属于低位链表还是高位链表
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>runBit <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                            ln <span style="color:#f92672">=</span> lastRun<span style="color:#f92672">;</span>
                            hn <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
                        <span style="color:#f92672">}</span>
                        <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                            hn <span style="color:#f92672">=</span> lastRun<span style="color:#f92672">;</span>
                            ln <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
                        <span style="color:#f92672">}</span>
                        <span style="color:#75715e">// 遍历链表，把hash&amp;n为0的放在低位链表中
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// 不为0的放在高位链表中
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> p <span style="color:#f92672">=</span> f<span style="color:#f92672">;</span> p <span style="color:#f92672">!=</span> lastRun<span style="color:#f92672">;</span> p <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                            <span style="color:#66d9ef">int</span> ph <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span><span style="color:#f92672">;</span> K pk <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">;</span> V pv <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>
                            <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>ph <span style="color:#f92672">&amp;</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span>
                                ln <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>ph<span style="color:#f92672">,</span> pk<span style="color:#f92672">,</span> pv<span style="color:#f92672">,</span> ln<span style="color:#f92672">);</span>
                            <span style="color:#66d9ef">else</span>
                                hn <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>ph<span style="color:#f92672">,</span> pk<span style="color:#f92672">,</span> pv<span style="color:#f92672">,</span> hn<span style="color:#f92672">);</span>
                        <span style="color:#f92672">}</span>
                        <span style="color:#75715e">// 低位链表的位置不变
</span><span style="color:#75715e"></span>                        setTabAt<span style="color:#f92672">(</span>nextTab<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> ln<span style="color:#f92672">);</span>
                        <span style="color:#75715e">// 高位链表的位置是原位置加n
</span><span style="color:#75715e"></span>                        setTabAt<span style="color:#f92672">(</span>nextTab<span style="color:#f92672">,</span> i <span style="color:#f92672">+</span> n<span style="color:#f92672">,</span> hn<span style="color:#f92672">);</span>
                        <span style="color:#75715e">// 标记当前桶已迁移
</span><span style="color:#75715e"></span>                        setTabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> fwd<span style="color:#f92672">);</span>
                        <span style="color:#75715e">// advance为true，返回上面进行--i操作
</span><span style="color:#75715e"></span>                        advance <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                    <span style="color:#f92672">}</span>
                    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>f <span style="color:#66d9ef">instanceof</span> TreeBin<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        <span style="color:#75715e">// 如果第一个元素是树节点
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// 也是一样，分化成两颗树
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// 也是根据hash&amp;n为0放在低位树中
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// 不为0放在高位树中
</span><span style="color:#75715e"></span>                        TreeBin<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> t <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>TreeBin<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span>f<span style="color:#f92672">;</span>
                        TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> lo <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> loTail <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
                        TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> hi <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> hiTail <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
                        <span style="color:#66d9ef">int</span> lc <span style="color:#f92672">=</span> 0<span style="color:#f92672">,</span> hc <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
                        <span style="color:#75715e">// 遍历整颗树，根据hash&amp;n是否为0分化成两颗树
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e <span style="color:#f92672">=</span> t<span style="color:#f92672">.</span><span style="color:#a6e22e">first</span><span style="color:#f92672">;</span> e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> e <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                            <span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span><span style="color:#f92672">;</span>
                            TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span>
                                    <span style="color:#f92672">(</span>h<span style="color:#f92672">,</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">,</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
                            <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>h <span style="color:#f92672">&amp;</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                                <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>p<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> loTail<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                                    lo <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
                                <span style="color:#66d9ef">else</span>
                                    loTail<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
                                loTail <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
                                <span style="color:#f92672">++</span>lc<span style="color:#f92672">;</span>
                            <span style="color:#f92672">}</span>
                            <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                                <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>p<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> hiTail<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                                    hi <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
                                <span style="color:#66d9ef">else</span>
                                    hiTail<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
                                hiTail <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
                                <span style="color:#f92672">++</span>hc<span style="color:#f92672">;</span>
                            <span style="color:#f92672">}</span>
                        <span style="color:#f92672">}</span>
                        <span style="color:#75715e">// 如果分化的树中元素个数小于等于6，则退化成链表
</span><span style="color:#75715e"></span>                        ln <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>lc <span style="color:#f92672">&lt;=</span> UNTREEIFY_THRESHOLD<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> untreeify<span style="color:#f92672">(</span>lo<span style="color:#f92672">)</span> <span style="color:#f92672">:</span>
                                <span style="color:#f92672">(</span>hc <span style="color:#f92672">!=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">new</span> TreeBin<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>lo<span style="color:#f92672">)</span> <span style="color:#f92672">:</span> t<span style="color:#f92672">;</span>
                        hn <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>hc <span style="color:#f92672">&lt;=</span> UNTREEIFY_THRESHOLD<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> untreeify<span style="color:#f92672">(</span>hi<span style="color:#f92672">)</span> <span style="color:#f92672">:</span>
                                <span style="color:#f92672">(</span>lc <span style="color:#f92672">!=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">new</span> TreeBin<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>hi<span style="color:#f92672">)</span> <span style="color:#f92672">:</span> t<span style="color:#f92672">;</span>
                        <span style="color:#75715e">// 低位树的位置不变
</span><span style="color:#75715e"></span>                        setTabAt<span style="color:#f92672">(</span>nextTab<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> ln<span style="color:#f92672">);</span>
                        <span style="color:#75715e">// 高位树的位置是原位置加n
</span><span style="color:#75715e"></span>                        setTabAt<span style="color:#f92672">(</span>nextTab<span style="color:#f92672">,</span> i <span style="color:#f92672">+</span> n<span style="color:#f92672">,</span> hn<span style="color:#f92672">);</span>
                        <span style="color:#75715e">// 标记该桶已迁移
</span><span style="color:#75715e"></span>                        setTabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> fwd<span style="color:#f92672">);</span>
                        <span style="color:#75715e">// advance为true，返回上面进行--i操作
</span><span style="color:#75715e"></span>                        advance <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                    <span style="color:#f92672">}</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

</code></pre></div><p>（1）新桶数组大小是旧桶数组的两倍；</p>
<p>（2）迁移元素先从靠后的桶开始；</p>
<p>（3）迁移完成的桶在里面放置一ForwardingNode类型的元素，标记该桶迁移完成；</p>
<p>（4）迁移时根据hash&amp;n是否等于0把桶中元素分化成两个链表或树；</p>
<p>（5）低位链表（树）存储在原来的位置；</p>
<p>（6）高们链表（树）存储在原来的位置加n的位置；</p>
<p>（7）迁移元素时会锁住当前桶，也是分段锁的思想；</p>
<h1 id="删除元素">删除元素</h1>
<p>删除元素跟添加元素一样，都是先找到元素所在的桶，然后采用分段锁的思想锁住整个桶，再进行操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span>Object key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 调用替换节点方法
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> replaceNode<span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">final</span> V <span style="color:#a6e22e">replaceNode</span><span style="color:#f92672">(</span>Object key<span style="color:#f92672">,</span> V value<span style="color:#f92672">,</span> Object cv<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 计算hash
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> hash <span style="color:#f92672">=</span> spread<span style="color:#f92672">(</span>key<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">());</span>
    <span style="color:#75715e">// 自旋
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab <span style="color:#f92672">=</span> table<span style="color:#f92672">;;)</span> <span style="color:#f92672">{</span>
        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> f<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> fh<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tab <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0 <span style="color:#f92672">||</span>
                <span style="color:#f92672">(</span>f <span style="color:#f92672">=</span> tabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> hash<span style="color:#f92672">))</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
            <span style="color:#75715e">// 如果目标key所在的桶不存在，跳出循环返回null
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>fh <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> MOVED<span style="color:#f92672">)</span>
            <span style="color:#75715e">// 如果正在扩容中，协助扩容
</span><span style="color:#75715e"></span>            tab <span style="color:#f92672">=</span> helpTransfer<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> f<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            V oldVal <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
            <span style="color:#75715e">// 标记是否处理过
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">boolean</span> validated <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>f<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 再次验证当前桶第一个元素是否被修改过
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> f<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>fh <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        <span style="color:#75715e">// fh&gt;=0表示是链表节点
</span><span style="color:#75715e"></span>                        validated <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                        <span style="color:#75715e">// 遍历链表寻找目标节点
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e <span style="color:#f92672">=</span> f<span style="color:#f92672">,</span> pred <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;;)</span> <span style="color:#f92672">{</span>
                            K ek<span style="color:#f92672">;</span>
                            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> hash <span style="color:#f92672">&amp;&amp;</span>
                                    <span style="color:#f92672">((</span>ek <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span>
                                            <span style="color:#f92672">(</span>ek <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>ek<span style="color:#f92672">))))</span> <span style="color:#f92672">{</span>
                                <span style="color:#75715e">// 找到了目标节点
</span><span style="color:#75715e"></span>                                V ev <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>
                                <span style="color:#75715e">// 检查目标节点旧value是否等于cv
</span><span style="color:#75715e"></span>                                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cv <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> cv <span style="color:#f92672">==</span> ev <span style="color:#f92672">||</span>
                                        <span style="color:#f92672">(</span>ev <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> cv<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>ev<span style="color:#f92672">)))</span> <span style="color:#f92672">{</span>
                                    oldVal <span style="color:#f92672">=</span> ev<span style="color:#f92672">;</span>
                                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>value <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                                        <span style="color:#75715e">// 如果value不为空则替换旧值
</span><span style="color:#75715e"></span>                                        e<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
                                    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>pred <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                                        <span style="color:#75715e">// 如果前置节点不为空
</span><span style="color:#75715e"></span>                                        <span style="color:#75715e">// 删除当前节点
</span><span style="color:#75715e"></span>                                        pred<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
                                    <span style="color:#66d9ef">else</span>
                                        <span style="color:#75715e">// 如果前置节点为空
</span><span style="color:#75715e"></span>                                        <span style="color:#75715e">// 说明是桶中第一个元素，删除之
</span><span style="color:#75715e"></span>                                        setTabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">);</span>
                                <span style="color:#f92672">}</span>
                                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                            <span style="color:#f92672">}</span>
                            pred <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
                            <span style="color:#75715e">// 遍历到链表尾部还没找到元素，跳出循环
</span><span style="color:#75715e"></span>                            <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>e <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                        <span style="color:#f92672">}</span>
                    <span style="color:#f92672">}</span>
                    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>f <span style="color:#66d9ef">instanceof</span> TreeBin<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        <span style="color:#75715e">// 如果是树节点
</span><span style="color:#75715e"></span>                        validated <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                        TreeBin<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> t <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>TreeBin<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span>f<span style="color:#f92672">;</span>
                        TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> r<span style="color:#f92672">,</span> p<span style="color:#f92672">;</span>
                        <span style="color:#75715e">// 遍历树找到了目标节点
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>r <span style="color:#f92672">=</span> t<span style="color:#f92672">.</span><span style="color:#a6e22e">root</span><span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span>
                                <span style="color:#f92672">(</span>p <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span><span style="color:#a6e22e">findTreeNode</span><span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                            V pv <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>
                            <span style="color:#75715e">// 检查目标节点旧value是否等于cv
</span><span style="color:#75715e"></span>                            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cv <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> cv <span style="color:#f92672">==</span> pv <span style="color:#f92672">||</span>
                                    <span style="color:#f92672">(</span>pv <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> cv<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>pv<span style="color:#f92672">)))</span> <span style="color:#f92672">{</span>
                                oldVal <span style="color:#f92672">=</span> pv<span style="color:#f92672">;</span>
                                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>value <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                                    <span style="color:#75715e">// 如果value不为空则替换旧值
</span><span style="color:#75715e"></span>                                    p<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
                                <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>t<span style="color:#f92672">.</span><span style="color:#a6e22e">removeTreeNode</span><span style="color:#f92672">(</span>p<span style="color:#f92672">))</span>
                                    <span style="color:#75715e">// 如果value为空则删除元素
</span><span style="color:#75715e"></span>                                    <span style="color:#75715e">// 如果删除后树的元素个数较少则退化成链表
</span><span style="color:#75715e"></span>                                    <span style="color:#75715e">// t.removeTreeNode(p)这个方法返回true表示删除节点后树的元素个数较少
</span><span style="color:#75715e"></span>                                    setTabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> untreeify<span style="color:#f92672">(</span>t<span style="color:#f92672">.</span><span style="color:#a6e22e">first</span><span style="color:#f92672">));</span>
                            <span style="color:#f92672">}</span>
                        <span style="color:#f92672">}</span>
                    <span style="color:#f92672">}</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
            <span style="color:#75715e">// 如果处理过，不管有没有找到元素都返回
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>validated<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 如果找到了元素，返回其旧值
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>oldVal <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    <span style="color:#75715e">// 如果要替换的值为空，元素个数减1
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>value <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                        addCount<span style="color:#f92672">(-</span>1L<span style="color:#f92672">,</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>
                    <span style="color:#66d9ef">return</span> oldVal<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// 没找到元素返回空
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

</code></pre></div><p>（1）计算hash；</p>
<p>（2）如果所在的桶不存在，表示没有找到目标元素，返回；</p>
<p>（3）如果正在扩容，则协助扩容完成后再进行删除操作；</p>
<p>（4）如果是以链表形式存储的，则遍历整个链表查找元素，找到之后再删除；</p>
<p>（5）如果是以树形式存储的，则遍历树查找元素，找到之后再删除；</p>
<p>（6）如果是以树形式存储的，删除元素之后树较小，则退化成链表；</p>
<p>（7）如果确实删除了元素，则整个map元素个数减1，并返回旧值；</p>
<p>（8）如果没有删除元素，则返回null；</p>
<h1 id="获取元素">获取元素</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>Object key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab<span style="color:#f92672">;</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e<span style="color:#f92672">,</span> p<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">,</span> eh<span style="color:#f92672">;</span> K ek<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 计算hash
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> spread<span style="color:#f92672">(</span>key<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">());</span>
    <span style="color:#75715e">// 如果元素所在的桶存在且里面有元素
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>tab <span style="color:#f92672">=</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">&amp;&amp;</span>
            <span style="color:#f92672">(</span>e <span style="color:#f92672">=</span> tabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> h<span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 如果第一个元素就是要找的元素，直接返回
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>eh <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> h<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>ek <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>ek <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>ek<span style="color:#f92672">)))</span>
                <span style="color:#66d9ef">return</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>eh <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
            <span style="color:#75715e">// hash小于0，说明是树或者正在扩容
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 使用find寻找元素，find的寻找方式依据Node的不同子类有不同的实现方式
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>p <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">find</span><span style="color:#f92672">(</span>h<span style="color:#f92672">,</span> key<span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">?</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

        <span style="color:#75715e">// 遍历整个链表寻找元素
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>e <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> h <span style="color:#f92672">&amp;&amp;</span>
                    <span style="color:#f92672">((</span>ek <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>ek <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>ek<span style="color:#f92672">))))</span>
                <span style="color:#66d9ef">return</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

</code></pre></div><p>（1）hash到元素所在的桶；</p>
<p>（2）如果桶中第一个元素就是该找的元素，直接返回；</p>
<p>（3）如果是树或者正在迁移元素，则调用各自Node子类的find()方法寻找元素；</p>
<p>（4）如果是链表，遍历整个链表寻找元素；</p>
<p>（5）获取元素没有加锁；</p>
<h1 id="获取元素个数">获取元素个数</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 调用sumCount()计算元素个数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">long</span> n <span style="color:#f92672">=</span> sumCount<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">((</span>n <span style="color:#f92672">&lt;</span> 0L<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> 0 <span style="color:#f92672">:</span>
            <span style="color:#f92672">(</span>n <span style="color:#f92672">&gt;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">long</span><span style="color:#f92672">)</span>Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">)</span> <span style="color:#f92672">?</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span> <span style="color:#f92672">:</span>
                    <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)</span>n<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">sumCount</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 计算CounterCell所有段及baseCount的数量之和
</span><span style="color:#75715e"></span>    CounterCell<span style="color:#f92672">[]</span> as <span style="color:#f92672">=</span> counterCells<span style="color:#f92672">;</span> CounterCell a<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">long</span> sum <span style="color:#f92672">=</span> baseCount<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>as <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> as<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> <span style="color:#f92672">++</span>i<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>a <span style="color:#f92672">=</span> as<span style="color:#f92672">[</span>i<span style="color:#f92672">])</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                sum <span style="color:#f92672">+=</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> sum<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

</code></pre></div><p>（1）元素的个数依据不同的线程存在在不同的段里；（见addCounter()分析）</p>
<p>（2）计算CounterCell所有段及baseCount的数量之和；</p>
<p>（3）获取元素个数没有加锁；</p>
<h1 id="总结">总结</h1>
<p>（1）ConcurrentHashMap是HashMap的线程安全版本；</p>
<p>（2）ConcurrentHashMap采用（数组 + 链表 + 红黑树）的结构存储元素；</p>
<p>（3）ConcurrentHashMap相比于同样线程安全的HashTable，效率要高很多；</p>
<p>（4）ConcurrentHashMap采用的锁有 synchronized，CAS，自旋锁，分段锁，volatile等；</p>
<p>（5）ConcurrentHashMap中没有threshold和loadFactor这两个字段，而是采用sizeCtl来控制；</p>
<p>（6）sizeCtl = -1，表示正在进行初始化；</p>
<p>（7）sizeCtl = 0，默认值，表示后续在真正初始化的时候使用默认容量；</p>
<p>（8）sizeCtl &gt; 0，在初始化之前存储的是传入的容量，在初始化或扩容后存储的是下一次的扩容门槛；</p>
<p>（9）sizeCtl = (resizeStamp &laquo; 16) + (1 + nThreads)，表示正在进行扩容，高位存储扩容邮戳，低位存储扩容线程数加1；</p>
<p>（10）更新操作时如果正在进行扩容，当前线程协助扩容；</p>
<p>（11）更新操作会采用synchronized锁住当前桶的第一个元素，这是分段锁的思想；</p>
<p>（12）整个扩容过程都是通过CAS控制sizeCtl这个字段来进行的，这很关键；</p>
<p>（13）迁移完元素的桶会放置一个ForwardingNode节点，以标识该桶迁移完毕；</p>
<p>（14）元素个数的存储也是采用的分段思想，类似于LongAdder的实现；</p>
<p>（15）元素个数的更新会把不同的线程hash到不同的段上，减少资源争用；</p>
<p>（16）元素个数的更新如果还是出现多个线程同时更新一个段，则会扩容段（CounterCell）；</p>
<p>（17）获取元素个数是把所有的段（包括baseCount和CounterCell）相加起来得到的；</p>
<p>（18）查询操作是不会加锁的，所以ConcurrentHashMap不是强一致性的；</p>
<p>（19）ConcurrentHashMap中不能存储key或value为null的元素；</p>
<h2 id="提问-1">提问</h2>
<ul>
<li>
<p>ConcurrentHashMap是怎么保证线程安全的？</p>
<p>ConcurrentHashMap内部使用的数据结构与HashMap一样，数组+链表+红黑树。Concurrent采用CAS+Synchronized的方式加锁。主要是在put和remove的时候，CAS是在竞争不激烈的时候使用，而Synchronized是在竞争激烈的时候，即已经在桶里面取链表或者红黑树的时候保证线程安全。</p>
</li>
<li>
<p>ConcurrentHashMap里的分段锁是什么？</p>
<p>ConcurrentHashMap没有直接使用Synchronized，即时Synchronized已经被优化了，但是在竞争不激烈的时候线程上下文切换的时间相对于CPU原子指令来说开销还是很大的。因此在找桶的时候，还属于竞争不激烈，因此这时使用的是CAS，无锁自旋。而hash取桶冲突时，竞争已经很激烈，此时使用Synchronized比CAS要高效，因为竞争激烈CAS大部分都会更新失败。这里的Synchronized锁的就是桶的头元素，相当于锁了桶，而ConcurentHashMap最外面就是一个桶数组，所以这里的Sync被称为分段锁，在put和remove的时候都会上锁。</p>
</li>
<li>
<p>ConcurrentHashMap强一致性吗？</p>
<p>不是的，get的时候没有加锁，不是强一致性</p>
</li>
<li>
<p>ConcurrentHashMap怎么计数的</p>
<p>ConcurrentHashMap在put完元素后会进行计数，并且扩容。计数是通过baseCount+CountCell[]数组来统计的。为了避免如果只使用一个size，多线程高并发情况下对size变更冲突太高。通过一个数组来记每个线程所持有的元素个数，再加上baseCount，在计数的时候，会先CAS一次baseCount，成功则说明并发不高，直接记baseCount，即可。当CountCell发生冲突的时候会直接扩容</p>
</li>
<li>
<p>ConcurrentHashMap是怎么扩容的</p>
<p>ConcurrentHashMap在扩容的时候固定扩容2倍，而阈值也是默认0.75。与HashMap默认值一样，细节太复杂，ConcurrentHashmap通过sizeCtrl来控制是否在扩容中，还是迁移元素，还是初始化中，这个值还是阈值。最重要的一点是与HashMap会在迁移元素时有优化，会将链表或者树，会将低16位的元素放在原来的位置，高16位迁移到n+oldIndex的地方，减少hash冲突持续在一个链表上，这也是为什么扩容必须是2倍，或者说是右移1位。</p>
</li>
<li>
<p>为什么ConcurrentHashMap的kv不能为null</p>
<blockquote>
<p>The main reason that nulls aren&rsquo;t allowed in ConcurrentMaps (ConcurrentHashMaps, ConcurrentSkipListMaps) is that ambiguities that may be just barely tolerable in non-concurrent maps can&rsquo;t be accommodated. The main one is that if <code>map.get(key)</code>returns <code>null</code>, you can&rsquo;t detect whether the key explicitly maps to <code>null</code> vs the key isn&rsquo;t mapped. In a non-concurrent map, you can check this via <code>map.contains(key)</code>, but in a concurrent one, the map might have changed between calls.</p>
</blockquote>
<p>主要原因是get方法没有锁，为了高性能，ConcurrentHashMap不是强一致性的，所以get的时候，可以会被其他线程修改了，如果我给了null的一个值，那么get的时候，不知道这个null是本身就不在，还是被其他线程修改成了null。而key不能为null，是这个key可能被人改过，不知道是不是自己的那个nullkey还是别人的nullkey了</p>
<p>ps: hashTable的key和value都不能为null</p>
</li>
<li>
<p>已经有concurrentHashMap了，为什么还会存在hashTable？直接都用ConcurrentHashMap不行吗</p>
<p>hashTable的所有方法都带了synchronized，包括<strong>get</strong>，这意味着hashTable是强一致性的，也就意味着当一个线程在获取元素的时候，其他线程是无法修改的！</p>
</li>
</ul>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/java%E5%9F%BA%E7%A1%80/" rel="tag">java基础</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="Frank Silva avatar" src="/img/avatar.png" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">About Frank Silva</span>
	</div>
	<div class="authorbox__description">
		Pursue Consummate Coding.
	</div>
</div>

<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/post/javacollections/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JavaCollections</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/post/hashset/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Hashset</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 Frank Silva.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
<script src="/js/custom.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>
</body>
</html>