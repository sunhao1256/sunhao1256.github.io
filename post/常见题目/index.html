<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>八股文 - Lulu</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="八股文" />
<meta property="og:description" content="Redis redis有哪些数据结构，你用过哪些，做过什么事情   String
最简单的数据结构，用于存放字符串，实际上在redis中存放的是字符数组，类似java中的arrayList，**Redis 为了对内存做极致的优化，不同长度的字符串使用不同的结构体来表示。**Redis 规定了字符串的长度不得超过 512 MB
  List
底层用的双向列表，类似java中的LinkedList，因为是链表所有，插入删除都是O(1)，查询是O(n)
常见的命令
  lpush从头添加元素，rpush从尾添加
  lpop拿出头部的元素，rpop从尾部拿元素
索引，lpush&#43;lpop即可实现栈，rpush&#43;lpop可以实现队列
    Hash
对应着java中的hashMap
  Set
Redis 的集合相当于 Java 语言中的 HashSet，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。
  Zset
它类似于 Java 中 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。
使用场景：
 排行榜，key是用户id，value是访问次数。 限流，key是用户id&#43;接口id，value是时间戳，每次进方法之前，拿当前时间戳-interval，删除小于now-interval的元素，算出加入当前这次请求set中的个数是否大于max，大于则限流。    BloomFilter
使用高效的数据结构解决是否存在的问题，可以解决穿透的问题
  HyperLogLog
可以用于基数的统计，例如UV统计
  redis如何做到限流的 限流的几个方式" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sunhao1256.github.io/post/%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-11T14:43:18+08:00" />
<meta property="article:modified_time" content="2022-01-11T14:43:18+08:00" />


		<meta itemprop="name" content="八股文">
<meta itemprop="description" content="Redis redis有哪些数据结构，你用过哪些，做过什么事情   String
最简单的数据结构，用于存放字符串，实际上在redis中存放的是字符数组，类似java中的arrayList，**Redis 为了对内存做极致的优化，不同长度的字符串使用不同的结构体来表示。**Redis 规定了字符串的长度不得超过 512 MB
  List
底层用的双向列表，类似java中的LinkedList，因为是链表所有，插入删除都是O(1)，查询是O(n)
常见的命令
  lpush从头添加元素，rpush从尾添加
  lpop拿出头部的元素，rpop从尾部拿元素
索引，lpush&#43;lpop即可实现栈，rpush&#43;lpop可以实现队列
    Hash
对应着java中的hashMap
  Set
Redis 的集合相当于 Java 语言中的 HashSet，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。
  Zset
它类似于 Java 中 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。
使用场景：
 排行榜，key是用户id，value是访问次数。 限流，key是用户id&#43;接口id，value是时间戳，每次进方法之前，拿当前时间戳-interval，删除小于now-interval的元素，算出加入当前这次请求set中的个数是否大于max，大于则限流。    BloomFilter
使用高效的数据结构解决是否存在的问题，可以解决穿透的问题
  HyperLogLog
可以用于基数的统计，例如UV统计
  redis如何做到限流的 限流的几个方式"><meta itemprop="datePublished" content="2022-01-11T14:43:18+08:00" />
<meta itemprop="dateModified" content="2022-01-11T14:43:18+08:00" />
<meta itemprop="wordCount" content="6531">
<meta itemprop="keywords" content="面试," />
		<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="八股文"/>
<meta name="twitter:description" content="Redis redis有哪些数据结构，你用过哪些，做过什么事情   String
最简单的数据结构，用于存放字符串，实际上在redis中存放的是字符数组，类似java中的arrayList，**Redis 为了对内存做极致的优化，不同长度的字符串使用不同的结构体来表示。**Redis 规定了字符串的长度不得超过 512 MB
  List
底层用的双向列表，类似java中的LinkedList，因为是链表所有，插入删除都是O(1)，查询是O(n)
常见的命令
  lpush从头添加元素，rpush从尾添加
  lpop拿出头部的元素，rpop从尾部拿元素
索引，lpush&#43;lpop即可实现栈，rpush&#43;lpop可以实现队列
    Hash
对应着java中的hashMap
  Set
Redis 的集合相当于 Java 语言中的 HashSet，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。
  Zset
它类似于 Java 中 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。
使用场景：
 排行榜，key是用户id，value是访问次数。 限流，key是用户id&#43;接口id，value是时间戳，每次进方法之前，拿当前时间戳-interval，删除小于now-interval的元素，算出加入当前这次请求set中的个数是否大于max，大于则限流。    BloomFilter
使用高效的数据结构解决是否存在的问题，可以解决穿透的问题
  HyperLogLog
可以用于基数的统计，例如UV统计
  redis如何做到限流的 限流的几个方式"/>

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/custom.css">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="/" title="Lulu" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="/img/placeholder.png">
				</div><div class="logo__item logo__text">
					<div class="logo__title">Lulu</div>
					<div class="logo__tagline">Lulu is arrongant cat</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">About</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">八股文</h1>
			<div class="post__meta meta"><div class="meta__item-author meta__item">
	<svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2 0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class="meta__text">Frank Silva</span>
</div>
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2022-01-11T14:43:18&#43;08:00">2022-01-11</time></div></div>
		</header>
		
<div class="post__toc toc">
	<div class="toc__title">Page content</div>
	<div class="toc__menu">
		<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#redis有哪些数据结构你用过哪些做过什么事情">redis有哪些数据结构，你用过哪些，做过什么事情</a></li>
        <li><a href="#redis如何做到限流的">redis如何做到限流的</a></li>
        <li><a href="#redis是单线程的吗它为什么这么快">redis是单线程的吗，它为什么这么快？</a></li>
        <li><a href="#redis在主从复制的和故障转移的过程中会导致数据丢失吗"><strong>Redis在主从复制的和故障转移的过程中会导致数据丢失吗</strong></a></li>
        <li><a href="#redis的高可用和持久化">redis的高可用和持久化</a></li>
        <li><a href="#优点">优点：</a></li>
        <li><a href="#缺点">缺点：</a></li>
        <li><a href="#优点-1">优点：</a></li>
        <li><a href="#缺点-1">缺点：</a></li>
        <li><a href="#redis布隆过滤器">redis布隆过滤器</a></li>
        <li><a href="#redis分布式锁">redis分布式锁</a></li>
        <li><a href="#redis为什么选用跳表">redis为什么选用跳表</a></li>
        <li><a href="#redis防击穿雪崩穿透">redis防击穿、雪崩、穿透</a></li>
        <li><a href="#redis是先删缓存还是先写库怎么解决缓存一致性">redis是先删缓存还是先写库，怎么解决缓存一致性</a></li>
        <li><a href="#redis的淘汰策略">redis的淘汰策略</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#arthas">arthas</a></li>
        <li><a href="#jdk自带命令">jdk自带命令</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#消息队列的通信模式">消息队列的通信模式</a></li>
        <li><a href="#kafka架构">Kafka架构</a></li>
        <li><a href="#为什么要用消息队列">为什么要用消息队列</a></li>
        <li><a href="#kafka的推还是拉">Kafka的推还是拉</a></li>
        <li><a href="#kafka如何做到消息不丢失的">Kafka如何做到消息不丢失的</a></li>
        <li><a href="#kafka为什么可以有这么大的吞吐量">Kafka为什么可以有这么大的吞吐量</a></li>
        <li><a href="#kafka怎么保证顺序消费">Kafka怎么保证顺序消费</a></li>
        <li><a href="#kafka怎么保证不重复消费的">kafka怎么保证不重复消费的</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#一条语句的执行过程">一条语句的执行过程</a></li>
        <li><a href="#常见的存储引擎">常见的存储引擎</a></li>
        <li><a href="#一张表里面有id自增主键当insert了17条记录之后删除了第151617条记录再把mysql重启再insert一条记录这条记录的id是18还是15-">一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</a></li>
        <li><a href="#自增主键用完了怎么办">自增主键用完了怎么办</a></li>
        <li><a href="#mysql的索引数据结构为什么用b树讲一讲mysql索引的数据结构是什么样的">mysql的索引数据结构为什么用B+树，讲一讲mysql索引的数据结构是什么样的</a></li>
        <li><a href="#最左匹配原则是什么">最左匹配原则是什么</a></li>
        <li><a href="#explain">Explain</a></li>
        <li><a href="#说出你如何调优的">说出你如何调优的</a></li>
        <li><a href="#常见的优化手段">常见的优化手段</a></li>
        <li><a href="#mvvc">MVVC</a></li>
        <li><a href="#事务特性隔离级别怎么解决幻读">事务特性，隔离级别，怎么解决幻读？</a></li>
        <li><a href="#三范式">三范式</a></li>
        <li><a href="#为什么要分库分表有什么方案">为什么要分库分表，有什么方案</a></li>
        <li><a href="#什么是回表">什么是回表</a></li>
        <li><a href="#mysql覆盖索引">MySQL覆盖索引</a></li>
        <li><a href="#为什么非主键索引结构叶子节点存储的是主键值">为什么非主键索引结构叶子节点存储的是主键值？</a></li>
        <li><a href="#为什么mysql索引要用b树不是b树">为什么Mysql索引要用B+树不是B树？</a></li>
        <li><a href="#为何不采用hash创建索引方式">为何不采用Hash创建索引方式？</a></li>
        <li><a href="#什么时候需要建立索引什么时候不需要建立索引">什么时候需要建立索引，什么时候不需要建立索引</a></li>
        <li><a href="#数据库建立索引常用的规则如下">数据库建立索引常用的规则如下：</a></li>
        <li><a href="#count1countcount列名">count(1)，count(*)，count(列名)</a></li>
        <li><a href="#mysql单表一千万数据怎么查最快">mysql单表一千万数据，怎么查最快</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#讲一讲mybatis-的工作原理">讲一讲mybatis 的工作原理</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#spring的bean注入过程讲一下">Spring的Bean注入过程讲一下</a></li>
        <li><a href="#spring中常见的设计模式说一说">Spring中常见的设计模式说一说</a></li>
        <li><a href="#spring是怎么解决bean之间的循环依赖问题">Spring是怎么解决Bean之间的循环依赖问题</a></li>
        <li><a href="#springmvc的流程">SpringMvc的流程</a></li>
        <li><a href="#springboot的启动原理">SpringBoot的启动原理</a></li>
        <li><a href="#springcloud了解多少">SpringCloud了解多少</a></li>
        <li><a href="#aop怎么实现的">AOP怎么实现的</a></li>
        <li><a href="#configureable的作用">@Configureable的作用</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#怎么保证幂等">怎么保证幂等</a></li>
        <li><a href="#cap">CAP</a></li>
        <li><a href="#nacos怎么实现的ap和cp">Nacos怎么实现的AP和CP</a></li>
        <li><a href="#为什么要用dubbo和springcloud的区别是什么">为什么要用dubbo，和SpringCloud的区别是什么</a></li>
        <li><a href="#分布式事务分布式锁分布式链路追踪解决方案">分布式事务、分布式锁、分布式链路追踪解决方案</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#为什么es能查询的这么快">为什么ES能查询的这么快</a></li>
        <li><a href="#你了解多少es为什么选择用es">你了解多少ES，为什么选择用ES</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#zookeeper是干什么的你使用过吗用它做过什么事情吗">Zookeeper是干什么的，你使用过吗，用它做过什么事情吗</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#讲一下伪共享">讲一下伪共享</a></li>
        <li><a href="#你知道unsafe类吗为什么他是unsafe的它能做什么">你知道UnSafe类吗，为什么他是“UnSafe”的，它能做什么</a></li>
        <li><a href="#异步同步阻塞非阻塞线程进程他们的关系">异步、同步；阻塞、非阻塞；线程、进程他们的关系</a></li>
        <li><a href="#你知道哪几种锁">你知道哪几种锁</a></li>
        <li><a href="#自己实现一个锁">自己实现一个锁</a></li>
        <li><a href="#讲一下线程的生命周期">讲一下线程的生命周期</a></li>
        <li><a href="#线程可以被终止吗怎么终止">线程可以被终止吗，怎么终止</a></li>
        <li><a href="#aqs是什么">AQS是什么？</a></li>
        <li><a href="#waitnotifysleepyieldjoininterrupt这几个方法的作用">wait()、notify()、sleep()、yield()、join()、Interrupt()这几个方法的作用</a></li>
        <li><a href="#实现线程安全的方法">实现线程安全的方法</a></li>
        <li><a href="#公平锁和非公平锁的区别reentrantlock是怎么实现的reentrantlock又是怎么实现重入锁的它的条件锁又是什么">公平锁和非公平锁的区别,ReentrantLock是怎么实现的，ReentrantLock又是怎么实现重入锁的，它的条件锁又是什么？</a></li>
        <li><a href="#reetrantwhritereadlock是怎么实现读写锁的">ReetrantWhriteReadLock是怎么实现读写锁的</a></li>
        <li><a href="#cas是什么怎么解决aba问题">CAS是什么，怎么解决ABA问题</a></li>
        <li><a href="#concurrenthashmap的分段锁">ConcurrentHashMap的分段锁</a></li>
        <li><a href="#你用过哪些javautilconcurrent下的类">你用过哪些Java.util.concurrent下的类</a></li>
        <li><a href="#讲一下线程池的几个参数含义">讲一下线程池的几个参数含义</a></li>
        <li><a href="#synchronized关键字怎么优化的膨胀的流程">synchronized关键字，怎么优化的，膨胀的流程</a></li>
        <li><a href="#volatile关键字">volatile关键字</a></li>
        <li><a href="#java内存模型">Java内存模型</a></li>
        <li><a href="#threadlocal">ThreadLocal</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#说下java的基本类型">说下Java的基本类型</a></li>
        <li><a href="#重载和重写">重载和重写</a></li>
        <li><a href="#讲一下string">讲一下String</a></li>
        <li><a href="#讲一下final">讲一下final</a></li>
        <li><a href="#讲一下static">讲一下Static</a></li>
        <li><a href="#讲一下equals和hashcode以及clone">讲一下equals和hashCode以及clone</a></li>
        <li><a href="#如何实现浅拷贝和深拷贝">如何实现浅拷贝和深拷贝</a></li>
        <li><a href="#java限定符">java限定符</a></li>
        <li><a href="#接口和抽象类">接口和抽象类</a></li>
        <li><a href="#说一说你理解的多态">说一说你理解的多态</a></li>
        <li><a href="#讲一下泛型和注解">讲一下泛型和注解</a></li>
        <li><a href="#讲一下反射和动态代理">讲一下反射和动态代理</a></li>
        <li><a href="#java的几种引用你用过几种">Java的几种引用，你用过几种</a></li>
        <li><a href="#说说进程和线程的区别">说说进程和线程的区别</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#讲一讲集合类常用的集合以及在多线程下你是如何保集合安全的">讲一讲集合类，常用的集合，以及在多线程下你是如何保集合安全的</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#jvm是什么">JVM是什么</a></li>
        <li><a href="#java内存模型-1">Java内存模型</a></li>
        <li><a href="#java编译到执行的过程">Java编译到执行的过程</a></li>
        <li><a href="#双亲委派机制是干什么的">双亲委派机制是干什么的</a></li>
        <li><a href="#jvm内存结构">JVM内存结构</a></li>
        <li><a href="#垃圾回收">垃圾回收</a></li>
        <li><a href="#平时如何调优">平时如何调优</a></li>
        <li><a href="#一个对象到底有多大对象在内存中长什么样子">一个对象到底有多大，“对象在内存中长什么样子”</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#交换机和路由器区别">交换机和路由器区别</a></li>
        <li><a href="#nas知道吗">Nas知道吗</a></li>
        <li><a href="#什么长链接什么时候该用长链接什么又是长轮训短轮训java怎么实现">什么长链接，什么时候该用长链接，什么又是长轮训，短轮训。java怎么实现</a></li>
        <li><a href="#java怎么写udp为什么要用udp">java怎么写UDP？为什么要用UDP</a></li>
        <li><a href="#异步请求知道吗有什么场景可以用到吗java怎么写">异步请求知道吗？有什么场景可以用到吗，java怎么写？</a></li>
        <li><a href="#讲一下tcpip它和http的关系">讲一下TCP/IP，它和HTTP的关系</a></li>
        <li><a href="#什么是websocketws是长链接吗wss又有什么区别">什么是WebSocket，WS是长链接吗，WSS又有什么区别？</a></li>
        <li><a href="#tcp长链接和http长链接有什么区别">TCP长链接和HTTP长链接有什么区别</a></li>
        <li><a href="#netty干什么的用过吗">Netty干什么的，用过吗</a></li>
        <li><a href="#你知道哪些网络模型">你知道哪些网络模型？</a></li>
        <li><a href="#你知道哪些io模型bionioaio都是什么他们的使用场景是什么">你知道哪些IO模型，BIO、NIO、AIO都是什么，他们的使用场景是什么</a></li>
        <li><a href="#讲一下httpshttphttp10http11http2">讲一下Https、Http、Http1.0、Http1.1、Http2</a></li>
        <li><a href="#什么是多路复用">什么是多路复用</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#聊聊设计模式你知道哪些用过哪些为什么要用设计模式">聊聊设计模式，你知道哪些，用过哪些，为什么要用设计模式</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#你知道哪些数据结构">你知道哪些数据结构</a></li>
        <li><a href="#红黑树b树b树二叉树完全平衡二叉树">红黑树、B树、B+树、二叉树、完全平衡二叉树</a></li>
        <li><a href="#手写一个链表实现正向输出反向输出找到最中间的元素">手写一个链表，实现正向输出，反向输出，找到最中间的元素</a></li>
        <li><a href="#什么是堆">什么是堆</a></li>
        <li><a href="#使用堆的原因">使用堆的原因？</a></li>
        <li><a href="#环形队列">环形队列</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#你能写出几个排序算法">你能写出几个排序算法</a></li>
        <li><a href="#你能写出几个查找算法">你能写出几个查找算法</a></li>
        <li><a href="#你能写出几个去重算法">你能写出几个去重算法</a></li>
        <li><a href="#lru">LRU</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#零拷贝是什么">零拷贝是什么</a></li>
        <li><a href="#顺序读写和随机读写">顺序读写和随机读写</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#olap和oltp有什么区别">OLAP和OLTP有什么区别</a></li>
      </ul>
    </li>
  </ul>
</nav>
	</div>
</div><div class="content post__content clearfix">
			<h1 id="redis">Redis</h1>
<h3 id="redis有哪些数据结构你用过哪些做过什么事情">redis有哪些数据结构，你用过哪些，做过什么事情</h3>
<ul>
<li>
<p>String</p>
<p>最简单的数据结构，用于存放字符串，实际上在redis中存放的是字符数组，类似java中的arrayList，**Redis 为了对内存做极致的优化，不同长度的字符串使用不同的结构体来表示。**Redis 规定了字符串的长度不得超过 512 MB</p>
</li>
<li>
<p>List</p>
<p>底层用的双向列表，类似java中的LinkedList，因为是链表所有，插入删除都是O(1)，查询是O(n)</p>
<p>常见的命令</p>
<ul>
<li>
<p>lpush从头添加元素，rpush从尾添加</p>
</li>
<li>
<p>lpop拿出头部的元素，rpop从尾部拿元素</p>
<p>索引，lpush+lpop即可实现栈，rpush+lpop可以实现队列</p>
</li>
</ul>
</li>
<li>
<p>Hash</p>
<p>对应着java中的hashMap</p>
</li>
<li>
<p>Set</p>
<p>Redis 的集合相当于 Java 语言中的 <strong>HashSet</strong>，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。</p>
</li>
<li>
<p>Zset</p>
<p>它类似于 Java 中 <strong>SortedSet</strong> 和 <strong>HashMap</strong> 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。</p>
<p>使用场景：</p>
<ul>
<li>排行榜，key是用户id，value是访问次数。</li>
<li>限流，key是用户id+接口id，value是时间戳，每次进方法之前，拿当前时间戳-interval，删除小于now-interval的元素，算出加入当前这次请求set中的个数是否大于max，大于则限流。</li>
</ul>
</li>
<li>
<p>BloomFilter</p>
<p>使用高效的数据结构解决是否存在的问题，可以解决穿透的问题</p>
</li>
<li>
<p>HyperLogLog</p>
<p>可以用于基数的统计，例如UV统计</p>
</li>
</ul>
<h3 id="redis如何做到限流的">redis如何做到限流的</h3>
<p>限流的几个方式</p>
<ul>
<li>
<p>计数器</p>
<p>计数器即是计算在单位时间窗口内请求访问的次数是否超过阀值。</p>
<p>窗口分为：固定窗口、滑动窗口</p>
<ul>
<li>
<p>固定窗口java实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> AtomicInteger cur <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AtomicInteger<span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">private</span> Long startTime<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isAllowed</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> maxCount<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> interval<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//如果没有第一次时间，则当下为第一次时间
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>startTime <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
            startTime <span style="color:#f92672">=</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">currentTimeMillis</span><span style="color:#f92672">();</span>
        <span style="color:#75715e">//新增一次
</span><span style="color:#75715e"></span>        cur<span style="color:#f92672">.</span><span style="color:#a6e22e">addAndGet</span><span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
        <span style="color:#75715e">//如果当前时间减去开始时间，大于间隙了，说明进入新一轮计算
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">currentTimeMillis</span><span style="color:#f92672">()</span> <span style="color:#f92672">-</span> interval <span style="color:#f92672">*</span> 1000L <span style="color:#f92672">&gt;</span> startTime<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">//重置开始时间
</span><span style="color:#75715e"></span>            startTime <span style="color:#f92672">=</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">currentTimeMillis</span><span style="color:#f92672">();</span>
            <span style="color:#75715e">//重置计数
</span><span style="color:#75715e"></span>            cur<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">//还在时间内
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> cur<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">()</span> <span style="color:#f92672">&lt;=</span> maxCount<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>固定窗口解决了在单位时间内流量次数不会超过阀值，但是在临界点会出现问题。</p>
<!-- raw HTML omitted -->
<p>在前一个一秒内，0.8秒到1秒，访问了5次，没有超过阀值，1秒到1.2秒访问了5次，没有超过阀值。0.8秒到1.2秒之间的0.4秒访问了10次，超过了阀值。没有达到目的。这样的问题原因是窗口没有“滑动”。</p>
</li>
<li>
<p>滑动窗口</p>
<p>滑动窗口是一种算法思想</p>
<blockquote>
<p>滑动窗口算法（Sliding Window Algorithm）</p>
</blockquote>
<blockquote>
<p>Sliding window algorithm is used to perform required operation on specific window size of given large buffer or array.</p>
<p>滑动窗口算法是在给定特定窗口大小的数组或字符串上执行要求的操作。</p>
</blockquote>
<blockquote>
<p>This technique shows how a nested for loop in few problems can be converted to single for loop and hence reducing the time complexity.</p>
<p>该技术可以将一部分问题中的嵌套循环转变为一个单循环，因此它可以减少时间复杂度。</p>
</blockquote>
<p>简而言之，滑动窗口算法在一个特定大小的字符串或数组上进行操作，而不在整个字符串和数组上操作，这样就降低了问题的复杂度，从而也达到降低了循环的嵌套深度。<strong>其实这里就可以看出来滑动窗口主要应用在数组和字符串上。</strong></p>
<p>常见的算法题，找到A字符串中，包含T个字符的最小覆盖子串</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">//找到字符串EBBANCF中包含ABC三个字符的最小子串
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">//往往类似于“ 请找到满足 xx 的最 x 的区间（子串、子数组）的 xx ”这类问题都可以使用该方法进行解决。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">noFixed</span><span style="color:#f92672">(</span>String str<span style="color:#f92672">,</span>String target<span style="color:#f92672">){</span>

        String<span style="color:#f92672">[]</span> s <span style="color:#f92672">=</span> str<span style="color:#f92672">.</span><span style="color:#a6e22e">split</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">);</span>
        String<span style="color:#f92672">[]</span> t <span style="color:#f92672">=</span> target<span style="color:#f92672">.</span><span style="color:#a6e22e">split</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">);</span>

        <span style="color:#75715e">//定义两个指针，在s上滑动
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> left<span style="color:#f92672">=</span>0<span style="color:#f92672">,</span>right<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span>

        String res<span style="color:#f92672">=</span><span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

        List window<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">();</span>
        <span style="color:#75715e">//一直滑动，直到右指针到头了
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>right<span style="color:#f92672">&lt;</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">){</span>
            <span style="color:#75715e">//移动右指针，一直到包含了所有的目标元素
</span><span style="color:#75715e"></span>            window<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>s<span style="color:#f92672">[</span>right<span style="color:#f92672">]);</span>
            right<span style="color:#f92672">++;</span>
            <span style="color:#75715e">//如果window满足要求了，就移动左指针
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>window<span style="color:#f92672">.</span><span style="color:#a6e22e">containsAll</span><span style="color:#f92672">(</span>Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>t<span style="color:#f92672">))){</span>
                <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>res<span style="color:#f92672">==</span><span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
                    <span style="color:#75715e">//第一次得到结果
</span><span style="color:#75715e"></span>                    res<span style="color:#f92672">=</span>String<span style="color:#f92672">.</span><span style="color:#a6e22e">join</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">,</span>window<span style="color:#f92672">);</span>
                <span style="color:#f92672">}</span><span style="color:#66d9ef">else</span><span style="color:#f92672">{</span>
                    <span style="color:#75715e">//比较当前的长度大小和目前最小的结果
</span><span style="color:#75715e"></span>                    res<span style="color:#f92672">=(</span>window<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()&gt;</span>res<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">())?</span>String<span style="color:#f92672">.</span><span style="color:#a6e22e">join</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">,</span>window<span style="color:#f92672">):</span>res<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
                <span style="color:#75715e">//移动左指针,直至窗口不满足
</span><span style="color:#75715e"></span>                window<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span>s<span style="color:#f92672">[</span>left<span style="color:#f92672">]);</span>
                left<span style="color:#f92672">++;</span>
            <span style="color:#f92672">}</span>

        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> res<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>


    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 固定窗口大小为f
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">fixed</span><span style="color:#f92672">(</span>Integer f<span style="color:#f92672">,</span> String str<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        String result <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

        <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#75715e">//寻找字符串中长度为f的包含最多元音字母的子串
</span><span style="color:#75715e"></span>        String<span style="color:#f92672">[]</span> s <span style="color:#f92672">=</span> str<span style="color:#f92672">.</span><span style="color:#a6e22e">split</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">);</span>

        List window <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">();</span>

        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>right <span style="color:#f92672">&lt;</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">//滑动右指针
</span><span style="color:#75715e"></span>            window<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>s<span style="color:#f92672">[</span>right<span style="color:#f92672">]);</span>
            right<span style="color:#f92672">++;</span>
            <span style="color:#75715e">//达到目标窗口的大小
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>right <span style="color:#f92672">&gt;=</span> f<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">//检查条件
</span><span style="color:#75715e"></span>                String cur <span style="color:#f92672">=</span> String<span style="color:#f92672">.</span><span style="color:#a6e22e">join</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">,</span> window<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>result <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    <span style="color:#75715e">//满足条件的话
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>countOfVowel<span style="color:#f92672">(</span>cur<span style="color:#f92672">)</span> <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span>
                        result <span style="color:#f92672">=</span> cur<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> countOfVowel<span style="color:#f92672">(</span>result<span style="color:#f92672">);</span>
                    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> countOfVowel<span style="color:#f92672">(</span>cur<span style="color:#f92672">);</span>
                    result <span style="color:#f92672">=</span> i <span style="color:#f92672">&gt;</span> j <span style="color:#f92672">?</span> result <span style="color:#f92672">:</span> cur<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
                <span style="color:#75715e">//移动左指针，因为窗口固定，删除左边right-f个字符
</span><span style="color:#75715e"></span>                window<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span>s<span style="color:#f92672">[</span>right<span style="color:#f92672">-</span>f<span style="color:#f92672">]);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> result<span style="color:#f92672">;</span>

    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">countOfVowel</span><span style="color:#f92672">(</span>String s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        String<span style="color:#f92672">[]</span> split <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">split</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">);</span>
        List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> vowels <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;A&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;E&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;I&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;O&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;U&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> split<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>vowels<span style="color:#f92672">.</span><span style="color:#a6e22e">contains</span><span style="color:#f92672">(</span>split<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">toUpperCase</span><span style="color:#f92672">()))</span> <span style="color:#f92672">{</span>
                res<span style="color:#f92672">++;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> res<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>滑动窗口解决了临界的问题，但是当在窗口内达到了阀值，剩余的请求都会被拒绝，这样处理不好。</p>
</li>
</ul>
</li>
<li>
<p>漏桶</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LeakBucketLimit</span> <span style="color:#f92672">{</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 出水率
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> rate<span style="color:#f92672">=</span>5L<span style="color:#f92672">;</span><span style="color:#75715e">//1秒出水5个请求
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 桶的容量
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> capacity<span style="color:#f92672">=</span>10L<span style="color:#f92672">;</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 当前水量
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">private</span>  <span style="color:#66d9ef">long</span> currentWater<span style="color:#f92672">;</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 最后刷新时间
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">long</span> refreshTime<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAcquire</span><span style="color:#f92672">(){</span>
        <span style="color:#75715e">/**
</span><span style="color:#75715e">         * 获取当前时间
</span><span style="color:#75715e">         */</span>
        <span style="color:#66d9ef">long</span> currentTime <span style="color:#f92672">=</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">currentTimeMillis</span><span style="color:#f92672">();</span>

        <span style="color:#75715e">/**
</span><span style="color:#75715e">         * 流出去的水
</span><span style="color:#75715e">         */</span>
        <span style="color:#66d9ef">long</span> outWater <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>currentTime<span style="color:#f92672">-</span>refreshTime<span style="color:#f92672">)/</span>1000<span style="color:#f92672">*</span>rate<span style="color:#f92672">;</span>

        <span style="color:#75715e">/**
</span><span style="color:#75715e">         * 当前
</span><span style="color:#75715e">         */</span>
        currentWater <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>0<span style="color:#f92672">,</span>currentWater<span style="color:#f92672">-</span>outWater<span style="color:#f92672">);</span>

        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>currentWater<span style="color:#f92672">);</span>
        refreshTime<span style="color:#f92672">=</span>currentTime<span style="color:#f92672">;</span>

        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>currentWater<span style="color:#f92672">&gt;=</span>capacity<span style="color:#f92672">){</span>
            <span style="color:#75715e">//不够流了
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#75715e">//加水
</span><span style="color:#75715e"></span>        currentWater<span style="color:#f92672">++;</span>

        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>缺陷：不管是什么流量，桶都会按照rate一点一点消费，如果来了爆炸的流量，依然一点一点消费，实际情况中，我们希望能快速消费。而平时就按照rate消费。</p>
</li>
<li>
<p>令牌桶</p>
<p>令牌桶就是为了解决漏桶的缺点。</p>
<!-- raw HTML omitted -->
<blockquote>
<ul>
<li>有一个令牌管理员，根据限流大小，定速往令牌桶里放令牌。</li>
<li>如果令牌数量满了，超过令牌桶容量的限制，那就丢弃。</li>
<li>系统在接受到一个用户请求时，都会先去令牌桶要一个令牌。如果拿到令牌，那么就处理这个请求的业务逻辑；</li>
<li>如果拿不到令牌，就直接拒绝这个请求。</li>
</ul>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 令牌桶发放速度
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> tokenRate<span style="color:#f92672">=</span>5L<span style="color:#f92672">;</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 桶的容量
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> capacity<span style="color:#f92672">=</span>10<span style="color:#f92672">;</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 上一次刷新的时间
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">private</span>  <span style="color:#66d9ef">long</span> refreshTime<span style="color:#f92672">;</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 当前桶里的令牌
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">long</span> currentToken<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAcquire</span><span style="color:#f92672">(){</span>
        <span style="color:#75715e">//当前时间
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">long</span> currentTime<span style="color:#f92672">=</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">currentTimeMillis</span><span style="color:#f92672">();</span>

        <span style="color:#75715e">//更新当前桶里的令牌个数
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//当前token个数=原来当前个数+间隙之间生产出来的token个数（可能为0）
</span><span style="color:#75715e"></span>        currentToken <span style="color:#f92672">=</span>Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span> <span style="color:#f92672">(</span>capacity<span style="color:#f92672">,(</span>currentToken<span style="color:#f92672">+</span>currentTime <span style="color:#f92672">-</span> refreshTime<span style="color:#f92672">)</span> <span style="color:#f92672">/</span> 1000 <span style="color:#f92672">*</span> tokenRate<span style="color:#f92672">);</span>

        refreshTime<span style="color:#f92672">=</span>currentTime<span style="color:#f92672">;</span>

        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>currentToken<span style="color:#f92672">&gt;</span>0<span style="color:#f92672">){</span>
            <span style="color:#75715e">//还有令牌
</span><span style="color:#75715e"></span>            currentToken<span style="color:#f92672">--;</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

</code></pre></div></li>
</ul>
<h3 id="redis是单线程的吗它为什么这么快">redis是单线程的吗，它为什么这么快？</h3>
<ul>
<li>
<p>是“单线程”也不是“单线程”</p>
<p>在redis6.0后，推出了多线程的概念。这里的单线程或者多线程，是对于整个redis来说的。并不是针对一个缓存的读取而言。</p>
<p>说redis是单线程的，并不是说redis的所有操作模块都是单线程的。redis单线程指的是，用单个线程进行网络io和键值读取。</p>
<p><strong>Redis中只有网络请求模块和数据操作模块是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的</strong></p>
<p>在redis6.0之前一直是这样处理的，为什么对于网络的io不用多线程呢。</p>
<blockquote>
<p>首先使用多线程的目的是为了提高IO利用率和CPU利用率，而redis的是io密集型软件。CPU并不是它的瓶颈。可以使用多线程来提高IO</p>
<p>利用率，但是提高IO利用率的方法并非只有多线程一种方式</p>
</blockquote>
<p>对线程带来的弊端：内存模型，锁，CAS操作保证并发。</p>
<p><strong>虽然，采用多线程可以帮助我们提升CPU和I/O的利用率，但是多线程带来的并发问题也给这些语言和框架带来了更多的复杂性。而且，多线程模型中，多个线程的互相切换也会带来一定的性能开销。</strong></p>
<p>所以，在提升I/O利用率这个方面上，Redis并没有采用多线程技术，而是选择了<strong>多路复用 I/O</strong>技术。</p>
<p><strong>多路复用即redis使用单线程，去接收并发下的网络套接字。redis没有使用多线程，减少线程之前切换的开销，以及多线程带来的共享对象的并发问题。因此大家称redis是单线程的</strong></p>
<p><strong>由于多路复用的IO模型本质上仍然是同步阻塞型IO模型</strong>。</p>
<!-- raw HTML omitted -->
<p><strong>在多路复用的IO模型中，在处理网络请求时，调用 select （其他函数同理）的过程是阻塞的，也就是说这个过程会阻塞线程，如果并发量很高，此处可能会成为瓶颈。</strong></p>
<p><strong>如果能采用多线程，使得网络处理的请求并发进行，就可以大大的提升性能。多线程除了可以减少由于网络 I/O 等待造成的影响，还可以充分利用 CPU 的多核优势。</strong></p>
<p>Redis 6.0采用多个IO线程来处理网络请求，网络请求的解析可以由其他线程完成，然后把解析后的请求交由主线程进行实际的内存读写。提升网络请求处理的并行度，进而提升整体性能。</p>
<p>但是，Redis 的多 IO 线程只是用来处理网络请求的，对于读写命令，Redis 仍然使用单线程来处理。因此不会数据上的并发安全问题</p>
</li>
<li>
<p>为什么快？</p>
<ul>
<li>
<p>完全基于内存</p>
</li>
<li>
<p>数据结构简单，对数据操作也简单，如哈希表、跳表都有很高的性能</p>
</li>
<li>
<p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU</p>
</li>
<li>
<p>使用多路I/O复用模型，非阻塞，即reactor模型</p>
<p>IO多路复用，即单个线程处理多个socket请求，非阻塞只socket设置为非阻塞，发送请求后不会继续等待，而是可以继续再发信息或者收信息。<strong>epoll监听哪些socket上有事件到达，当 accept、read、write 和 close 文件事件产生时，就会回调 FD 绑定的事件处理器</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="redis在主从复制的和故障转移的过程中会导致数据丢失吗"><strong>Redis在主从复制的和故障转移的过程中会导致数据丢失吗</strong></h3>
<ul>
<li>
<p>异步数据丢失：</p>
<p>显然是会的，从上面的「主从复制」流程来看，这个过程是异步的（在复制的过程中：主服务器会一直接收请求，然后把修改命令发给从服务器），</p>
<p>假如主服务器的命令还没发完给从服务器，自己就挂掉了。这时候想要让从服务器顶上主服务器，但从服务器的数据是不全的</p>
</li>
<li>
<p>脑裂</p>
<p>还有另一种情况就是：有可能哨兵认为主服务器挂了，但真实是主服务器并没有挂( 网络抖动)，而哨兵已经选举了一台从服务器当做是主服务器了，此时「客户端」还没反应过来，还继续写向旧主服务器写数据</p>
</li>
</ul>
<h3 id="redis的高可用和持久化">redis的高可用和持久化</h3>
<p>高可用：</p>
<ul>
<li>
<p>哨兵：</p>
<p>哨兵」干的事情主要就是：监控（监控主服务器的状态）、选主（主服务器挂了，在从服务器选出一个作为主服务器）、通知（故障发送消息给管理员）和配置（作为配置中心，提供当前主服务器的信息），可以把「哨兵」当做是运行在「特殊」模式下的Redis服务器，为了「高可用」，哨兵也是集群架构的。</p>
<ul>
<li>哨兵可以理解为特殊的Redis服务器，一般会组成哨兵集群</li>
<li>哨兵主要工作是监控、告警、配置以及选主</li>
<li>当主服务器发生故障时，会「选出」一台从服务器来顶上「客观下线」的服务器，由「领头哨兵」进行切换</li>
</ul>
</li>
<li>
<p>主从备份：和mysql类似，主节点只处理写的请求，而从节点处理读的请求，他们之间是通过psync同步</p>
<blockquote>
<p>你启动一台slave 的时候，他会发送一个<strong>psync</strong>命令给master ，如果是这个slave第一次连接到master，他会触发一个全量复制。master就会启动一个线程，生成<strong>RDB</strong>快照，还会把新的写请求都缓存在内存中，<strong>RDB</strong>文件生成后，master会将这个<strong>RDB</strong>发送给slave的，slave拿到之后做的第一件事情就是写进本地的磁盘，然后加载进内存，然后master会把内存里面缓存的那些新命名都发给slave。</p>
</blockquote>
<ul>
<li>PSYNC命令两种模式：完全重同步、部分重同步</li>
<li>完全重同步：主从服务器建立连接、主服务器生成RDB文件发给从服务器、主服务器不阻塞（相关修改命令记录至buffer）、将修改命令发给从服务器</li>
<li>部分重同步：从服务器断线重连，发送RunId和offset给主服务器，主服务器判断offset和runId，将还未同步给从服务器的offset相关指令进行发送</li>
</ul>
</li>
<li>
<p>redis cluster：</p>
<p>分片集群：用于解决主从复制、脑裂的问题。类似es</p>
</li>
</ul>
<p>redis的持久化：</p>
<p>​	Redis提供了2中持久化方式AOF，RDB</p>
<blockquote>
<p>根据我们自己配置的时间或者手动去执行BGSAVE或SAVE命令，Redis就会去生成RDB文件，这个RDB文件实际上就是一个经过压缩的二进制文件，Redis可以通过这个文件在启动的时候来还原我们的数据</p>
<p>而AOF则是把Redis服务器接收到的所有写命令都记录到日志中</p>
<p>Redis重跑一遍这个记录下的日志文件，就相当于还原了数据</p>
</blockquote>
<ul>
<li>
<p>RDB：<strong>RDB</strong> 持久化机制，是对 <strong>Redis</strong> 中的数据执行<strong>周期性</strong>的持久化。</p>
<blockquote>
<h3 id="优点">优点：</h3>
<p>他会生成多个数据文件，每个数据文件分别都代表了某一时刻<strong>Redis</strong>里面的数据，这种方式，有没有觉得很适合做<strong>冷备</strong>，完整的数据运维设置定时任务，定时同步到远端的服务器，比如阿里的云服务，这样一旦线上挂了，你想恢复多少分钟之前的数据，就去远端拷贝一份之前的数据就好了。</p>
<p><strong>RDB</strong>对<strong>Redis</strong>的性能影响非常小，是因为在同步数据的时候他只是<strong>fork</strong>了一个子进程去做持久化的，而且他在数据恢复的时候速度比<strong>AOF</strong>来的快。</p>
<h3 id="缺点">缺点：</h3>
<p><strong>RDB</strong>都是快照文件，都是默认五分钟甚至更久的时间才会生成一次，这意味着你这次同步到下次同步这中间五分钟的数据都很可能全部丢失掉。<strong>AOF</strong>则最多丢一秒的数据，<strong>数据完整性</strong>上高下立判。</p>
<p>还有就是<strong>RDB</strong>在生成数据快照的时候，如果文件很大，客户端可能会暂停几毫秒甚至几秒，你公司在做秒杀的时候他刚好在这个时候<strong>fork</strong>了一个子进程去生成一个大快照，哦豁，出大问题。</p>
</blockquote>
</li>
<li>
<p>AOF：<strong>AOF</strong> 机制对每条写入命令作为日志，以 <strong>append-only</strong> 的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql中的<strong>binlog</strong>。</p>
<blockquote>
<h3 id="优点-1">优点：</h3>
<p>上面提到了，<strong>RDB</strong>五分钟一次生成快照，但是<strong>AOF</strong>是一秒一次去通过一个后台的线程<code>fsync</code>操作，那最多丢这一秒的数据。</p>
<p><strong>AOF</strong>在对日志文件进行操作的时候是以<code>append-only</code>的方式去写的，他只是追加的方式写数据，自然就少了很多磁盘寻址的开销了，写入性能惊人，文件也不容易破损。</p>
<h3 id="缺点-1">缺点：</h3>
<p>一样的数据，<strong>AOF</strong>文件比<strong>RDB</strong>还要大。</p>
<p><strong>AOF</strong>开启后，<strong>Redis</strong>支持写的<strong>QPS</strong>会比<strong>RDB</strong>支持写的要低，他不是每秒都要去异步刷新一次日志嘛<strong>fsync</strong>，当然即使这样性能还是很高.</p>
</blockquote>
</li>
<li>
<p>实际上：</p>
<p>使用RDB先恢复数据，速度快，然后通过AOF进行补全</p>
</li>
</ul>
<h3 id="redis布隆过滤器">redis布隆过滤器</h3>
<p>布隆过滤器可以使用高效的数据结构，存放大量的数据。布隆过滤器说存在，则不一定存在，但是布隆过滤器说不存在，则一定不存在。常用于缓存穿透的问题。</p>
<p>特点</p>
<ul>
<li>空间效率高</li>
<li>多次hash，时间效率高</li>
<li>存在误判，所以不好做删除</li>
</ul>
<p>使用场景</p>
<ul>
<li>黑名单</li>
<li>URL去重</li>
<li>ID校验</li>
<li>防止穿透</li>
</ul>
<p>原理：</p>
<ul>
<li>布隆过滤器本质上是一个位数组，每个元素只占1个bit，只会有0和1，通过n次hash，减少hash碰撞。当一个key过来的时候，进行n次hash，得出n次结果，将n次结果的位值在数组中查找，如果发现有一个值为0，则key一定不在过滤器中。如果都为1可能在过滤器中，因为hash值会碰撞。hash的次数和数组的大小决定了布隆过滤器的准确度。</li>
</ul>
<p>使用：</p>
<ul>
<li>google在guava中封装好的BloomFilter</li>
<li>redis 4.0后可以加入module BloomFilter</li>
</ul>
<h3 id="redis分布式锁">redis分布式锁</h3>
<p>SETNX + EXPIRE</p>
<h3 id="redis为什么选用跳表">redis为什么选用跳表</h3>
<ul>
<li>
<p>跳表是一种进阶型的链表，具有二分查找的功能<a href="https://juejin.cn/post/6844903847521976327">参考</a></p>
<blockquote>
<p>Redis只在两个地方用到了跳跃表，一个是实现有序集合键(zset)，另一个是在集群节点中用作内部数据结构，除此之外，跳表在Redis里面没有其他用途。</p>
<p>但是为什么用跳表而不用红黑树呢？猜想如下：
1）在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。
2）平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。
3）从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。
4）查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。
5）从算法实现难度上来比较，skiplist比平衡树要简单得多。</p>
</blockquote>
</li>
</ul>
<h3 id="redis防击穿雪崩穿透">redis防击穿、雪崩、穿透</h3>
<ul>
<li>
<p>击穿</p>
<p>和雪崩有一点像。击穿是大量请求，打一个key，这个key突然失效，导致打挂了库。而雪崩是大量key一起失效，设计永不过期</p>
</li>
<li>
<p>穿透</p>
<p>访问一个不可能存在的key，一直打到数据库，导致数据库挂了</p>
<p>解决方案：</p>
<ul>
<li>代码中针对查key的逻辑需要注意，在逻辑上就处理掉这些不会出现的key</li>
<li>对于不存在的key，依然存缓存，value设为null，或者提示语句。例如“稍后再试，请求不正确”。并且给他一个过期时间</li>
<li>使用布隆过滤器</li>
<li>通过nginx做ip的限制，加黑名单。</li>
</ul>
</li>
<li>
<p>雪崩</p>
<p>大批量的key在同时一时刻失效，导致大批量的请求全部打到数据上。数据库承受不住挂了。</p>
<p>解决方案：</p>
<ul>
<li>设置过期时间的时候加上随机数，保证同一时间不会有大量的key失效</li>
<li>设置这种热点数据用不过期。需要更新的时候，顺手更新一下缓存就可以了</li>
</ul>
</li>
</ul>
<h3 id="redis是先删缓存还是先写库怎么解决缓存一致性">redis是先删缓存还是先写库，怎么解决缓存一致性</h3>
<ul>
<li>
<p>先删缓存，再更新数据库</p>
<p>缓存删除完成后，数据库更新操作还没好，此时请求过来，读缓存，读不到，读数据库，得到的是旧数据</p>
<p>解决方案：延时双删</p>
<blockquote>
<p>流程如下：</p>
<ol>
<li>线程1删除缓存，然后去更新数据库</li>
<li>线程2来读缓存，发现缓存已经被删除，所以直接从数据库中读取，这时候由于线程1还没有更新完成，所以读到的是旧值，然后把旧值写入缓存</li>
<li>线程1，根据估算的时间，sleep，由于sleep的时间大于线程2读数据+写缓存的时间，所以缓存被再次删除</li>
<li>如果还有其他线程来读取缓存的话，就会再次从数据库中读取到最新值</li>
</ol>
</blockquote>
</li>
<li>
<p>先更新库，再删除缓存</p>
<p>更新数据库成功，如果删除缓存失败或者还没有来得及删除，那么，其他线程从缓存中读取到的就是旧值，还是会发生不一致。</p>
<p>解决方案：先更新数据库，成功后往消息队列发消息，消费到消息后再删除缓存，<strong>借助消息队列的重试机制来实现</strong>，达到最终一致性的效果。进阶一点，使用数据的binlog通知到消息队列，然后更新缓存。无代码入侵</p>
<blockquote>
<p>缺陷：</p>
<ol>
<li>引入消息中间件之后，问题更复杂了，怎么保证消息不丢失更麻烦</li>
<li>就算更新数据库和删除缓存都没有发生问题，消息的延迟也会带来短暂的不一致性，不过这个延迟相对来说还是可以接受的</li>
</ol>
</blockquote>
</li>
<li>
<p>设置过期时间</p>
<blockquote>
<p>每次放入缓存的时候，设置一个过期时间，比如5分钟，以后的操作只修改数据库，不操作缓存，等待缓存超时后从数据库重新读取。</p>
<p>如果对于一致性要求不是很高的情况，可以采用这种方案。</p>
<p>这个方案还会有另外一个问题，就是如果数据更新的特别频繁，不一致性的问题就很大了。</p>
<p>在实际生产中，我们有一些活动的缓存数据是使用这种方式处理的。</p>
<p>因为活动并不频繁发生改变，而且对于活动来说，短暂的不一致性并不会有什么大的问题。</p>
</blockquote>
</li>
<li>
<p>总结</p>
<p>首先，我们要明确一点，缓存不是更新，而应该是删除。</p>
<p>删除缓存有两种方式：</p>
<blockquote>
<p>举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。
实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用到缓存才去算缓存。</p>
</blockquote>
<ol>
<li>先删除缓存，再更新数据库。解决方案是使用延迟双删。</li>
<li>先更新数据库，再删除缓存。解决方案是消息队列或者其他binlog同步，引入消息队列会带来更多的问题，并不推荐直接使用。</li>
</ol>
<p>针对缓存一致性要求不是很高的场景，那么只通过设置超时时间就可以了。</p>
<p>其实，如果不是很高的并发，无论你选择先删缓存还是后删缓存的方式，都几乎很少能产生这种问题，但是在高并发下，你应该知道怎么解决问题。</p>
</li>
</ul>
<h3 id="redis的淘汰策略">redis的淘汰策略</h3>
<p>官网上给到的内存淘汰机制是以下几个：</p>
<ul>
<li>
<p><strong>noeviction</strong>:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）</p>
</li>
<li>
<p><strong>allkeys-lru</strong>: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</p>
</li>
<li>
<p><strong>volatile-lru</strong>: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。</p>
</li>
<li>
<p><strong>allkeys-random</strong>: 回收随机的键使得新添加的数据有空间存放。</p>
</li>
<li>
<p><strong>volatile-random</strong>: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</p>
</li>
<li>
<p><strong>volatile-ttl</strong>: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</p>
<p>如果没有键满足回收的前提条件的话，策略<strong>volatile-lru</strong>, <strong>volatile-random</strong>以及<strong>volatile-ttl</strong>就和noeviction 差不多了。</p>
</li>
</ul>
<h1 id="问题排查">问题排查</h1>
<h3 id="arthas">arthas</h3>
<h3 id="jdk自带命令">jdk自带命令</h3>
<p>jps</p>
<p>jcmd</p>
<p>jstate</p>
<p><a href="https://docs.oracle.com/en/java/javase/11/tools/tools-and-command-reference.html">https://docs.oracle.com/en/java/javase/11/tools/tools-and-command-reference.html</a></p>
<h1 id="kafka">Kafka</h1>
<h3 id="消息队列的通信模式">消息队列的通信模式</h3>
<ul>
<li>
<p>点对点模式</p>
<p>点对点模式通常是基于拉取或者轮询的消息传送模型，生产者将消息发送到队列中，消费者主动去拿消息。点对点模型的的优点是消费者拉取消息的频率可以由自己控制。但是消息队列是否有消息需要消费，在消费者端无法感知，所以在消费者端需要额外的线程去监控。</p>
</li>
<li>
<p>发布订阅模式</p>
<p>发布订阅模式是一个基于消息送的消息传送模型，改模型可以有多种不同的订阅者。生产者将消息放入消息队列后，队列会将消息推送给订阅过该类消息的消费者（类似微信公众号）。由于是消费者被动接收推送，所以无需感知消息队列是否有待消费的消息！但是consumer1、consumer2、consumer3由于机器性能不一样，所以处理消息的能力也会不一样，但消息队列却无法感知消费者消费的速度！所以推送的速度成了发布订阅模模式的一个问题！假设三个消费者处理速度分别是8M/s、5M/s、2M/s，如果队列推送的速度为5M/s，则consumer3无法承受！如果队列推送的速度为2M/s，则consumer1、consumer2会出现资源的极大浪费！</p>
</li>
</ul>
<h3 id="kafka架构">Kafka架构</h3>
<!-- raw HTML omitted -->
<ul>
<li>
<p><strong>Producer</strong>：Producer即生产者，消息的产生者，是消息的入口。</p>
<p><strong>kafka cluster</strong>：</p>
<p><strong>Broker</strong>：Broker是kafka实例，每个服务器上有一个或多个kafka的实例，我们姑且认为每个broker对应一台服务器。每个kafka集群内的broker都有一个<strong>不重复</strong>的编号，如图中的broker-0、broker-1等……</p>
<p><strong>Topic</strong>：消息的主题，可以理解为消息的分类，kafka的数据就保存在topic。在每个broker上都可以创建多个topic。</p>
<p><strong>Partition</strong>：Topic的分区，每个topic可以有多个分区，分区的作用是做负载，提高kafka的吞吐量。同一个topic在不同的分区的数据是不重复的，partition的表现形式就是一个一个的文件夹！</p>
<p><strong>Replication</strong>:每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为Leader。在kafka中默认副本的最大数量是10个，且副本的数量不能大于Broker的数量，follower和leader绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。</p>
<p><strong>Message</strong>：每一条发送的消息主体。</p>
<p><strong>Consumer</strong>：消费者，即消息的消费方，是消息的出口。</p>
<p><strong>Consumer Group</strong>：我们可以将多个消费组组成一个消费者组，在kafka的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。同一个消费者组的消费者可以消费同一个topic的不同分区的数据，这也是为了提高kafka的吞吐量！</p>
<p><strong>Zookeeper</strong>：kafka集群依赖zookeeper来保存集群的的元信息，来保证系统的可用性。</p>
</li>
</ul>
<h3 id="为什么要用消息队列">为什么要用消息队列</h3>
<p>解耦、异步、削丰</p>
<h3 id="kafka的推还是拉">Kafka的推还是拉</h3>
<p>拉</p>
<h3 id="kafka如何做到消息不丢失的">Kafka如何做到消息不丢失的</h3>
<p>消息丢失有如下场景</p>
<ul>
<li>
<p>producer发送给broker</p>
<p>会出现，producer发给broker没收到，broker收到了还没同步给其他broker就挂了，broker持久化的时候，走磁盘缓存挂了</p>
<p>不想丢数据，那就使用带有callback的api，设置 acks、retries、factor等等些参数来保证Producer发送的消息不会丢就好啦。</p>
</li>
<li>
<p>客户端消费broker丢了</p>
<p>首先，要想client端消费数据不能丢，肯定是不能使用autoCommit的，所以必须是手动提交的</p>
</li>
<li>
<p>生产者保证消息发送到集群</p>
<blockquote>
<p>使用带有回调方法（callback）的api，并设置好参数acks和retries和retry.backoff.ms这几个参数
acks参数表示如何判断系统认为消息发送成功。0，只要发过去就行了，1broker的leader收到就行了，-1，副本要同步完毕才算成功</p>
<p>retries参数表示生产者生产消息的重试次数。
retry.backoff.ms参数表示消息生产超时失败后重试的间隔时间。
通过回调函数，我们可以知道消息是否发送成功。如果发送失败，我们需要进行异常处理。
比如把失败消息存入本地磁盘或者远程数据库，等服务正常了再发送。这样才能保证消息不丢失。</p>
</blockquote>
</li>
</ul>
<h3 id="kafka为什么可以有这么大的吞吐量">Kafka为什么可以有这么大的吞吐量</h3>
<p>消息队列「最核心」的功能就是把生产的数据存储起来，然后给各个业务把数据再读取出来。</p>
<p>Kafka在「存储」和「读取」这个过程中又做了很多的优化</p>
<ul>
<li>我们往一个Topic发送消息或者读取消息时，实际内部是多个Partition在处理【并行】</li>
<li>在存储消息时，Kafka内部是顺序写磁盘的，并且利用了操作系统的缓冲区来提高性能【append+cache】</li>
<li>在读写数据中也减少CPU拷贝文件的次数【零拷贝】</li>
</ul>
<h3 id="kafka怎么保证顺序消费">Kafka怎么保证顺序消费</h3>
<p>kafka 的分布式单位是 partition，同一个 partition 中的数据可以保证 FIFO。不同的 partition 之间不能保证顺序。每个partition 只能够有一个消费者消费。因为在发送数据的时候，绝大多数用户都可以通过 message key 来定义，同一个 key 的 message 都会发送到同一个 partition 上面，所以一般不会有问题。</p>
<h3 id="kafka怎么保证不重复消费的">kafka怎么保证不重复消费的</h3>
<p>消费方进行做去重表</p>
<h1 id="mysql">MySql</h1>
<p>推荐文章</p>
<ul>
<li><a href="https://www.cnblogs.com/lianzhilei/p/11250589.html">https://www.cnblogs.com/lianzhilei/p/11250589.html</a></li>
<li><a href="https://mp.weixin.qq.com/s/BFuA-59Fpue2r6dt8YBbrQ">https://mp.weixin.qq.com/s/BFuA-59Fpue2r6dt8YBbrQ</a></li>
</ul>
<h3 id="一条语句的执行过程">一条语句的执行过程</h3>
<!-- raw HTML omitted -->
<ul>
<li>客户端请求</li>
<li>连接器（验证用户身份，给予权限）</li>
<li>查询缓存（存在缓存则直接返回，不存在则执行后续操作）</li>
<li>分析器（对SQL进行词法分析和语法分析操作）</li>
<li>优化器（主要对执行的sql优化选择最优的执行方案方法）</li>
<li>执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）</li>
<li>去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</li>
</ul>
<h3 id="常见的存储引擎">常见的存储引擎</h3>
<p>使用哪一种引擎可以灵活选择，<strong>一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求</strong>，使用合适的存储引擎，将会提高整个数据库的性能 。</p>
<p>Mysql的Data目录下都会存放每个表的元数据信息，包括表的定义与数据库引擎没有关系，文件为**.frm**结尾，例如user.frm存放的是user表的元数据信息</p>
<ul>
<li>InnoDB
<ul>
<li><code>.frm</code>文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等</li>
<li><code>.MYD</code> (<code>MYData</code>) 文件：MyISAM 存储引擎专用，用于存储MyISAM 表的数据</li>
<li><code>.MYI</code> (<code>MYIndex</code>)文件：MyISAM 存储引擎专用，用于存储MyISAM 表的索引相关信息</li>
</ul>
</li>
<li>MyISAM
<ul>
<li><code>.frm</code> 文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等</li>
<li><code>.ibd</code> 文件或 <code>.ibdata</code> 文件：这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用<strong>共享表空间</strong>存放存储数据，还是用<strong>独享表空间</strong>存放存储数据。</li>
</ul>
</li>
<li>对比
<ol>
<li>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
<li>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；</li>
<li>InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>
<li>InnoDB 不保存表的具体行数，执行<code>select count(*) from table</code> 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">对比项</th>
<th style="text-align:left">MyISAM</th>
<th style="text-align:left">InnoDB</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">主外键</td>
<td style="text-align:left">不支持</td>
<td style="text-align:left">支持</td>
</tr>
<tr>
<td style="text-align:left">事务</td>
<td style="text-align:left">不支持</td>
<td style="text-align:left">支持</td>
</tr>
<tr>
<td style="text-align:left">行表锁</td>
<td style="text-align:left">表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td>
<td style="text-align:left">行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作</td>
</tr>
<tr>
<td style="text-align:left">缓存</td>
<td style="text-align:left">只缓存索引，不缓存真实数据</td>
<td style="text-align:left">不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td>
</tr>
<tr>
<td style="text-align:left">表空间</td>
<td style="text-align:left">小</td>
<td style="text-align:left">大</td>
</tr>
<tr>
<td style="text-align:left">关注点</td>
<td style="text-align:left">性能</td>
<td style="text-align:left">事务</td>
</tr>
<tr>
<td style="text-align:left">默认安装</td>
<td style="text-align:left">是</td>
<td style="text-align:left">是</td>
</tr>
</tbody>
</table>
<h3 id="一张表里面有id自增主键当insert了17条记录之后删除了第151617条记录再把mysql重启再insert一条记录这条记录的id是18还是15-">一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</h3>
<p>如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID 记录到数据文件中，重启MySQL自增主键的最大ID也不会丢失；</p>
<p>如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。</p>
<h3 id="自增主键用完了怎么办">自增主键用完了怎么办</h3>
<p>会报重复主键错误，2亿了，早就开始分库分表了</p>
<h3 id="mysql的索引数据结构为什么用b树讲一讲mysql索引的数据结构是什么样的">mysql的索引数据结构为什么用B+树，讲一讲mysql索引的数据结构是什么样的</h3>
<!-- raw HTML omitted -->
<ul>
<li>
<p>索引是帮助mysql更快获得数据的一种数据结构</p>
</li>
<li>
<p>索引分类</p>
<p><strong>数据结构角度</strong></p>
<ul>
<li>B+树索引</li>
<li>Hash索引</li>
<li>Full-Text全文索引</li>
</ul>
<p><strong>从物理存储角度</strong></p>
<ul>
<li>
<p><code>根据数据与索引的存储关联性，可以分为聚簇索引和非聚簇索引（也叫聚集索引和非聚集索引）。聚簇索引也叫簇类索引，是一种对磁盘上实际数据重新组织以按指定的一个或多个列的值排序。整个简洁的说法，这俩的区别就是索引的存储顺序和数据的存储顺序是否是关系的，有关就是聚簇索引，无关就是非聚簇索引。具体实现方式根据索引的数据结构不同会有所不同。下面以B+树实现的索引为例，举例来说明聚簇索引和非聚簇索引。</code></p>
</li>
<li>
<p>聚集索引（clustered index）,InnoDb 的主键索引就是聚集索引</p>
</li>
<li>
<p>非聚集索引（non-clustered index），也叫辅助索引（secondary index），也叫二级索引</p>
<p>如果不是主键索引，则就可以称之为非主键索引，又可以称之为辅助索引或者二级索引。主键索引的叶子节点存储了完整的数据行，而非主键索引的叶子节点存储的则是主键索引值，通过非主键索引查询数据时，会先查找到主键索引，然后再到主键索引上去查找对应的数据。</p>
<blockquote>
<p>在这里假设我们有张表user，具有三列：ID，age，name，create_time，id是主键，（age，create_time,，name）建立辅助索引。执行如下sql语句：</p>
<p>select name from user where age&gt;2 order by create_time desc。</p>
<p>正常的话，查询分两步：</p>
<p>1.按照辅助索引，查找到记录的主键，</p>
<p>2.按照主键主键索引里查找记录，返回name。</p>
<p>但实际上，我们可以看到，辅助索引节点是按照age，create_time，name建立的，索引信息里完全包含我们所要的信息，如果能从辅助索引里返回name信息，则第二步是完全没有必要的，可以极大提升查询速度。</p>
<p>按照这种思想Innodb里针对使用辅助索引的查询场景做了优化，叫覆盖索引</p>
</blockquote>
<p>聚集索引和非聚集索引都是B+树结构</p>
</li>
</ul>
<p><strong>从逻辑角度</strong></p>
<ul>
<li>
<p>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</p>
<p>MySQL中是根据主键来组织数据的，所以每张表都必须有主键索引，主键索引只能有一个，不能为null同时必须保证唯一性。建表时如果没有指定主键索引，则会自动生成一个隐藏的字段作为主键索引。</p>
</li>
<li>
<p>普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引</p>
</li>
<li>
<p>多列索引（复合索引、联合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</p>
</li>
<li>
<p>唯一索引或者非唯一索引</p>
</li>
<li>
<p>空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建</p>
</li>
</ul>
</li>
<li>
<p>B-树和B+树</p>
<ul>
<li>
<p>B-树</p>
<!-- raw HTML omitted -->
<p>B-树就是平时说的B树，和二叉树的区别在于，可以存在多个子树。从而达到深度低的效果。通常用于操作系统的文件查询，因为一次深度就是一次磁盘的IO。B-树的节点，除了子节点的指针信息，和索引信息(主键)，还存放了数据</p>
</li>
<li>
<p>B+树</p>
<!-- raw HTML omitted -->
<p>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 存储引擎就是用 B+Tree 实现其索引结构。</p>
<p>从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，<strong>所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上</strong>，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p>
</li>
</ul>
</li>
</ul>
<p><strong>正因为InnoDB的数据和聚集索引是存放在一起的，所以默认建表的时候推荐创建主键索引，如果没有建立的话，mysql会自动创建一个隐藏的列作为主键并且这个字段长度为6个字节，类型为整型。</strong></p>
<h3 id="最左匹配原则是什么">最左匹配原则是什么</h3>
<p>B+Tree性质</p>
<ol>
<li>通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</li>
<li>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即<strong>索引的最左匹配特性</strong>。</li>
</ol>
<h3 id="explain">Explain</h3>
<p>Explain + SQL语句即可,如下:</p>
<pre tabindex="0"><code>explain select * from tbl_dept;
</code></pre><ul>
<li>1执行结果如下:</li>
</ul>
<p>*<a href="https://img-blog.csdn.net/20180521155012377?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poMTU3MzI2MjE2Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><img src="https://img-blog.csdn.net/20180521155012377?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poMTU3MzI2MjE2Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></a>*</p>
<p><strong>EXPLAIN结果参数含义</strong></p>
<p>1.id: id代表执行select子句或操作表的顺序,例如,上述的执行结果代表只有一次执行而且执行顺序是第一(因为只有一个id为1的执行结果),id分别有三种不同的执行结果,分别如下:</p>
<ul>
<li>id相同,执行顺序由上至下</li>
</ul>
<p><a href="https://img2018.cnblogs.com/blog/885859/201904/885859-20190419152720756-229903142.png"><img src="https://img2018.cnblogs.com/blog/885859/201904/885859-20190419152720756-229903142.png" alt="img"></a></p>
<ul>
<li>id不同,如果是子查询,id的序号会递增,id值越大,优先级越高,越先被执行</li>
</ul>
<p><a href="https://img2018.cnblogs.com/blog/885859/201904/885859-20190419152812436-124187623.png"><img src="https://img2018.cnblogs.com/blog/885859/201904/885859-20190419152812436-124187623.png" alt="img"></a></p>
<ul>
<li>id相同和不同,同时存在,遵从优先级高的优先执行,优先级相同的按照由上至下的顺序执行</li>
</ul>
<p><a href="https://img2018.cnblogs.com/blog/885859/201904/885859-20190419152835637-1233280197.png"><img src="https://img2018.cnblogs.com/blog/885859/201904/885859-20190419152835637-1233280197.png" alt="img"></a></p>
<p><strong>2.select_type</strong>
　　查询的类型,主要用于区别普通查询,联合查询,子查询等复杂查询</p>
<ul>
<li>simple: 简单的select查询,查询中不包含子查询或union查询</li>
<li>primary: 查询中若包含任何复杂的子部分,最外层查询则被标记为primary</li>
<li>subquery 在select 或where 列表中包含了子查询</li>
<li>derived 在from列表中包含的子查询被标记为derived,mysql会递归这些子查询,把结果放在临时表里</li>
<li>union 做第二个select出现在union之后,则被标记为union,若union包含在from子句的子查询中,外层select将被标记为derived</li>
<li>union result 从union表获取结果的select</li>
</ul>
<p><strong>3.table</strong>
　　显示一行的数据时关于哪张表的
<strong>4.type</strong>
　　查询类型从最好到最差依次是:system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;All,一般情况下,得至少保证达到range级别,最好能达到ref</p>
<ul>
<li><strong>system</strong>:表只有一行记录,这是const类型的特例,平时不会出现</li>
<li><strong>const</strong>:表示通过索引一次就找到了,const即常量,它用于比较primary key或unique索引,因为只匹配一行数据,所以效率很快,如将主键置于where条件中,mysql就能将该查询转换为一个常量</li>
</ul>
<p><a href="https://img2018.cnblogs.com/blog/885859/201904/885859-20190419153049676-1370075656.png"><img src="https://img2018.cnblogs.com/blog/885859/201904/885859-20190419153049676-1370075656.png" alt="img"></a></p>
<ul>
<li><strong>eq_ref</strong>:唯一性索引扫描,对于每个索引键,表中只有一条记录与之匹配,常见于主键或唯一索引扫描</li>
<li><strong>ref</strong>:非唯一性索引扫描,返回匹配某个单独值的行,它可能会找到多个符合条件的行,所以他应该属于查找和扫描的混合体</li>
<li><strong>range</strong>:只检索给定范围的行,使用一个索引来选择行,如where语句中出现了between,&lt;,&gt;,in等查询,这种范围扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。</li>
<li><strong>index</strong>:index类型只遍历索引树,这通常比All快,因为索引文件通常比数据文件小,index是从索引中读取,all从硬盘中读取</li>
<li><strong>all</strong>:全表扫描,是最差的一种查询类型</li>
</ul>
<p><strong>5.possible_keys</strong>
　　显示可能应用在这张表中的索引,一个或多个,查询到的索引不一定是真正被用到的</p>
<p><strong>6.key</strong>
　　实际使用的索引,如果为null,则没有使用索引,因此会出现possible_keys列有可能被用到的索引,但是key列为null,表示实际没用索引。</p>
<p><strong>7.key_len</strong>
　　表示索引中使用的字节数,而通过该列计算查询中使用的 索引长度,在不损失精确性的情况下,长度越短越好,key_len显示的值为索引字段的最大可能长度,并非实际使用长度,即,key_len是根据表定义计算而得么不是通过表内检索出的</p>
<p><strong>8.ref</strong>
　　显示索引的哪一列被使用了,如果可能的话是一个常数,哪些列或常量被用于查找索引列上的值</p>
<p><strong>9.rows</strong>
　　根据表统计信息及索引选用情况,大只估算出找到所需的记录所需要读取的行数</p>
<p><strong>10.Extra</strong></p>
<ul>
<li><strong>Using filesort</strong>:说明mysql会对数据使用一个外部的索引排序,而不是按照表内的索引顺序进行读取,mysql中无法利用索引完成的排序操作称为&quot;文件排序&quot;</li>
<li><strong>Using temporary</strong> :使用了临时表保存中间结果,mysql在对查询结果排序时使用临时表,常见于order by和分组查询group by</li>
<li><strong>Using index</strong>:表示相应的select操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错。如果同时出现using where，表明索引被用来执行索引键值的查找；如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。 其中的覆盖索引含义是所查询的列是和建立的索引字段和个数是一一对应的</li>
<li><strong>Using where</strong>:表明使用了where过滤</li>
<li><strong>Using join buffer</strong>:表明使用了连接缓存,如在查询的时候会有多次join,则可能会产生临时表</li>
<li><strong>impossible where</strong>:表示where子句的值总是false,不能用来获取任何元祖。如下例：</li>
</ul>
<pre tabindex="0"><code>select * from t1 where id='1' and id='2';
</code></pre><ul>
<li>select tables optimized away</li>
</ul>
<p>在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</p>
<ul>
<li>distinct：优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作，即一旦MySQL找到了与行相联合匹配的行，就不再搜索了。</li>
</ul>
<p><strong>重点：</strong></p>
<p>　　<strong>type</strong>：访问类型，查看SQL到底是以何种类型访问数据的。</p>
<p>　　<strong>key</strong>：使用的索引，MySQL用了哪个索引，有时候MySQL用的索引不是最好的，需要force index()。</p>
<p>　　<strong>rows</strong>：最大扫描的列数。</p>
<p>　　<strong>extra</strong>：重要的额外信息，特别注意损耗性能的两个情况，using filesort和using temporary。</p>
<h3 id="说出你如何调优的">说出你如何调优的</h3>
<p>直接explain</p>
<h3 id="常见的优化手段">常见的优化手段</h3>
<ul>
<li>使用覆盖索引解决回表，提高查询效率</li>
<li>使用explain检查sql语句执行的情况</li>
<li>where语句时，字段类型一定要一直，否则索引失效</li>
<li>使用函数索引不走</li>
<li>OR导致索引是在特定情况下的，并不是所有的OR都是使索引失效，如果OR连接的是同一个字段，那么索引不会失效，反之索引失效。</li>
<li>模糊匹配，like 中%不能写在前面</li>
<li>IS NULL走索引，IS NOT NULL走索引</li>
<li>开启慢日志，查看哪些sql执行太慢</li>
</ul>
<h3 id="mvvc">MVVC</h3>
<p>MySQL的大多数事务型存储引擎实现都不是简单的行级锁。基于提升并发性考虑，一般都同时实现了多版本并发控制（MVCC），包括Oracle、PostgreSQL。只是实现机制各不相同。</p>
<p>可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只是锁定必要的行。</p>
<p>MVCC 的实现是通过保存数据在某个时间点的快照来实现的。也就是说不管需要执行多长时间，每个事物看到的数据都是一致的。</p>
<p>典型的MVCC实现方式，分为<strong>乐观（optimistic）并发控制和悲观（pressimistic）并发控制</strong>。下边通过 InnoDB的简化版行为来说明 MVCC 是如何工作的。</p>
<p>InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p><strong>REPEATABLE READ（可重读）隔离级别下MVCC如何工作：</strong></p>
<ul>
<li>
<p>SELECT</p>
<p>InnoDB会根据以下两个条件检查每行记录：</p>
<p>只有符合上述两个条件的才会被查询出来</p>
</li>
<li>
<ul>
<li>InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在开始事务之前已经存在要么是事务自身插入或者修改过的</li>
<li>行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除</li>
</ul>
</li>
<li>
<p>INSERT：InnoDB为新插入的每一行保存当前系统版本号作为行版本号</p>
</li>
<li>
<p>DELETE：InnoDB为删除的每一行保存当前系统版本号作为行删除标识</p>
</li>
<li>
<p>UPDATE：InnoDB为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识</p>
</li>
</ul>
<p>保存这两个额外系统版本号，使大多数操作都不用加锁。使数据操作简单，性能很好，并且也能保证只会读取到符合要求的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。</p>
<p>MVCC 只在 COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作。</p>
<h3 id="事务特性隔离级别怎么解决幻读">事务特性，隔离级别，怎么解决幻读？</h3>
<p>特性：ACID</p>
<ul>
<li>
<p>原子性</p>
<p>整个事务要么全部执行，要么全部不执行，不会停在中间。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样</p>
</li>
<li>
<p>一致性</p>
<p>一致性，这个是大家误解最深的，很多博客都喜欢用银行转账的例子来讲一直性，所谓的一致性是基于原子性。</p>
<p>原子性只保证了一个事物内的所有操作同一性，大家同生死，不会出现你死了，我还活着。但是，原子性并没有保证大家同一时刻一起生，一起死。计算机指令是有先后顺序的，这样就决定了一个事物的提交，会经历一个时间过程，那么如果事物提交进行到了一半，我读取了数据库，会不会读到中间结果？</p>
<p>为了防止这样的情况，数据库事物的一致性就规定了事物提交前后，永远只可能存在事物提交前的状态和事物提交后的状态，从一个一致性的状态到另一个一致性状态，而不可能出现中间的过程态。也就是说事物的执行结果是量子化状态，而不是线性状态。</p>
<p>数据库提交事物会有一个过程，如果提交的时候，存在一个时间差，在提交的第一秒，一个删除过程还没完成到了第三秒才完成，会不会第一秒访问的人和第三秒访问的人得到不同的结果？出现不一致，状态的混沌？这就是一致性得保证的只会有前状态和后状态，绝不会出现中间态。</p>
</li>
<li>
<p>隔离性</p>
<p>一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰</p>
</li>
<li>
<p>持久性</p>
<p>在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚</p>
</li>
</ul>
<p>隔离级别：</p>
<ul>
<li>
<p>读未提交</p>
<p>脏读，事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p>
</li>
<li>
<p>读已提交</p>
<p>不可重复读，一个事务读2次，2次读的结果不一样，务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</p>
</li>
<li>
<p>可重复读</p>
<p>会造成幻读</p>
<blockquote>
<p>幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。   幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p>
</blockquote>
</li>
<li>
<p><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</p>
</li>
<li>
<p>如何解决幻读</p>
<p>mysql使用了间隙锁和记录锁来解决的，间隙锁就是对一段区域的记录都锁定</p>
<p>所以，<strong>Innodb 引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了 next-key 锁</strong>，就是记录锁和间隙锁的组合。</p>
<ul>
<li>记录锁，锁的是记录本身；</li>
<li>间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。</li>
</ul>
<p><a href="https://www.cnblogs.com/xiaolincoding/p/15308381.html">参考</a></p>
</li>
</ul>
<h3 id="三范式">三范式</h3>
<ul>
<li>第一范式：列不能再拆分了</li>
<li>第二范式：每一条数据必须能够被区分，主键存在，而且能保证唯一</li>
<li>第三范式：不要有冗余</li>
<li>反范式：冗余一些字段，避免查询</li>
</ul>
<h3 id="为什么要分库分表有什么方案">为什么要分库分表，有什么方案</h3>
<p>分库</p>
<ul>
<li>垂直分库，每个业务有自己单独的库</li>
</ul>
<p>分表</p>
<ul>
<li>垂直分表：单表分成多表，扩展开来</li>
<li>水平分表：数据分开来，例如用户表，通过id分为user-10000,user-20000，通过hash，让数据散列到不同的库不同表，不至于单库压力大</li>
</ul>
<p>缺点：</p>
<ul>
<li>分布式事务：Seata</li>
<li>连表查询：尽量避免，实在不行只能分开查询，再汇总</li>
<li>分页排序等：查完内存分页排序</li>
<li>分布式ID，唯一主键：雪花算法</li>
</ul>
<h3 id="什么是回表">什么是回表</h3>
<p>指非聚集索引在查找数据的时候，会先查找到聚集索引，再通过聚集索引找到最终的数据。这就是回表</p>
<h3 id="mysql覆盖索引">MySQL覆盖索引</h3>
<p><strong>覆盖索引</strong>（Covering Index）,或者叫索引覆盖， 也就是平时所说的不需要回表操作</p>
<ul>
<li>
<p>就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说<strong>查询列要被所建的索引覆盖</strong>。</p>
</li>
<li>
<p>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据，当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含（覆盖）满足查询结果的数据就叫做覆盖索引。</p>
</li>
<li>
<p><strong>判断标准</strong></p>
<p>使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为<strong>using index</strong>，MySQL查询优化器在执行查询前会决定是否有索引覆盖查询</p>
</li>
</ul>
<h3 id="为什么非主键索引结构叶子节点存储的是主键值">为什么非主键索引结构叶子节点存储的是主键值？</h3>
<blockquote>
<p>保证数据一致性和节省存储空间，可以这么理解：商城系统订单表会存储一个用户ID作为关联外键，而不推荐存储完整的用户信息，因为当我们用户表中的信息（真实名称、手机号、收货地址···）修改后，不需要再次维护订单表的用户数据，同时也节省了存储空间</p>
</blockquote>
<h3 id="为什么mysql索引要用b树不是b树">为什么Mysql索引要用B+树不是B树？</h3>
<blockquote>
<p>用B+树不用B树考虑的是IO对性能的影响，B树的每个节点都存储数据，而B+树只有叶子节点才存储数据，所以查找相同数据量的情况下，B树的高度更高，IO更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。其中在MySQL底层对B+树进行进一步优化：在叶子节点中是双向链表，且在链表的头结点和尾节点也是循环指向的。</p>
</blockquote>
<h3 id="为何不采用hash创建索引方式">为何不采用Hash创建索引方式？</h3>
<blockquote>
<p>因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ Tree是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。</p>
<p>哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</p>
</blockquote>
<h3 id="什么时候需要建立索引什么时候不需要建立索引">什么时候需要建立索引，什么时候不需要建立索引</h3>
<blockquote>
<p>创建索引</p>
<ol>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段</li>
<li>查询中与其他表关联的字段，外键关系建立索引</li>
<li>单键/组合索引的选择问题，高并发下倾向创建组合索引</li>
<li>查询中排序的字段，排序字段通过索引访问大幅提高排序速度</li>
<li>查询中统计或分组字段</li>
</ol>
<p>不建立索引</p>
<ol>
<li>表记录太少</li>
<li>经常增删改的表</li>
<li>数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）</li>
<li>频繁更新的字段不适合创建索引（会加重IO负担）</li>
<li>where条件里用不到的字段不创建索引</li>
</ol>
</blockquote>
<h3 id="数据库建立索引常用的规则如下">数据库建立索引常用的规则如下：</h3>
<ol>
<li>表的主键、外键必须有索引；</li>
<li>数据量超过300的表应该有索引；</li>
<li>经常与其他表进行连接的表，在连接字段上应该建立索引；</li>
<li>经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；</li>
<li>索引应该建在选择性高的字段上；</li>
<li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；</li>
<li>复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替：</li>
</ol>
<blockquote>
<ol>
<li>正确选择复合索引中的主列字段，一般是选择性较好的字段；</li>
<li>复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；</li>
<li>如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；</li>
<li>如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；</li>
</ol>
</blockquote>
<ol>
<li>频繁进行数据操作的表，不要建立太多的索引；</li>
<li>删除无用的索引，避免对执行计划造成负面影响；</li>
</ol>
<p>以上是一些普遍的建立索引时的判断依据。
索引的建立必须慎重，对每个索引的必要性都应该经过仔细分析，要有建立的依据。
因为太多的索引与不充分、不正确的索引对性能都毫无益处：在表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。 另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。
总的来说，小型表肯定不建索引，
或者数据库记录在亿条数据级以上，还是建议使用非关系型数据库。
还有些特殊字段的数据库，比如BLOB，CLOB字段肯定也不适合建索引。
其实这个问题更感觉偏向于做软件项目的一种经验。</p>
<h3 id="count1countcount列名">count(1)，count(*)，count(列名)</h3>
<ul>
<li>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL</li>
<li>count(1)包括了所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL</li>
<li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。</li>
<li>执行效率上：
<ul>
<li>列名为主键，count(列名)会比count(1)快</li>
<li>列名不为主键，count(1)会比count(列名)快</li>
<li>如果表多个列并且没有主键，则 count(1) 的执行效率优于 count(*)</li>
<li>如果有主键，则 select count（主键）的执行效率是最优的</li>
<li>如果表只有一个字段，则 select count(*) 最优。</li>
</ul>
</li>
</ul>
<h3 id="mysql单表一千万数据怎么查最快">mysql单表一千万数据，怎么查最快</h3>
<ul>
<li>
<p>limit，offset</p>
<p>在limit的偏移量越来越大的时候，数据则会越来越慢，花费的时间也会越来越长，使用子查询</p>
</li>
</ul>
<h1 id="mybatis">Mybatis</h1>
<h3 id="讲一讲mybatis-的工作原理">讲一讲mybatis 的工作原理</h3>
<h1 id="spring">Spring</h1>
<h3 id="spring的bean注入过程讲一下">Spring的Bean注入过程讲一下</h3>
<h3 id="spring中常见的设计模式说一说">Spring中常见的设计模式说一说</h3>
<h3 id="spring是怎么解决bean之间的循环依赖问题">Spring是怎么解决Bean之间的循环依赖问题</h3>
<p>spring针对如果是非单例的bean直接会抛出异常。</p>
<p>单例的bean是</p>
<h3 id="springmvc的流程">SpringMvc的流程</h3>
<h3 id="springboot的启动原理">SpringBoot的启动原理</h3>
<h3 id="springcloud了解多少">SpringCloud了解多少</h3>
<h3 id="aop怎么实现的">AOP怎么实现的</h3>
<h3 id="configureable的作用">@Configureable的作用</h3>
<h1 id="分布式">分布式</h1>
<h3 id="怎么保证幂等">怎么保证幂等</h3>
<ul>
<li>唯一索引</li>
<li>悲观锁，加锁</li>
</ul>
<h3 id="cap">CAP</h3>
<p>C (一致性):对某个指定的客户端来说，读操作能返回最新的写操作。对于数据分布在不同节点上的数据上来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。</p>
<p>A (可用性)：非故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应)。可用性的两个关键一个是合理的时间，一个是合理的响应。合理的时间指的是请求不能无限被阻塞，应该在合理的时间给出返回。合理的响应指的是系统应该明确返回结果并且结果是正确的，这里的正确指的是比如应该返回50，而不是返回40。</p>
<p>P (分区容错性):当出现网络分区后，系统能够继续工作。打个比方，这里个集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。</p>
<h3 id="nacos怎么实现的ap和cp">Nacos怎么实现的AP和CP</h3>
<p>在nacos中，<code>CP</code>与<code>AP</code>切换的条件是注册的服务实例是否是临时实例</p>
<h3 id="为什么要用dubbo和springcloud的区别是什么">为什么要用dubbo，和SpringCloud的区别是什么</h3>
<p><code>Dubbo</code>由于是二进制的传输，占用带宽会更少。<code>Spring Cloud</code> 是 HTTP 协议传输，带宽占用会比较多，同时使用 HTTP 协议一般会使用 <code>JSON</code> 报文，消耗会更大。</p>
<p>Dubbo 的开发难度较大，原因是 Dubbo 的 jar 包依赖问题很多大型工程无法解决；Spring Cloud 的接口协议约定比较自由且松散，需要有强有力的行政措施来限制接口无序升级。</p>
<p>Dubbo 的注册中心可以选择 <code>Zookeeper</code>、<code>Redis</code> 等多种；Spring Cloud 的注册中心只能用 <code>Eureka</code> 或者自研</p>
<h3 id="分布式事务分布式锁分布式链路追踪解决方案">分布式事务、分布式锁、分布式链路追踪解决方案</h3>
<ul>
<li>
<p><!-- raw HTML omitted -->分布式锁<!-- raw HTML omitted --></p>
<ol>
<li>
<p><strong>基于 MySQL 中的锁</strong>：MySQL 本身有自带的悲观锁 <code>for update</code> 关键字，也可以自己实现悲观/乐观锁来达到目的；</p>
</li>
<li>
<p><strong>基于 Zookeeper 有序节点</strong>：Zookeeper 允许临时创建有序的子节点，这样客户端获取节点列表时，就能够当前子节点列表中的序号判断是否能够获得锁；</p>
<p>zooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它可以为分布式应用提供一致性服务，它是Hadoop和Hbase的重要组件，同时也可以作为配置中心、注册中心运用在微服务体系中。</p>
</li>
<li>
<p><strong>基于 Redis 的单线程</strong>：由于 Redis 是单线程，所以命令会以串行的方式执行，并且本身提供了像 <code>SETNX(set if not exists)</code> 这样的指令，本身具有互斥性；</p>
<ul>
<li>
<p>锁超时：如果某服务获取到锁，挂了，那么锁就永远得不到了。因此需要设置超时时间</p>
<p>但是另一个问题随即而来：<strong>如果在加锁和释放锁之间的逻辑执行得太长，以至于超出了锁的超时限制</strong>，也会出现问题。因为这时候第一个线程持有锁过期了，而临界区的逻辑还没有执行完，与此同时第二个线程就提前拥有了这把锁，导致临界区的代码不能得到严格的串行执行。</p>
<p>为了避免这个问题，<strong>Redis 分布式锁不要用于较长时间的任务</strong>。如果真的偶尔出现了问题，造成的数据小错乱可能就需要人工的干预。</p>
<p>有一个稍微安全一点的方案是 <strong>将锁的 <code>value</code> 值设置为一个随机数</strong>，释放锁时先匹配随机数是否一致，然后再删除 key，这是为了 <strong>确保当前线程占有的锁不会被其他线程释放</strong>，除非这个锁是因为过期了而被服务器自动释放的。</p>
<p>但是匹配 <code>value</code> 和删除 <code>key</code> 在 Redis 中并不是一个原子性的操作，也没有类似保证原子性的指令，所以可能需要使用像 Lua 这样的脚本来处理了，因为 Lua 脚本可以 <strong>保证多个指令的原子性执行</strong>。</p>
</li>
<li>
<p><strong>RedLock</strong>：解决多节点redis时，发生获取锁后，主节点掉线，导致其他服务获取到了锁</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>分布式事务</p>
<p>阿里的Seata</p>
</li>
</ul>
<h1 id="es">ES</h1>
<h3 id="为什么es能查询的这么快">为什么ES能查询的这么快</h3>
<h3 id="你了解多少es为什么选择用es">你了解多少ES，为什么选择用ES</h3>
<h1 id="zookeeper">Zookeeper</h1>
<h3 id="zookeeper是干什么的你使用过吗用它做过什么事情吗">Zookeeper是干什么的，你使用过吗，用它做过什么事情吗</h3>
<h1 id="java并发">Java并发</h1>
<h3 id="讲一下伪共享">讲一下伪共享</h3>
<p>在计算机中，真正做计算的动作都是cpu核心。而与cpu交互最多的是内存。每次代码在执行的时候，变量都是存放在内存中的。但是内存的速度相对于CPU来说是相当慢的。因此在CPU和内存中间还有“高速缓存”，一般有3级，L1，L2，L3依此离CPU的距离变远。越近的容量越小，造价越高。其中L3是多核心共享的。</p>
<p>CPU再计算的时候，会先从L1中找，找不到从L2中，再从L3中，最后才从主内存中加载。</p>
<p>而高速缓存的单位通常是连续的64字节的一个“缓存行”。</p>
<p>在程序运行的过程中，缓存每次更新都从主内存中加载连续的 64 个字节。因此，如果访问一个 long 类型的数组时，当数组中的一个值被加载到缓存中时，另外 7 个元素也会被加载到缓存中。</p>
<p>但是，如果使用的数据结构中的项在内存中不是彼此相邻的，比如链表，那么将得不到免费缓存加载带来的好处。</p>
<p>不过，这种免费加载也有一个坏处。设想如果我们有个 long 类型的变量 a，它不是数组的一部分，而是一个单独的变量，并且还有另外一个 long 类型的变量 b 紧挨着它，那么当加载 a 的时候将免费加载 b。</p>
<p>看起来似乎没有什么毛病，但是如果一个 CPU 核心的线程在对 a 进行修改，另一个 CPU 核心的线程却在对 b 进行读取。</p>
<p>当前者修改 a 时，会把 a 和 b 同时加载到前者核心的缓存行中，更新完 a 后其它所有包含 a 的缓存行都将失效，因为其它缓存中的 a 不是最新值了。</p>
<p>而当后者读取 b 时，发现这个缓存行已经失效了，需要从主内存中重新加载。</p>
<p>请记住，我们的缓存都是以缓存行作为一个单位来处理的，所以失效 a 的缓存的同时，也会把 b 失效，反之亦然。</p>
<p><img src="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/false-sharing3.png" alt="ABA"></p>
<p>这样就出现了一个问题，b 和 a 完全不相干，每次却要因为 a 的更新需要从主内存重新读取，它被缓存未命中给拖慢了。</p>
<p>这就是传说中的伪共享。</p>
<h3 id="你知道unsafe类吗为什么他是unsafe的它能做什么">你知道UnSafe类吗，为什么他是“UnSafe”的，它能做什么</h3>
<ul>
<li>
<p>UnSafe的获取方式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Field f <span style="color:#f92672">=</span> Unsafe<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getDeclaredField</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;theUnsafe&#34;</span><span style="color:#f92672">);</span>
        f<span style="color:#f92672">.</span><span style="color:#a6e22e">setAccessible</span><span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">);</span>
        Unsafe unsafe <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Unsafe<span style="color:#f92672">)</span> f<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
</code></pre></div></li>
<li>
<p>可以做什么</p>
<ul>
<li>
<p>实例化一个类</p>
<p><code>Unsafe.allocateInstance()</code>只会给对象分配内存，并不会调用构造方法</p>
</li>
<li>
<p>使用Unsafe的putXXX()方法，我们可以修改任意私有字段的值。</p>
</li>
</ul>
</li>
<li>
<p>抛出check异常</p>
<p>我们知道如果代码抛出了checked异常，要不就使用try&hellip;catch捕获它，要不就在方法签名上定义这个异常，但是，通过Unsafe我们可以抛出一个checked异常，同时却不用捕获或在方法签名上定义它。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 使用正常方式抛出IOException需要定义在方法签名上往外抛
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">readFile</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IOException<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 使用Unsafe抛出异常不需要定义在方法签名上往外抛
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">readFileUnsafe</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    unsafe<span style="color:#f92672">.</span><span style="color:#a6e22e">throwException</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> IOException<span style="color:#f92672">());</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p>使用堆外内存</p>
<p>如果进程在运行过程中JVM上的内存不足了，会导致频繁的进行GC。理想情况下，我们可以考虑使用堆外内存，这是一块不受JVM管理的内存。</p>
<p>使用Unsafe的allocateMemory()我们可以直接在堆外分配内存，这可能非常有用，但我们要记住，这个内存不受JVM管理，因此我们要调用freeMemory()方法手动释放它。</p>
</li>
<li>
<p>CompareAndSwap操作</p>
<p>JUC下面大量使用了CAS操作，它们的底层是调用的Unsafe的CompareAndSwapXXX()方法。这种方式广泛运用于无锁算法，与java中标准的悲观锁机制相比，它可以利用CAS处理器指令提供极大的加速。</p>
</li>
<li>
<p>park/unpark</p>
<p>JVM在上下文切换的时候使用了Unsafe中的两个非常牛逼的方法park()和unpark()。</p>
<p>当一个线程正在等待某个操作时，JVM调用Unsafe的park()方法来阻塞此线程。</p>
<p>当阻塞中的线程需要再次运行时，JVM调用Unsafe的unpark()方法来唤醒此线程。</p>
<p>我们之前在分析java中的集合时看到了大量的LockSupport.park()/unpark()，它们底层都是调用的Unsafe的这两个方法。</p>
</li>
</ul>
<h3 id="异步同步阻塞非阻塞线程进程他们的关系">异步、同步；阻塞、非阻塞；线程、进程他们的关系</h3>
<ul>
<li>
<p>异步和同步</p>
<p>同步与异步最大的区别就是<strong>被调用方</strong>的<strong>执行方式</strong>和<strong>返回时机</strong>，同步指的是<strong>被调用方</strong>做完事情之后再返回，异步指的是<strong>被调用方</strong>先返回，然后再做事情，做完之后再想办法通知调用方</p>
</li>
<li>
<p>阻塞和非阻塞</p>
<p>阻塞就是发起一个请求，<strong>调用者</strong>一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</p>
<p>非阻塞就是发起一个请求，<strong>调用者</strong>不用一直等着结果返回，可以先去干其他事情。</p>
</li>
</ul>
<blockquote>
<p>阻塞和同步不是一回事，同步，异步与阻塞，非阻塞针对的对象是不一样的，<strong>阻塞,非阻塞是说的调用者，同步，异步说的是被调用者</strong></p>
</blockquote>
<h3 id="你知道哪几种锁">你知道哪几种锁</h3>
<ul>
<li>
<p>公平锁/非公平锁</p>
<p>公平锁：按照线程的申请顺序获取锁</p>
<p>非公平锁：不是按照申请的顺序，可能后申请的线程反而先获取到锁</p>
<p>ReentrantLock中可以通过构造方法指定是否为公平锁，默认为非公平锁，非公平锁的优点在于吞吐量大。</p>
<p>synchronized无法指定为公平锁，一直都是非公平锁。</p>
</li>
<li>
<p>可重入锁</p>
<p>可重入锁，是指一个线程获取锁之后再尝试获取锁时会自动获取锁，可重入锁的优点是避免死锁。</p>
<p>具体一点，就是一个线程获得锁之后，再次获得锁的时候，不需要释放锁。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">import</span> java.util.concurrent.atomic.AtomicReference<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UnreentrantLock</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> AtomicReference<span style="color:#f92672">&lt;</span>Thread<span style="color:#f92672">&gt;</span> owner <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AtomicReference<span style="color:#f92672">&lt;</span>Thread<span style="color:#f92672">&gt;();</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        Thread current <span style="color:#f92672">=</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">();</span>
        <span style="color:#75715e">//这句是很经典的“自旋”语法，AtomicInteger中也有
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>owner<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSet</span><span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> current<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        Thread current <span style="color:#f92672">=</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">();</span>
        owner<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSet</span><span style="color:#f92672">(</span>current<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>代码也比较简单，使用原子引用来存放线程，同一线程两次调用lock()方法，如果不执行unlock()释放锁的话，第二次调用自旋的时候就会产生死锁，这个锁就不是可重入的，而实际上同一个线程不必每次都去释放锁再来获取锁，这样的调度切换是很耗资源的。稍微改一下，把它变成一个可重入锁：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">import</span> java.util.concurrent.atomic.AtomicReference<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UnreentrantLock</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> AtomicReference<span style="color:#f92672">&lt;</span>Thread<span style="color:#f92672">&gt;</span> owner <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AtomicReference<span style="color:#f92672">&lt;</span>Thread<span style="color:#f92672">&gt;();</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> state <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        Thread current <span style="color:#f92672">=</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>current <span style="color:#f92672">==</span> owner<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            state<span style="color:#f92672">++;</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">//这句是很经典的“自旋”式语法，AtomicInteger中也有
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>owner<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSet</span><span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> current<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        Thread current <span style="color:#f92672">=</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>current <span style="color:#f92672">==</span> owner<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>state <span style="color:#f92672">!=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                state<span style="color:#f92672">--;</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                owner<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSet</span><span style="color:#f92672">(</span>current<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>ReentrantLock和synchronized都是可重入锁。</p>
<p>synchronized是在对象头中做了计数器，monitorenter的时候，计数器+1，monitorexit的时候，计数器-1。来达到重入锁的目的。</p>
<p>ReentrantLock底层用的AQS，AQS中有一个state变量，获取锁成功后，会+1，用来解决重入锁的问题</p>
</li>
<li>
<p>独占锁/共享锁</p>
<p>独占锁：锁一次只能被一个线程占有</p>
<p>共享锁：锁可以被多个线程占有</p>
<p>ReentrantLock和synchronized都是独享锁，ReadWriteLock的读锁是共享锁，写锁是独享锁。</p>
</li>
<li>
<p>互斥锁/读写锁</p>
<p>与独享锁/共享锁的概念差不多，是独享锁/共享锁的具体实现。</p>
<p>ReentrantLock和synchronized都是互斥锁</p>
<p>ReadWriteLock是读写锁</p>
</li>
<li>
<p>乐观锁/悲观锁</p>
<p>悲观锁，是指认为对于同一个数据的并发操作必然会发生修改，即使不会发生修改也这么认为，所以一定要加锁。</p>
<p>乐观锁，是指认为对于同一个数据的并发操作不一定会发生修改，在更新数据的时候，尝试去更新数据，如果失败就不断尝试。</p>
<p>悲观锁适用于写操作多的场景，乐观锁适用于读操作多的场景。</p>
</li>
<li>
<p>分段锁</p>
<p>分段锁，是一种锁的设计思路，它细化了锁的粒度，主要运用在ConcurrentHashMap中，实现高效的并发操作，当操作不需要更新整个数组时，就只锁数组中的一项就可以了。</p>
</li>
<li>
<p>偏向锁/轻量级锁/重量级锁</p>
<p>这三种锁，都是针对于Synchronized关键字进行优化的，主要通过对象监视器在对象头中的字段来表明的</p>
<ul>
<li>
<p>偏向锁</p>
<p>当同一段同步代码一直被一个线程访问，那么这个线程会自动获取锁，降低获取锁的代价</p>
</li>
<li>
<p>轻量级锁</p>
<p>当前的锁如果是偏向锁的话，如果被另一个线程访问中，就是持有中。偏向锁会升级为轻量级锁，这个线程会通过自旋的方式不断的尝试获取锁</p>
</li>
<li>
<p>重量级锁</p>
<p>当前锁是轻量级锁的情况下，当自旋的线程自旋了一定程度后，还没有获得到锁的话，就会进入阻塞状态，该锁会升级为重量级锁，重量级锁会让其他线程进入阻塞状态，性能降低</p>
</li>
</ul>
</li>
<li>
<p>自旋锁</p>
<p>通过不断尝试获取锁，通过减少上下文切换带来的开锁消耗。提高性能，缺点是循环会消耗CPU</p>
</li>
<li>
<p>监视器锁</p>
<p>synchronized的实现方式，使用monitorenter和monitorexit来实现</p>
</li>
<li>
<p>mutex锁</p>
<p>互斥锁，LockSupport.part()底层通过mutex实现的</p>
</li>
</ul>
<h3 id="自己实现一个锁">自己实现一个锁</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 实现一个锁
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * 思路：通过定义一个变量，让多个线程去修改他，通过CAS操作，如果没有操作成功的，则进入队列
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyLock</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">//定义一个状态变量，通过volatile关键字修饰,让每个线程都能看到
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> state<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> stateOffset<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> tailOffset<span style="color:#f92672">;</span>
    <span style="color:#75715e">//UnSafe类
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> Unsafe unsafe<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 存储的元素为线程
</span><span style="color:#75715e"></span>        Thread thread<span style="color:#f92672">;</span>
        <span style="color:#75715e">// 前一个节点（可以没有，但实现起来很困难）
</span><span style="color:#75715e"></span>        Node prev<span style="color:#f92672">;</span>
        <span style="color:#75715e">// 后一个节点
</span><span style="color:#75715e"></span>        Node next<span style="color:#f92672">;</span>

        <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Node</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Node</span><span style="color:#f92672">(</span>Thread thread<span style="color:#f92672">,</span> Node prev<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">thread</span> <span style="color:#f92672">=</span> thread<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> prev<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// 链表头
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> Node head<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 链表尾
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> Node tail<span style="color:#f92672">;</span>


    <span style="color:#66d9ef">static</span> <span style="color:#f92672">{</span>
        Field f <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
            f <span style="color:#f92672">=</span> Unsafe<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getDeclaredField</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;theUnsafe&#34;</span><span style="color:#f92672">);</span>
            f<span style="color:#f92672">.</span><span style="color:#a6e22e">setAccessible</span><span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">);</span>
            unsafe <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Unsafe<span style="color:#f92672">)</span> f<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
            <span style="color:#75715e">// 获取state的偏移量
</span><span style="color:#75715e"></span>            stateOffset <span style="color:#f92672">=</span> unsafe<span style="color:#f92672">.</span><span style="color:#a6e22e">objectFieldOffset</span><span style="color:#f92672">(</span>MyLock<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getDeclaredField</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;state&#34;</span><span style="color:#f92672">));</span>
            <span style="color:#75715e">// 获取tail的偏移量
</span><span style="color:#75715e"></span>            tailOffset <span style="color:#f92672">=</span> unsafe<span style="color:#f92672">.</span><span style="color:#a6e22e">objectFieldOffset</span><span style="color:#f92672">(</span>MyLock<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getDeclaredField</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;tail&#34;</span><span style="color:#f92672">));</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>NoSuchFieldException <span style="color:#f92672">|</span> IllegalAccessException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>


    <span style="color:#75715e">// 原子更新tail字段
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">compareAndSetTail</span><span style="color:#f92672">(</span>Node expect<span style="color:#f92672">,</span> Node update<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> unsafe<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSwapObject</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> tailOffset<span style="color:#f92672">,</span> expect<span style="color:#f92672">,</span> update<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * cas更新state
</span><span style="color:#75715e">     * @param expect
</span><span style="color:#75715e">     * @param update
</span><span style="color:#75715e">     * @return
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">compareAndSetState</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> expect<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> update<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> unsafe<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSwapInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> stateOffset<span style="color:#f92672">,</span> expect<span style="color:#f92672">,</span> update<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> Node empty <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">();</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">MyLock</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">head</span><span style="color:#f92672">=</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">tail</span><span style="color:#f92672">=</span>empty<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 尝试更新state字段，更新成功说明占有了锁
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndSetState<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> 1<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 未更新成功则入队
</span><span style="color:#75715e"></span>        Node node <span style="color:#f92672">=</span> enqueue<span style="color:#f92672">();</span>
        Node prev <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 再次尝试获取锁，需要检测上一个节点是不是head，检查是不是下一个应该的，按入队顺序加锁
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">!=</span> head <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>compareAndSetState<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> 1<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 未获取到锁，阻塞
</span><span style="color:#75715e"></span>            unsafe<span style="color:#f92672">.</span><span style="color:#a6e22e">park</span><span style="color:#f92672">(</span><span style="color:#66d9ef">false</span><span style="color:#f92672">,</span> 0L<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 下面不需要原子更新，因为同时只有一个线程访问到这里
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 获取到锁了且上一个节点是head
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// head后移一位
</span><span style="color:#75715e"></span>        head <span style="color:#f92672">=</span> node<span style="color:#f92672">;</span>
        <span style="color:#75715e">// 清空当前节点的内容，协助GC
</span><span style="color:#75715e"></span>        node<span style="color:#f92672">.</span><span style="color:#a6e22e">thread</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 将上一个节点从链表中剔除，协助GC
</span><span style="color:#75715e"></span>        node<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        prev<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// 入队
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">enqueue</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 获取尾节点
</span><span style="color:#75715e"></span>            Node t <span style="color:#f92672">=</span> tail<span style="color:#f92672">;</span>
            <span style="color:#75715e">// 构造新节点
</span><span style="color:#75715e"></span>            Node node <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">(),</span> t<span style="color:#f92672">);</span>
            <span style="color:#75715e">// 不断尝试原子更新尾节点
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndSetTail<span style="color:#f92672">(</span>t<span style="color:#f92672">,</span> node<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 更新尾节点成功了，让原尾节点的next指针指向当前节点
</span><span style="color:#75715e"></span>                t<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node<span style="color:#f92672">;</span>
                <span style="color:#66d9ef">return</span> node<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">// 解锁
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 把state更新成0，这里不需要原子更新，因为同时只有一个线程访问到这里
</span><span style="color:#75715e"></span>        state <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#75715e">// 下一个待唤醒的节点
</span><span style="color:#75715e"></span>        Node next <span style="color:#f92672">=</span> head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 下一个节点不为空，就唤醒它
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>next <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            unsafe<span style="color:#f92672">.</span><span style="color:#a6e22e">unpark</span><span style="color:#f92672">(</span>next<span style="color:#f92672">.</span><span style="color:#a6e22e">thread</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>


    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> count<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> InterruptedException <span style="color:#f92672">{</span>

        MyLock lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyLock<span style="color:#f92672">();</span>

        CountDownLatch countDownLatch <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CountDownLatch<span style="color:#f92672">(</span>1000<span style="color:#f92672">);</span>

        IntStream<span style="color:#f92672">.</span><span style="color:#a6e22e">range</span><span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> 1000<span style="color:#f92672">).</span><span style="color:#a6e22e">forEach</span><span style="color:#f92672">(</span>i <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
            lock<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>

            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                IntStream<span style="color:#f92672">.</span><span style="color:#a6e22e">range</span><span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> 10000<span style="color:#f92672">).</span><span style="color:#a6e22e">forEach</span><span style="color:#f92672">(</span>j <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
                    count<span style="color:#f92672">++;</span>
                <span style="color:#f92672">});</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
                lock<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
            <span style="color:#f92672">}</span>
<span style="color:#75715e">//            System.out.println(Thread.currentThread().getName());
</span><span style="color:#75715e"></span>            countDownLatch<span style="color:#f92672">.</span><span style="color:#a6e22e">countDown</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">},</span> <span style="color:#e6db74">&#34;tt-&#34;</span> <span style="color:#f92672">+</span> i<span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">());</span>

        countDownLatch<span style="color:#f92672">.</span><span style="color:#a6e22e">await</span><span style="color:#f92672">();</span>

        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>count<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="讲一下线程的生命周期">讲一下线程的生命周期</h3>
<p>java.lang.Thread.State中定义了线程的状态</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">enum</span> State <span style="color:#f92672">{</span>
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Thread state for a thread which has not yet started.
</span><span style="color:#75715e">     */</span>
  <span style="color:#75715e">//新建状态,线程还未开始
</span><span style="color:#75715e"></span>    NEW<span style="color:#f92672">,</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Thread state for a runnable thread.  A thread in the runnable
</span><span style="color:#75715e">     * state is executing in the Java virtual machine but it may
</span><span style="color:#75715e">     * be waiting for other resources from the operating system
</span><span style="color:#75715e">     * such as processor.
</span><span style="color:#75715e">     */</span>
  <span style="color:#75715e">//可以运行状态，已经在jvm虚拟机中了，正在等待操作系统分配资源
</span><span style="color:#75715e"></span>    RUNNABLE<span style="color:#f92672">,</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Thread state for a thread blocked waiting for a monitor lock.
</span><span style="color:#75715e">     * A thread in the blocked state is waiting for a monitor lock
</span><span style="color:#75715e">     * to enter a synchronized block/method or
</span><span style="color:#75715e">     * reenter a synchronized block/method after calling
</span><span style="color:#75715e">     * {@link Object#wait() Object.wait}.
</span><span style="color:#75715e">     */</span>
  <span style="color:#75715e">//阻塞状态，正在等待一个monitor锁，就是我们平时用的synchronized的关键字。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//或者在调用了Object.wait()方法且被notify()之后也会进入BLOCKED状态
</span><span style="color:#75715e"></span>    BLOCKED<span style="color:#f92672">,</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Thread state for a waiting thread.
</span><span style="color:#75715e">     * A thread is in the waiting state due to calling one of the
</span><span style="color:#75715e">     * following methods:
</span><span style="color:#75715e">     * &lt;ul&gt;
</span><span style="color:#75715e">     *   &lt;li&gt;{@link Object#wait() Object.wait} with no timeout&lt;/li&gt;
</span><span style="color:#75715e">     *   &lt;li&gt;{@link #join() Thread.join} with no timeout&lt;/li&gt;
</span><span style="color:#75715e">     *   &lt;li&gt;{@link LockSupport#park() LockSupport.park}&lt;/li&gt;
</span><span style="color:#75715e">     * &lt;/ul&gt;
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to
</span><span style="color:#75715e">     * perform a particular action.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * For example, a thread that has called {@code Object.wait()}
</span><span style="color:#75715e">     * on an object is waiting for another thread to call
</span><span style="color:#75715e">     * {@code Object.notify()} or {@code Object.notifyAll()} on
</span><span style="color:#75715e">     * that object. A thread that has called {@code Thread.join()}
</span><span style="color:#75715e">     * is waiting for a specified thread to terminate.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     等待状态
</span><span style="color:#75715e">       * 1. Object.wait()无超时的方法后且未被notify()前，如果被notify()了会进入BLOCKED状态
</span><span style="color:#75715e">     * 2. Thread.join()无超时的方法后
</span><span style="color:#75715e">     * 3. LockSupport.park()无超时的方法后
</span><span style="color:#75715e">         */</span>
    WAITING<span style="color:#f92672">,</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Thread state for a waiting thread with a specified waiting time.
</span><span style="color:#75715e">     * A thread is in the timed waiting state due to calling one of
</span><span style="color:#75715e">     * the following methods with a specified positive waiting time:
</span><span style="color:#75715e">     * &lt;ul&gt;
</span><span style="color:#75715e">     *   &lt;li&gt;{@link #sleep Thread.sleep}&lt;/li&gt;
</span><span style="color:#75715e">     *   &lt;li&gt;{@link Object#wait(long) Object.wait} with timeout&lt;/li&gt;
</span><span style="color:#75715e">     *   &lt;li&gt;{@link #join(long) Thread.join} with timeout&lt;/li&gt;
</span><span style="color:#75715e">     *   &lt;li&gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;
</span><span style="color:#75715e">     *   &lt;li&gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;
</span><span style="color:#75715e">     * &lt;/ul&gt;
</span><span style="color:#75715e">     *超市等待状态,调用了    
</span><span style="color:#75715e">     * 1. Thread.sleep()方法后
</span><span style="color:#75715e">     * 2. Object.wait(timeout)方法后且未到超时时间前，如果达到超时了或被notify()了会进入BLOCKED状态
</span><span style="color:#75715e">     * 3. Thread.join(timeout)方法后
</span><span style="color:#75715e">     * 4. LockSupport.parkNanos(nanos)方法后
</span><span style="color:#75715e">     * 5. LockSupport.parkUntil(deadline)方法后
</span><span style="color:#75715e">       /*
</span><span style="color:#75715e">    TIMED_WAITING,
</span><span style="color:#75715e">
</span><span style="color:#75715e">    /**
</span><span style="color:#75715e">     * Thread state for a terminated thread.
</span><span style="color:#75715e">     * The thread has completed execution.
</span><span style="color:#75715e">     */</span>
  <span style="color:#75715e">//终止状态，线程执行完毕
</span><span style="color:#75715e"></span>    TERMINATED<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="线程可以被终止吗怎么终止">线程可以被终止吗，怎么终止</h3>
<p>可以被终止</p>
<ul>
<li>通过设置标记，配合循环</li>
</ul>
<p>​	线程只有在执行完代码后才会终止，因此我们可以使用while循环，通过一个volatile修饰的变量控制跳出循环即可</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>通过interrupt方法</p>
<!-- raw HTML omitted -->
</li>
</ul>
<p>但是这种方式有问题，实际上在执行interrupt后，依然会继续执行一会儿，并不能做到立马停止。</p>
<p>如果有阻塞的动作，会立马抛出异常</p>
<!-- raw HTML omitted -->
<ul>
<li>interrupt()方法，标记线程结束，只是给一个标记，并不终止。</li>
<li>interrupted()方法，返回当前线程是否有终止的标记，并且清除标记。下一次再调这个方法会返回false</li>
<li>isInterrupted()方法，返回当前线程是否有终止的标记，但不清除标记。</li>
<li>通过stop方法，stop就像直接拔掉插头一样，会造成很多问题，不推荐使用</li>
</ul>
<h3 id="aqs是什么">AQS是什么？</h3>
<p>AQS全称</p>
<p>AbstractQueuedSynchronizer，抽象的队列同步器</p>
<p>AQS是基于FIFO的队列实现的，并且内部维护了一个状态变量state，通过原子更新这个状态变量state即可以实现加锁解锁操作。</p>
<p>内部结构</p>
<ul>
<li>Node：典型的双链表结构，节点中保存着当前线程、前一个节点、后一个节点以及线程的状态等信息。</li>
<li>State：通过这个状态用来控制锁</li>
</ul>
<p>需要子类实现的方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 互斥模式下使用：尝试获取锁
</span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAcquire</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> arg<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> UnsupportedOperationException<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 互斥模式下使用：尝试释放锁
</span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryRelease</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> arg<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> UnsupportedOperationException<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 共享模式下使用：尝试获取锁
</span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">tryAcquireShared</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> arg<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> UnsupportedOperationException<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 共享模式下使用：尝试释放锁
</span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryReleaseShared</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> arg<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> UnsupportedOperationException<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 如果当前线程独占着锁，返回true
</span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isHeldExclusively</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> UnsupportedOperationException<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>

</code></pre></div><p>通过AQS自己实现一个锁</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyLockBaseOnAqs</span> <span style="color:#f92672">{</span>

    <span style="color:#75715e">// 定义一个同步器，实现AQS类
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Sync</span> <span style="color:#66d9ef">extends</span> AbstractQueuedSynchronizer <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 实现tryAcquire(acquires)方法
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">@Override</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAcquire</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> acquires<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndSetState<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> 1<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                setExclusiveOwnerThread<span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">());</span>
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 实现tryRelease(releases)方法
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">@Override</span>
        <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryRelease</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> releases<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            setExclusiveOwnerThread<span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
            setState<span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">// 声明同步器
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Sync sync <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Sync<span style="color:#f92672">();</span>

    <span style="color:#75715e">// 加锁
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        sync<span style="color:#f92672">.</span><span style="color:#a6e22e">acquire</span><span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">// 解锁
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        sync<span style="color:#f92672">.</span><span style="color:#a6e22e">release</span><span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>


    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> InterruptedException <span style="color:#f92672">{</span>
        MyLockBaseOnAqs lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyLockBaseOnAqs<span style="color:#f92672">();</span>

        CountDownLatch countDownLatch <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CountDownLatch<span style="color:#f92672">(</span>1000<span style="color:#f92672">);</span>

        IntStream<span style="color:#f92672">.</span><span style="color:#a6e22e">range</span><span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> 1000<span style="color:#f92672">).</span><span style="color:#a6e22e">forEach</span><span style="color:#f92672">(</span>i <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
            lock<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>

            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                IntStream<span style="color:#f92672">.</span><span style="color:#a6e22e">range</span><span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> 10000<span style="color:#f92672">).</span><span style="color:#a6e22e">forEach</span><span style="color:#f92672">(</span>j <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
                    count<span style="color:#f92672">++;</span>
                <span style="color:#f92672">});</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
                lock<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
            <span style="color:#f92672">}</span>
<span style="color:#75715e">//            System.out.println(Thread.currentThread().getName());
</span><span style="color:#75715e"></span>            countDownLatch<span style="color:#f92672">.</span><span style="color:#a6e22e">countDown</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">},</span> <span style="color:#e6db74">&#34;tt-&#34;</span> <span style="color:#f92672">+</span> i<span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">());</span>

        countDownLatch<span style="color:#f92672">.</span><span style="color:#a6e22e">await</span><span style="color:#f92672">();</span>

        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>count<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="waitnotifysleepyieldjoininterrupt这几个方法的作用">wait()、notify()、sleep()、yield()、join()、Interrupt()这几个方法的作用</h3>
<p><img src="https://images2015.cnblogs.com/blog/568153/201707/568153-20170718214947927-1596433893.png" alt="点击全屏显示"></p>
<ul>
<li>
<p>wait</p>
<p>当我们调用wait（）方法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只有调用了notify（）或notifyAll()后等待池的线程才会开始去竞争锁，notify（）是随机从等待池选出一个线程放到锁池，而notifyAll()是将等待池的所有线程放到锁池当中</p>
<p><strong>wait会释放对象锁</strong></p>
</li>
<li>
<p>notify()随机从等待池里，选一个线程去争夺锁。notify()释放所有的等待池里的线程。</p>
<p><!-- raw HTML omitted -->wait()和synchroinzed要锁的对象是同一个对象才可以<!-- raw HTML omitted --></p>
<p><strong>wait()和notify()因为会对对象的“锁标志”进行操作，所以它们必须在获得对象锁后执行即在 synchronized函数或synchronized block中进行调用，否则如果虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。</strong></p>
</li>
<li>
<p>join</p>
<p>Thread实例的方法，释放CPU执行权，等待被调用join方法的线程结束才继续执行本线程下面的操作。不会释放所持有对象的锁。</p>
</li>
<li>
<p>sleep()</p>
<p>Thread类的静态方法，释放CPU执行权，可以让其他线程拥有机会去抢占CPU。等待指定时间后自己醒来。不会释放所持有对象的锁。</p>
</li>
<li>
<p>interrupt()</p>
<p>只是单纯的打上中止的标记。断处于等待状态的线程（对于阻塞状态的线程不起作用，如因synchronized方法或代码块等而阻塞的线程）：<strong>在wait或sleep的线程、在等待线程结束的线程（join的调用者）可以被中断，如果被中断，会抛出InterruptedException</strong>；2、对非等待状态的线程调用interrupt不会抛异常，需要手动检测线程状态并做相应处理。</p>
</li>
<li>
<p>yield()</p>
<p>Thread的静态方法，此方法只是使当前线程重新回到可执行状态，不会阻塞线程，因此执行yield()的线程有可能在进入到可执行状态后马上又被执行。实际上，当某个线程调用了yield方法暂停之后，只有优先级与当前线程相同，或者优先级比当前线程更高的处于就绪状态的线程才会获得执行的机会。</p>
</li>
</ul>
<h3 id="实现线程安全的方法">实现线程安全的方法</h3>
<p>加锁就完事</p>
<h3 id="公平锁和非公平锁的区别reentrantlock是怎么实现的reentrantlock又是怎么实现重入锁的它的条件锁又是什么">公平锁和非公平锁的区别,ReentrantLock是怎么实现的，ReentrantLock又是怎么实现重入锁的，它的条件锁又是什么？</h3>
<p>ReentrantLock，表面意思重复进入的锁</p>
<ul>
<li>通过state变量每次递增，用来实现重入锁。检查当前的独占锁是否是当前线程，如果是的话，直接给state变量+1，不会释放锁，再加锁</li>
</ul>
<p>ReentrantLock内部的主要的属性Sync，是实现了AQS的一个锁。其还有2个子类，</p>
<ul>
<li>
<p>FairSync</p>
<p>公平锁，实现具体公平锁的实现逻辑</p>
</li>
<li>
<p>NoFairSync</p>
<p>非公平锁，实现具体的非公平锁逻辑</p>
</li>
</ul>
<p>ReentrantLock实现了Lock接口</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 获取锁
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
<span style="color:#75715e">// 获取锁（可中断）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lockInterruptibly</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> InterruptedException<span style="color:#f92672">;</span>
<span style="color:#75715e">// 尝试获取锁，如果没获取到锁，就返回false
</span><span style="color:#75715e"></span><span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryLock</span><span style="color:#f92672">();</span>
<span style="color:#75715e">// 尝试获取锁，如果没获取到锁，就等待一段时间，这段时间内还没获取到锁就返回false
</span><span style="color:#75715e"></span><span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryLock</span><span style="color:#f92672">(</span><span style="color:#66d9ef">long</span> time<span style="color:#f92672">,</span> TimeUnit unit<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> InterruptedException<span style="color:#f92672">;</span>
<span style="color:#75715e">// 释放锁
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
<span style="color:#75715e">// 条件锁
</span><span style="color:#75715e"></span>Condition <span style="color:#a6e22e">newCondition</span><span style="color:#f92672">();</span>
</code></pre></div><ul>
<li>
<p>构造方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 默认构造方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ReentrantLock</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    sync <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> NonfairSync<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 自己可选择使用公平锁还是非公平锁
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ReentrantLock</span><span style="color:#f92672">(</span><span style="color:#66d9ef">boolean</span> fair<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    sync <span style="color:#f92672">=</span> fair <span style="color:#f92672">?</span> <span style="color:#66d9ef">new</span> FairSync<span style="color:#f92672">()</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">new</span> NonfairSync<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p>公平锁加锁过程</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// ReentrantLock.lock()
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 调用的sync属性的lock()方法
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这里的sync是公平锁，所以是FairSync的实例
</span><span style="color:#75715e"></span>    sync<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// ReentrantLock.FairSync.lock()
</span><span style="color:#75715e"></span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 调用AQS的acquire()方法获取锁
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 注意，这里传的值为1
</span><span style="color:#75715e"></span>    acquire<span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// AbstractQueuedSynchronizer.acquire()
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">acquire</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> arg<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 尝试获取锁
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果失败了，就排队
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>tryAcquire<span style="color:#f92672">(</span>arg<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span>
        <span style="color:#75715e">// 注意addWaiter()这里传入的节点模式为独占模式
</span><span style="color:#75715e"></span>        acquireQueued<span style="color:#f92672">(</span>addWaiter<span style="color:#f92672">(</span>Node<span style="color:#f92672">.</span><span style="color:#a6e22e">EXCLUSIVE</span><span style="color:#f92672">),</span> arg<span style="color:#f92672">))</span>
        selfInterrupt<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// ReentrantLock.FairSync.tryAcquire()
</span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAcquire</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> acquires<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 当前线程
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">final</span> Thread current <span style="color:#f92672">=</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">();</span>
    <span style="color:#75715e">// 查看当前状态变量的值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> getState<span style="color:#f92672">();</span>
    <span style="color:#75715e">// 如果状态变量的值为0，说明暂时还没有人占有锁
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>c <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 如果没有其它线程在排队，那么当前线程尝试更新state的值为1
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 如果成功了，则说明当前线程获取了锁
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>hasQueuedPredecessors<span style="color:#f92672">()</span> <span style="color:#f92672">&amp;&amp;</span>
            compareAndSetState<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> acquires<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 当前线程获取了锁，把自己设置到exclusiveOwnerThread变量中
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// exclusiveOwnerThread是AQS的父类AbstractOwnableSynchronizer中提供的变量
</span><span style="color:#75715e"></span>            setExclusiveOwnerThread<span style="color:#f92672">(</span>current<span style="color:#f92672">);</span>
            <span style="color:#75715e">// 返回true说明成功获取了锁
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// 如果当前线程本身就占有着锁，现在又尝试获取锁
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 那么，直接让它获取锁并返回true
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>current <span style="color:#f92672">==</span> getExclusiveOwnerThread<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 状态变量state的值加1
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> nextc <span style="color:#f92672">=</span> c <span style="color:#f92672">+</span> acquires<span style="color:#f92672">;</span>
        <span style="color:#75715e">// 如果溢出了，则报错
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nextc <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Maximum lock count exceeded&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#75715e">// 设置到state中
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 这里不需要CAS更新state
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 因为当前线程占有着锁，其它线程只会CAS把state从0更新成1，是不会成功的
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 所以不存在竞争，自然不需要使用CAS来更新
</span><span style="color:#75715e"></span>        setState<span style="color:#f92672">(</span>nextc<span style="color:#f92672">);</span>
        <span style="color:#75715e">// 当线程获取锁成功
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// 当前线程尝试获取锁失败
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// AbstractQueuedSynchronizer.addWaiter()
</span><span style="color:#75715e">// 调用这个方法，说明上面尝试获取锁失败了
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">addWaiter</span><span style="color:#f92672">(</span>Node mode<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 新建一个节点
</span><span style="color:#75715e"></span>    Node node <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">(),</span> mode<span style="color:#f92672">);</span>
    <span style="color:#75715e">// 这里先尝试把新节点加到尾节点后面
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果成功了就返回新节点
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果没成功再调用enq()方法不断尝试
</span><span style="color:#75715e"></span>    Node pred <span style="color:#f92672">=</span> tail<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 如果尾节点不为空
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>pred <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 设置新节点的前置节点为现在的尾节点
</span><span style="color:#75715e"></span>        node<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> pred<span style="color:#f92672">;</span>
        <span style="color:#75715e">// CAS更新尾节点为新节点
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndSetTail<span style="color:#f92672">(</span>pred<span style="color:#f92672">,</span> node<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 如果成功了，把旧尾节点的下一个节点指向新节点
</span><span style="color:#75715e"></span>            pred<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node<span style="color:#f92672">;</span>
            <span style="color:#75715e">// 并返回新节点
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> node<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// 如果上面尝试入队新节点没成功，调用enq()处理
</span><span style="color:#75715e"></span>    enq<span style="color:#f92672">(</span>node<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> node<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// AbstractQueuedSynchronizer.enq()
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">enq</span><span style="color:#f92672">(</span><span style="color:#66d9ef">final</span> Node node<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 自旋，不断尝试
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
        Node t <span style="color:#f92672">=</span> tail<span style="color:#f92672">;</span>
        <span style="color:#75715e">// 如果尾节点为空，说明还未初始化
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>t <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// Must initialize
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 初始化头节点和尾节点
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndSetHead<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Node<span style="color:#f92672">()))</span>
                tail <span style="color:#f92672">=</span> head<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 如果尾节点不为空
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 设置新节点的前一个节点为现在的尾节点
</span><span style="color:#75715e"></span>            node<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">;</span>
            <span style="color:#75715e">// CAS更新尾节点为新节点
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndSetTail<span style="color:#f92672">(</span>t<span style="color:#f92672">,</span> node<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 成功了，则设置旧尾节点的下一个节点为新节点
</span><span style="color:#75715e"></span>                t<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node<span style="color:#f92672">;</span>
                <span style="color:#75715e">// 并返回旧尾节点
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> t<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// AbstractQueuedSynchronizer.acquireQueued()
</span><span style="color:#75715e">// 调用上面的addWaiter()方法使得新节点已经成功入队了
</span><span style="color:#75715e">// 这个方法是尝试让当前节点来获取锁的
</span><span style="color:#75715e"></span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">acquireQueued</span><span style="color:#f92672">(</span><span style="color:#66d9ef">final</span> Node node<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> arg<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 失败标记
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">boolean</span> failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 中断标记
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">boolean</span> interrupted <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 自旋
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 当前节点的前一个节点
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">final</span> Node p <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">predecessor</span><span style="color:#f92672">();</span>
            <span style="color:#75715e">// 如果当前节点的前一个节点为head节点，则说明轮到自己获取锁了
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 调用ReentrantLock.FairSync.tryAcquire()方法再次尝试获取锁
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p <span style="color:#f92672">==</span> head <span style="color:#f92672">&amp;&amp;</span> tryAcquire<span style="color:#f92672">(</span>arg<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 尝试获取锁成功
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// 这里同时只会有一个线程在执行，所以不需要用CAS更新
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// 把当前节点设置为新的头节点
</span><span style="color:#75715e"></span>                setHead<span style="color:#f92672">(</span>node<span style="color:#f92672">);</span>
                <span style="color:#75715e">// 并把上一个节点从链表中删除
</span><span style="color:#75715e"></span>                p<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> <span style="color:#75715e">// help GC
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// 未失败
</span><span style="color:#75715e"></span>                failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
                <span style="color:#66d9ef">return</span> interrupted<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#75715e">// 是否需要阻塞
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>shouldParkAfterFailedAcquire<span style="color:#f92672">(</span>p<span style="color:#f92672">,</span> node<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span>
                <span style="color:#75715e">// 真正阻塞的方法
</span><span style="color:#75715e"></span>                parkAndCheckInterrupt<span style="color:#f92672">())</span>
                <span style="color:#75715e">// 如果中断了
</span><span style="color:#75715e"></span>                interrupted <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 如果失败了
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>failed<span style="color:#f92672">)</span>
            <span style="color:#75715e">// 取消获取锁
</span><span style="color:#75715e"></span>            cancelAcquire<span style="color:#f92672">(</span>node<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// AbstractQueuedSynchronizer.shouldParkAfterFailedAcquire()
</span><span style="color:#75715e">// 这个方法是在上面的for()循环里面调用的
</span><span style="color:#75715e">// 第一次调用会把前一个节点的等待状态设置为SIGNAL，并返回false
</span><span style="color:#75715e">// 第二次调用才会返回true
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">shouldParkAfterFailedAcquire</span><span style="color:#f92672">(</span>Node pred<span style="color:#f92672">,</span> Node node<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 上一个节点的等待状态
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 注意Node的waitStatus字段我们在上面创建Node的时候并没有指定
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 也就是说使用的是默认值0
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这里把各种等待状态再贴出来
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//static final int CANCELLED =  1;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//static final int SIGNAL    = -1;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//static final int CONDITION = -2;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//static final int PROPAGATE = -3;
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> ws <span style="color:#f92672">=</span> pred<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">// 如果等待状态为SIGNAL(等待唤醒)，直接返回true
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>ws <span style="color:#f92672">==</span> Node<span style="color:#f92672">.</span><span style="color:#a6e22e">SIGNAL</span><span style="color:#f92672">)</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">// 如果前一个节点的状态大于0，也就是已取消状态
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>ws <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 把前面所有取消状态的节点都从链表中删除
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">do</span> <span style="color:#f92672">{</span>
            node<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> pred <span style="color:#f92672">=</span> pred<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>pred<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">);</span>
        pred<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 如果前一个节点的状态小于等于0，则把其状态设置为等待唤醒
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 这里可以简单地理解为把初始状态0设置为SIGNAL
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// CONDITION是条件锁的时候使用的
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// PROPAGATE是共享锁使用的
</span><span style="color:#75715e"></span>        compareAndSetWaitStatus<span style="color:#f92672">(</span>pred<span style="color:#f92672">,</span> ws<span style="color:#f92672">,</span> Node<span style="color:#f92672">.</span><span style="color:#a6e22e">SIGNAL</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// AbstractQueuedSynchronizer.parkAndCheckInterrupt()
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">parkAndCheckInterrupt</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 阻塞当前线程
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 底层调用的是Unsafe的park()方法
</span><span style="color:#75715e"></span>    LockSupport<span style="color:#f92672">.</span><span style="color:#a6e22e">park</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
    <span style="color:#75715e">// 返回是否已中断
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">interrupted</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>

</code></pre></div></li>
<li>
<p>非公平锁过程</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// ReentrantLock.lock()
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    sync<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// ReentrantLock.NonfairSync.lock()
</span><span style="color:#75715e">// 这个方法在公平锁模式下是直接调用的acquire(1);
</span><span style="color:#75715e"></span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 直接尝试CAS更新状态变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndSetState<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> 1<span style="color:#f92672">))</span>
        <span style="color:#75715e">// 如果更新成功，说明获取到锁，把当前线程设为独占线程
</span><span style="color:#75715e"></span>        setExclusiveOwnerThread<span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">());</span>
    <span style="color:#66d9ef">else</span>
        acquire<span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// ReentrantLock.NonfairSync.tryAcquire()
</span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAcquire</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> acquires<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 调用父类的方法
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> nonfairTryAcquire<span style="color:#f92672">(</span>acquires<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// ReentrantLock.Sync.nonfairTryAcquire()
</span><span style="color:#75715e"></span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">nonfairTryAcquire</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> acquires<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">final</span> Thread current <span style="color:#f92672">=</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">();</span>
    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> getState<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>c <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 如果状态变量的值为0，再次尝试CAS更新状态变量的值
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 相对于公平锁模式少了!hasQueuedPredecessors()条件
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndSetState<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> acquires<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            setExclusiveOwnerThread<span style="color:#f92672">(</span>current<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>current <span style="color:#f92672">==</span> getExclusiveOwnerThread<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> nextc <span style="color:#f92672">=</span> c <span style="color:#f92672">+</span> acquires<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nextc <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#75715e">// overflow
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Maximum lock count exceeded&#34;</span><span style="color:#f92672">);</span>
        setState<span style="color:#f92672">(</span>nextc<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

</code></pre></div></li>
<li>
<p>释放锁过程</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// java.util.concurrent.locks.ReentrantLock.unlock()
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    sync<span style="color:#f92672">.</span><span style="color:#a6e22e">release</span><span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// java.util.concurrent.locks.AbstractQueuedSynchronizer.release
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">release</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> arg<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 调用AQS实现类的tryRelease()方法释放锁
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tryRelease<span style="color:#f92672">(</span>arg<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
        Node h <span style="color:#f92672">=</span> head<span style="color:#f92672">;</span>
        <span style="color:#75715e">// 如果头节点不为空，且等待状态不是0，就唤醒下一个节点
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 还记得waitStatus吗？
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 在每个节点阻塞之前会把其上一个节点的等待状态设为SIGNAL（-1）
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 所以，SIGNAL的准确理解应该是唤醒下一个等待的线程
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> h<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">!=</span> 0<span style="color:#f92672">)</span>
            unparkSuccessor<span style="color:#f92672">(</span>h<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// java.util.concurrent.locks.ReentrantLock.Sync.tryRelease
</span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryRelease</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> releases<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> getState<span style="color:#f92672">()</span> <span style="color:#f92672">-</span> releases<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 如果当前线程不是占有着锁的线程，抛出异常
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">()</span> <span style="color:#f92672">!=</span> getExclusiveOwnerThread<span style="color:#f92672">())</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalMonitorStateException<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">boolean</span> free <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">// 如果状态变量的值为0了，说明完全释放了锁
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这也就是为什么重入锁调用了多少次lock()就要调用多少次unlock()的原因
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果不这样做，会导致锁不会完全释放，别的线程永远无法获取到锁
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>c <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        free <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 清空占有线程
</span><span style="color:#75715e"></span>        setExclusiveOwnerThread<span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// 设置状态变量的值
</span><span style="color:#75715e"></span>    setState<span style="color:#f92672">(</span>c<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> free<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unparkSuccessor</span><span style="color:#f92672">(</span>Node node<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 注意，这里的node是头节点
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// 如果头节点的等待状态小于0，就把它设置为0
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> ws <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>ws <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
        compareAndSetWaitStatus<span style="color:#f92672">(</span>node<span style="color:#f92672">,</span> ws<span style="color:#f92672">,</span> 0<span style="color:#f92672">);</span>

    <span style="color:#75715e">// 头节点的下一个节点
</span><span style="color:#75715e"></span>    Node s <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">// 如果下一个节点为空，或者其等待状态大于0（实际为已取消）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>s <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        s <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 从尾节点向前遍历取到队列最前面的那个状态不是已取消状态的节点
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Node t <span style="color:#f92672">=</span> tail<span style="color:#f92672">;</span> t <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> t <span style="color:#f92672">!=</span> node<span style="color:#f92672">;</span> t <span style="color:#f92672">=</span> t<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span><span style="color:#f92672">)</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>t<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&lt;=</span> 0<span style="color:#f92672">)</span>
                s <span style="color:#f92672">=</span> t<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// 如果下一个节点不为空，则唤醒它
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>s <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
        LockSupport<span style="color:#f92672">.</span><span style="color:#a6e22e">unpark</span><span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">thread</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

</code></pre></div></li>
<li>
<p>条件锁</p>
<blockquote>
<p>条件锁，是指在获取锁之后发现当前业务场景自己无法处理，而需要等待某个条件的出现才可以继续处理时使用的一种锁。</p>
<p>比如，在阻塞队列中，当队列中没有元素的时候是无法弹出一个元素的，这时候就需要阻塞在条件notEmpty上，等待其它线程往里面放入一个元素后，唤醒这个条件notEmpty，当前线程才可以继续去做“弹出一个元素”的行为。</p>
</blockquote>
<ul>
<li>
<p>条件锁流程</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// AbstractQueuedSynchronizer.ConditionObject.await()
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">await</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> InterruptedException <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 如果线程中断了，抛出异常
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">interrupted</span><span style="color:#f92672">())</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InterruptedException<span style="color:#f92672">();</span>
    <span style="color:#75715e">// 添加节点到Condition的队列中，并返回该节点
</span><span style="color:#75715e"></span>    Node node <span style="color:#f92672">=</span> addConditionWaiter<span style="color:#f92672">();</span>
    <span style="color:#75715e">// 完全释放当前线程获取的锁
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 因为锁是可重入的，所以这里要把获取的锁全部释放
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> savedState <span style="color:#f92672">=</span> fullyRelease<span style="color:#f92672">(</span>node<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">int</span> interruptMode <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 是否在同步队列中
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>isOnSyncQueue<span style="color:#f92672">(</span>node<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 阻塞当前线程
</span><span style="color:#75715e"></span>        LockSupport<span style="color:#f92672">.</span><span style="color:#a6e22e">park</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>

        <span style="color:#75715e">// 上面部分是调用await()时释放自己占有的锁，并阻塞自己等待条件的出现
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// *************************分界线*************************  //
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 下面部分是条件已经出现，尝试去获取锁
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>interruptMode <span style="color:#f92672">=</span> checkInterruptWhileWaiting<span style="color:#f92672">(</span>node<span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> 0<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">// 尝试获取锁，注意第二个参数，这是上一章分析过的方法
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果没获取到会再次阻塞（这个方法这里就不贴出来了，有兴趣的翻翻上一章的内容）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>acquireQueued<span style="color:#f92672">(</span>node<span style="color:#f92672">,</span> savedState<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> interruptMode <span style="color:#f92672">!=</span> THROW_IE<span style="color:#f92672">)</span>
        interruptMode <span style="color:#f92672">=</span> REINTERRUPT<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 清除取消的节点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">nextWaiter</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#75715e">// clean up if cancelled
</span><span style="color:#75715e"></span>        unlinkCancelledWaiters<span style="color:#f92672">();</span>
    <span style="color:#75715e">// 线程中断相关
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>interruptMode <span style="color:#f92672">!=</span> 0<span style="color:#f92672">)</span>
        reportInterruptAfterWait<span style="color:#f92672">(</span>interruptMode<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// AbstractQueuedSynchronizer.ConditionObject.addConditionWaiter
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">addConditionWaiter</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    Node t <span style="color:#f92672">=</span> lastWaiter<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 如果条件队列的尾节点已取消，从头节点开始清除所有已取消的节点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>t <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> t<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">!=</span> Node<span style="color:#f92672">.</span><span style="color:#a6e22e">CONDITION</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        unlinkCancelledWaiters<span style="color:#f92672">();</span>
        <span style="color:#75715e">// 重新获取尾节点
</span><span style="color:#75715e"></span>        t <span style="color:#f92672">=</span> lastWaiter<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// 新建一个节点，它的等待状态是CONDITION
</span><span style="color:#75715e"></span>    Node node <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">(),</span> Node<span style="color:#f92672">.</span><span style="color:#a6e22e">CONDITION</span><span style="color:#f92672">);</span>
    <span style="color:#75715e">// 如果尾节点为空，则把新节点赋值给头节点（相当于初始化队列）
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 否则把新节点赋值给尾节点的nextWaiter指针
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>t <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
        firstWaiter <span style="color:#f92672">=</span> node<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">else</span>
        t<span style="color:#f92672">.</span><span style="color:#a6e22e">nextWaiter</span> <span style="color:#f92672">=</span> node<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 尾节点指向新节点
</span><span style="color:#75715e"></span>    lastWaiter <span style="color:#f92672">=</span> node<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 返回新节点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> node<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// AbstractQueuedSynchronizer.fullyRelease
</span><span style="color:#75715e"></span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">fullyRelease</span><span style="color:#f92672">(</span>Node node<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">boolean</span> failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 获取状态变量的值，重复获取锁，这个值会一直累加
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 所以这个值也代表着获取锁的次数
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> savedState <span style="color:#f92672">=</span> getState<span style="color:#f92672">();</span>
        <span style="color:#75715e">// 一次性释放所有获得的锁
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>release<span style="color:#f92672">(</span>savedState<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            <span style="color:#75715e">// 返回获取锁的次数
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> savedState<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalMonitorStateException<span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>failed<span style="color:#f92672">)</span>
            node<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">=</span> Node<span style="color:#f92672">.</span><span style="color:#a6e22e">CANCELLED</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// AbstractQueuedSynchronizer.isOnSyncQueue
</span><span style="color:#75715e"></span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isOnSyncQueue</span><span style="color:#f92672">(</span>Node node<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 如果等待状态是CONDITION，或者前一个指针为空，返回false
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 说明还没有移到AQS的队列中
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">==</span> Node<span style="color:#f92672">.</span><span style="color:#a6e22e">CONDITION</span> <span style="color:#f92672">||</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">// 如果next指针有值，说明已经移到AQS的队列中了
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#75715e">// If has successor, it must be on queue
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">// 从AQS的尾节点开始往前寻找看是否可以找到当前节点，找到了也说明已经在AQS的队列中了
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> findNodeFromTail<span style="color:#f92672">(</span>node<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

</code></pre></div><p>条件通知方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// AbstractQueuedSynchronizer.ConditionObject.signal
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">signal</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 如果不是当前线程占有着锁，调用这个方法抛出异常
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 说明signal()也要在获取锁之后执行
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>isHeldExclusively<span style="color:#f92672">())</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalMonitorStateException<span style="color:#f92672">();</span>
    <span style="color:#75715e">// 条件队列的头节点
</span><span style="color:#75715e"></span>    Node first <span style="color:#f92672">=</span> firstWaiter<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 如果有等待条件的节点，则通知它条件已成立
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>first <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
        doSignal<span style="color:#f92672">(</span>first<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// AbstractQueuedSynchronizer.ConditionObject.doSignal
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doSignal</span><span style="color:#f92672">(</span>Node first<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">do</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 移到条件队列的头节点往后一位
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span> <span style="color:#f92672">(</span>firstWaiter <span style="color:#f92672">=</span> first<span style="color:#f92672">.</span><span style="color:#a6e22e">nextWaiter</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
            lastWaiter <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 相当于把头节点从队列中出队
</span><span style="color:#75715e"></span>        first<span style="color:#f92672">.</span><span style="color:#a6e22e">nextWaiter</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 转移节点到AQS队列中
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>transferForSignal<span style="color:#f92672">(</span>first<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span>
             <span style="color:#f92672">(</span>first <span style="color:#f92672">=</span> firstWaiter<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// AbstractQueuedSynchronizer.transferForSignal
</span><span style="color:#75715e"></span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">transferForSignal</span><span style="color:#f92672">(</span>Node node<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 把节点的状态更改为0，也就是说即将移到AQS队列中
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果失败了，说明节点已经被改成取消状态了
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 返回false，通过上面的循环可知会寻找下一个可用节点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>compareAndSetWaitStatus<span style="color:#f92672">(</span>node<span style="color:#f92672">,</span> Node<span style="color:#f92672">.</span><span style="color:#a6e22e">CONDITION</span><span style="color:#f92672">,</span> 0<span style="color:#f92672">))</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>

    <span style="color:#75715e">// 调用AQS的入队方法把节点移到AQS的队列中
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 注意，这里enq()的返回值是node的上一个节点，也就是旧尾节点
</span><span style="color:#75715e"></span>    Node p <span style="color:#f92672">=</span> enq<span style="color:#f92672">(</span>node<span style="color:#f92672">);</span>
    <span style="color:#75715e">// 上一个节点的等待状态
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> ws <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">// 如果上一个节点已取消了，或者更新状态为SIGNAL失败（也是说明上一个节点已经取消了）
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 则直接唤醒当前节点对应的线程
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>ws <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>compareAndSetWaitStatus<span style="color:#f92672">(</span>p<span style="color:#f92672">,</span> ws<span style="color:#f92672">,</span> Node<span style="color:#f92672">.</span><span style="color:#a6e22e">SIGNAL</span><span style="color:#f92672">))</span>
        LockSupport<span style="color:#f92672">.</span><span style="color:#a6e22e">unpark</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">thread</span><span style="color:#f92672">);</span>
    <span style="color:#75715e">// 如果更新上一个节点的等待状态为SIGNAL成功了
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 则返回true，这时上面的循环不成立了，退出循环，也就是只通知了一个节点
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 此时当前节点还是阻塞状态
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 也就是说调用signal()的时候并不会真正唤醒一个节点
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 只是把节点从条件队列移到AQS队列中
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

</code></pre></div><p><strong>条件锁获取流程</strong></p>
<p>（1）新建一个节点加入到条件队列中去；</p>
<p>（2）完全释放当前线程占有的锁；</p>
<p>（3）阻塞当前线程，并等待条件的出现；</p>
<p>（4）条件已出现（此时节点已经移到AQS的队列中），尝试获取锁；</p>
<p><strong>条件锁的唤醒流程</strong></p>
<p>（1）从条件队列的头节点开始寻找一个非取消状态的节点；</p>
<p>（2）把它从条件队列移到AQS队列；</p>
<p>（3）且只移动一个节点；</p>
</li>
</ul>
</li>
<li>
<p>为什么ReentrantLock默认采用的是非公平模式？</p>
<p>答：因为非公平模式效率比较高。</p>
<p>为什么非公平模式效率比较高？</p>
<p>答：因为非公平模式会在一开始就尝试两次获取锁，如果当时正好state的值为0，它就会成功获取到锁，少了排队导致的阻塞/唤醒过程，并且减少了线程频繁的切换带来的性能损耗。</p>
<p>非公平模式有什么弊端？</p>
<p>答：非公平模式有可能会导致一开始排队的线程一直获取不到锁，导致线程饿死。</p>
</li>
<li>
<p>公平非公平的实现方法</p>
<p><strong>公平锁在实现的时候，会先去检查自己这node前面有没有其他node去排队了</strong></p>
<p><strong>而非公平锁，不会去检查，而是直接去尝试获取锁</strong></p>
</li>
</ul>
<h3 id="reetrantwhritereadlock是怎么实现读写锁的">ReetrantWhriteReadLock是怎么实现读写锁的</h3>
<p>读写锁</p>
<p>读锁：多个线程可以获取同一把锁</p>
<p>写锁：多个线程只有一个线程可以获取到写锁</p>
<ul>
<li>读锁流程</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// ReentrantReadWriteLock.ReadLock.lock()
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    sync<span style="color:#f92672">.</span><span style="color:#a6e22e">acquireShared</span><span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// AbstractQueuedSynchronizer.acquireShared()
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">acquireShared</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> arg<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 尝试获取共享锁（返回1表示成功，返回-1表示失败）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tryAcquireShared<span style="color:#f92672">(</span>arg<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
        <span style="color:#75715e">// 失败了就可能要排队
</span><span style="color:#75715e"></span>        doAcquireShared<span style="color:#f92672">(</span>arg<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// ReentrantReadWriteLock.Sync.tryAcquireShared()
</span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">tryAcquireShared</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> unused<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Thread current <span style="color:#f92672">=</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">();</span>
    <span style="color:#75715e">// 状态变量的值
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 在读写锁模式下，高16位存储的是共享锁（读锁）被获取的次数，低16位存储的是互斥锁（写锁）被获取的次数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> getState<span style="color:#f92672">();</span>
    <span style="color:#75715e">// 互斥锁的次数
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果其它线程获得了写锁，直接返回-1
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>exclusiveCount<span style="color:#f92672">(</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> 0 <span style="color:#f92672">&amp;&amp;</span>
        getExclusiveOwnerThread<span style="color:#f92672">()</span> <span style="color:#f92672">!=</span> current<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 读锁被获取的次数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> sharedCount<span style="color:#f92672">(</span>c<span style="color:#f92672">);</span>
    
    <span style="color:#75715e">// 下面说明此时还没有写锁，尝试去更新state的值获取读锁
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 读者是否需要排队（是否是公平模式）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>readerShouldBlock<span style="color:#f92672">()</span> <span style="color:#f92672">&amp;&amp;</span>
        r <span style="color:#f92672">&lt;</span> MAX_COUNT <span style="color:#f92672">&amp;&amp;</span>
        compareAndSetState<span style="color:#f92672">(</span>c<span style="color:#f92672">,</span> c <span style="color:#f92672">+</span> SHARED_UNIT<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 获取读锁成功
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>r <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 如果之前还没有线程获取读锁
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 记录第一个读者为当前线程
</span><span style="color:#75715e"></span>            firstReader <span style="color:#f92672">=</span> current<span style="color:#f92672">;</span>
            <span style="color:#75715e">// 第一个读者重入的次数为1
</span><span style="color:#75715e"></span>            firstReaderHoldCount <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>firstReader <span style="color:#f92672">==</span> current<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 如果有线程获取了读锁且是当前线程是第一个读者
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 则把其重入次数加1
</span><span style="color:#75715e"></span>            firstReaderHoldCount<span style="color:#f92672">++;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 如果有线程获取了读锁且当前线程不是第一个读者
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 则从缓存中获取重入次数保存器
</span><span style="color:#75715e"></span>            HoldCounter rh <span style="color:#f92672">=</span> cachedHoldCounter<span style="color:#f92672">;</span>
            <span style="color:#75715e">// 如果缓存不属性当前线程
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 再从ThreadLocal中获取
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// readHolds本身是一个ThreadLocal，里面存储的是HoldCounter
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>rh <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> rh<span style="color:#f92672">.</span><span style="color:#a6e22e">tid</span> <span style="color:#f92672">!=</span> getThreadId<span style="color:#f92672">(</span>current<span style="color:#f92672">))</span>
                <span style="color:#75715e">// get()的时候会初始化rh
</span><span style="color:#75715e"></span>                cachedHoldCounter <span style="color:#f92672">=</span> rh <span style="color:#f92672">=</span> readHolds<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>rh<span style="color:#f92672">.</span><span style="color:#a6e22e">count</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span>
                <span style="color:#75715e">// 如果rh的次数为0，把它放到ThreadLocal中去
</span><span style="color:#75715e"></span>                readHolds<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span>rh<span style="color:#f92672">);</span>
            <span style="color:#75715e">// 重入的次数加1（初始次数为0）
</span><span style="color:#75715e"></span>            rh<span style="color:#f92672">.</span><span style="color:#a6e22e">count</span><span style="color:#f92672">++;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 获取读锁成功，返回1
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> 1<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// 通过这个方法再去尝试获取读锁（如果之前其它线程获取了写锁，一样返回-1表示失败）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> fullTryAcquireShared<span style="color:#f92672">(</span>current<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// AbstractQueuedSynchronizer.doAcquireShared()
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doAcquireShared</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> arg<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 进入AQS的队列中
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">final</span> Node node <span style="color:#f92672">=</span> addWaiter<span style="color:#f92672">(</span>Node<span style="color:#f92672">.</span><span style="color:#a6e22e">SHARED</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">boolean</span> failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">boolean</span> interrupted <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 当前节点的前一个节点
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">final</span> Node p <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">predecessor</span><span style="color:#f92672">();</span>
            <span style="color:#75715e">// 如果前一个节点是头节点（说明是第一个排队的节点）
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p <span style="color:#f92672">==</span> head<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 再次尝试获取读锁
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> tryAcquireShared<span style="color:#f92672">(</span>arg<span style="color:#f92672">);</span>
                <span style="color:#75715e">// 如果成功了
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>r <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    <span style="color:#75715e">// 头节点后移并传播
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// 传播即唤醒后面连续的读节点
</span><span style="color:#75715e"></span>                    setHeadAndPropagate<span style="color:#f92672">(</span>node<span style="color:#f92672">,</span> r<span style="color:#f92672">);</span>
                    p<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> <span style="color:#75715e">// help GC
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>interrupted<span style="color:#f92672">)</span>
                        selfInterrupt<span style="color:#f92672">();</span>
                    failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
                    <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
            <span style="color:#75715e">// 没获取到读锁，阻塞并等待被唤醒
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>shouldParkAfterFailedAcquire<span style="color:#f92672">(</span>p<span style="color:#f92672">,</span> node<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span>
                parkAndCheckInterrupt<span style="color:#f92672">())</span>
                interrupted <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>failed<span style="color:#f92672">)</span>
            cancelAcquire<span style="color:#f92672">(</span>node<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// AbstractQueuedSynchronizer.setHeadAndPropagate()
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setHeadAndPropagate</span><span style="color:#f92672">(</span>Node node<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> propagate<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// h为旧的头节点
</span><span style="color:#75715e"></span>    Node h <span style="color:#f92672">=</span> head<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 设置当前节点为新头节点
</span><span style="color:#75715e"></span>    setHead<span style="color:#f92672">(</span>node<span style="color:#f92672">);</span>
    
    <span style="color:#75715e">// 如果旧的头节点或新的头节点为空或者其等待状态小于0（表示状态为SIGNAL/PROPAGATE）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>propagate <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">||</span> h <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> h<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span>
        <span style="color:#f92672">(</span>h <span style="color:#f92672">=</span> head<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> h<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 需要传播
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 取下一个节点
</span><span style="color:#75715e"></span>        Node s <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 如果下一个节点为空，或者是需要获取读锁的节点
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>s <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">isShared</span><span style="color:#f92672">())</span>
            <span style="color:#75715e">// 唤醒下一个节点
</span><span style="color:#75715e"></span>            doReleaseShared<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// AbstractQueuedSynchronizer.doReleaseShared()
</span><span style="color:#75715e">// 这个方法只会唤醒一个节点
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doReleaseShared</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
        Node h <span style="color:#f92672">=</span> head<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> h <span style="color:#f92672">!=</span> tail<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> ws <span style="color:#f92672">=</span> h<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span><span style="color:#f92672">;</span>
            <span style="color:#75715e">// 如果头节点状态为SIGNAL，说明要唤醒下一个节点
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>ws <span style="color:#f92672">==</span> Node<span style="color:#f92672">.</span><span style="color:#a6e22e">SIGNAL</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>compareAndSetWaitStatus<span style="color:#f92672">(</span>h<span style="color:#f92672">,</span> Node<span style="color:#f92672">.</span><span style="color:#a6e22e">SIGNAL</span><span style="color:#f92672">,</span> 0<span style="color:#f92672">))</span>
                    <span style="color:#66d9ef">continue</span><span style="color:#f92672">;</span>            <span style="color:#75715e">// loop to recheck cases
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// 唤醒下一个节点
</span><span style="color:#75715e"></span>                unparkSuccessor<span style="color:#f92672">(</span>h<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>ws <span style="color:#f92672">==</span> 0 <span style="color:#f92672">&amp;&amp;</span>
                     <span style="color:#75715e">// 把头节点的状态改为PROPAGATE成功才会跳到下面的if
</span><span style="color:#75715e"></span>                     <span style="color:#f92672">!</span>compareAndSetWaitStatus<span style="color:#f92672">(</span>h<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> Node<span style="color:#f92672">.</span><span style="color:#a6e22e">PROPAGATE</span><span style="color:#f92672">))</span>
                <span style="color:#66d9ef">continue</span><span style="color:#f92672">;</span>                <span style="color:#75715e">// loop on failed CAS
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 如果唤醒后head没变，则跳出循环
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">==</span> head<span style="color:#f92672">)</span>                   <span style="color:#75715e">// loop if head changed
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

</code></pre></div><ul>
<li>
<p>写锁流程</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock.lock()
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    sync<span style="color:#f92672">.</span><span style="color:#a6e22e">acquire</span><span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire()
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">acquire</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> arg<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 先尝试获取锁
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果失败，则会进入队列中排队，后面的逻辑跟ReentrantLock一模一样了
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>tryAcquire<span style="color:#f92672">(</span>arg<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span>
        acquireQueued<span style="color:#f92672">(</span>addWaiter<span style="color:#f92672">(</span>Node<span style="color:#f92672">.</span><span style="color:#a6e22e">EXCLUSIVE</span><span style="color:#f92672">),</span> arg<span style="color:#f92672">))</span>
        selfInterrupt<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// java.util.concurrent.locks.ReentrantReadWriteLock.Sync.tryAcquire()
</span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAcquire</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> acquires<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Thread current <span style="color:#f92672">=</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">();</span>
    <span style="color:#75715e">// 状态变量state的值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> getState<span style="color:#f92672">();</span>
    <span style="color:#75715e">// 互斥锁被获取的次数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> exclusiveCount<span style="color:#f92672">(</span>c<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>c <span style="color:#f92672">!=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 如果c!=0且w==0，说明共享锁被获取的次数不为0
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 这句话整个的意思就是
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 如果共享锁被获取的次数不为0，或者被其它线程获取了互斥锁（写锁）
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 那么就返回false，获取写锁失败
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>w <span style="color:#f92672">==</span> 0 <span style="color:#f92672">||</span> current <span style="color:#f92672">!=</span> getExclusiveOwnerThread<span style="color:#f92672">())</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 溢出检测
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>w <span style="color:#f92672">+</span> exclusiveCount<span style="color:#f92672">(</span>acquires<span style="color:#f92672">)</span> <span style="color:#f92672">&gt;</span> MAX_COUNT<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Maximum lock count exceeded&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#75715e">// 到这里说明当前线程已经获取过写锁，这里是重入了，直接把state加1即可
</span><span style="color:#75715e"></span>        setState<span style="color:#f92672">(</span>c <span style="color:#f92672">+</span> acquires<span style="color:#f92672">);</span>
        <span style="color:#75715e">// 获取写锁成功
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// 如果c等于0，就尝试更新state的值（非公平模式writerShouldBlock()返回false）
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果失败了，说明获取写锁失败，返回false
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果成功了，说明获取写锁成功，把自己设置为占有者，并返回true
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>writerShouldBlock<span style="color:#f92672">()</span> <span style="color:#f92672">||</span>
        <span style="color:#f92672">!</span>compareAndSetState<span style="color:#f92672">(</span>c<span style="color:#f92672">,</span> c <span style="color:#f92672">+</span> acquires<span style="color:#f92672">))</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    setExclusiveOwnerThread<span style="color:#f92672">(</span>current<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 获取写锁失败了后面的逻辑跟ReentrantLock是一致的，进入队列排队，这里就不列源码了
</span><span style="color:#75715e"></span>
</code></pre></div></li>
<li>
<p>总结</p>
</li>
</ul>
<p>（1）ReentrantReadWriteLock采用读写锁的思想，能提高并发的吞吐量；</p>
<p>（2）读锁使用的是共享锁，多个读锁可以一起获取锁，互相不会影响，即读读不互斥；</p>
<p>（3）读写、写读和写写是会互斥的，前者占有着锁，后者需要进入AQS队列中排队；</p>
<p>（4）多个连续的读线程是一个接着一个被唤醒的，而不是一次性唤醒所有读线程；</p>
<p>（5）只有多个读锁都完全释放了才会唤醒下一个写线程；</p>
<p>（6）只有写锁完全释放了才会唤醒下一个等待者，这个等待者有可能是读线程，也可能是写线程；</p>
<ul>
<li>
<p>同一个线程先写后读，是什么情况</p>
<p>会阻塞，获取不到读的锁</p>
</li>
<li>
<p>同一个线程先读后写</p>
<p>正常</p>
</li>
</ul>
<h3 id="cas是什么怎么解决aba问题">CAS是什么，怎么解决ABA问题</h3>
<p>CAS是CPU的原子指令器，通过自选的方式，属于乐观锁，与java的悲观锁相比效率更高。</p>
<p>ABA，只的是多个线程同时在更新的时候，例如A线程要把target变为1，目前是2，A读到了2，然后修改成1后，又修改成2，然后B读到了2。</p>
<!-- raw HTML omitted -->
<p>解决方式</p>
<ul>
<li>
<p>版本号：</p>
<p>AtomicStampedReference：维护了一个版本号</p>
<p>AtomicMarkableReference：维护了一个Boolean，标记是否更改过</p>
</li>
</ul>
<h3 id="concurrenthashmap的分段锁">ConcurrentHashMap的分段锁</h3>
<h3 id="你用过哪些javautilconcurrent下的类">你用过哪些Java.util.concurrent下的类</h3>
<ul>
<li>
<p>Semaphore</p>
<p>Semaphore，信号量，它保存了一系列的许可（permits），每次调用acquire()都将消耗一个许可，每次调用release()都将归还一个许可。</p>
<p>（1）Semaphore，也叫信号量，通常用于控制同一时刻对共享资源的访问上，也就是限流场景；</p>
<p>（2）Semaphore的内部实现是基于AQS的共享锁来实现的；</p>
<p>（3）Semaphore初始化的时候需要指定许可的次数，许可的次数是存储在state中；</p>
<p>（4）获取一个许可时，则state值减1；</p>
<p>（5）释放一个许可时，则state值加1；</p>
<p>（6）可以动态减少n个许可；</p>
<p>（7）可以动态增加n个许可吗:调用release(int permits)即可。我们知道释放许可的时候state的值会相应增加，再回头看看释放许可的源码，发现与ReentrantLock的释放锁还是有点区别的，Semaphore释放许可的时候并不会检查当前线程有没有获取过许可，所以可以调用释放许可的方法动态增加一些许可。</p>
</li>
<li>
<p>CountDownLatch</p>
<p>CountDownLatch，可以翻译为倒计时器，但是似乎不太准确，它的含义是允许一个或多个线程等待其它线程的操作执行完毕后再执行后续的操作。</p>
<p>CountDownLatch的通常用法和Thread.join()有点类似，等待其它线程都完成后再执行主任务。</p>
</li>
<li>
<p>CyclicBarrier</p>
<p>CyclicBarrier，回环栅栏，它会阻塞一组线程直到这些线程同时达到某个条件才继续执行。它与CountDownLatch很类似，但又不同，CountDownLatch需要调用countDown()方法触发事件，而CyclicBarrier不需要，它就像一个栅栏一样，当一组线程都到达了栅栏处才继续往下走。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CyclicBarrierTest</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        CyclicBarrier cyclicBarrier <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CyclicBarrier<span style="color:#f92672">(</span>3<span style="color:#f92672">);</span>

        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 3<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()-&gt;{</span>
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;before&#34;</span><span style="color:#f92672">);</span>
                <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                    cyclicBarrier<span style="color:#f92672">.</span><span style="color:#a6e22e">await</span><span style="color:#f92672">();</span>
                <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
                <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>BrokenBarrierException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
                <span style="color:#f92672">}</span>
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;after&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#f92672">}).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>    

</code></pre></div></li>
<li>
<p>Phaser</p>
<p>Phaser，翻译为阶段，它适用于这样一种场景，一个大任务可以分为多个阶段完成，且每个阶段的任务可以多个线程并发执行，但是必须上一个阶段的任务都完成了才可以执行下一个阶段的任务。</p>
<p>这种场景虽然使用CyclicBarrier或者CountryDownLatch也可以实现，但是要复杂的多。首先，具体需要多少个阶段是可能会变的，其次，每个阶段的任务数也可能会变的。相比于CyclicBarrier和CountDownLatch，Phaser更加灵活更加方便。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PhaserTest</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> PARTIES <span style="color:#f92672">=</span> 3<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> PHASES <span style="color:#f92672">=</span> 4<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        Phaser phaser <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Phaser<span style="color:#f92672">(</span>PARTIES<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#a6e22e">@Override</span>
            <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">onAdvance</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> phase<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> registeredParties<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 【本篇文章由公众号“彤哥读源码”原创，请支持原创，谢谢！】
</span><span style="color:#75715e"></span>                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;=======phase: &#34;</span> <span style="color:#f92672">+</span> phase <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; finished=============&#34;</span><span style="color:#f92672">);</span>
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">super</span><span style="color:#f92672">.</span><span style="color:#a6e22e">onAdvance</span><span style="color:#f92672">(</span>phase<span style="color:#f92672">,</span> registeredParties<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">};</span>

        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> PARTIES<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()-&gt;{</span>
                <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> PHASES<span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
                    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>String<span style="color:#f92672">.</span><span style="color:#a6e22e">format</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;%s: phase: %d&#34;</span><span style="color:#f92672">,</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">(),</span> j<span style="color:#f92672">));</span>
                    phaser<span style="color:#f92672">.</span><span style="color:#a6e22e">arriveAndAwaitAdvance</span><span style="color:#f92672">();</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">},</span> <span style="color:#e6db74">&#34;Thread &#34;</span> <span style="color:#f92672">+</span> i<span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

</code></pre></div></li>
</ul>
<h3 id="讲一下线程池的几个参数含义">讲一下线程池的几个参数含义</h3>
<p>它有7个参数，分别为corePoolSize、maximumPoolSize、keepAliveTime、unit、workQueue、threadFactory、handler。</p>
<ul>
<li>
<p>corePoolSize</p>
<p>核心线程数。</p>
<p>当正在运行的线程数小于核心线程数时，来一个任务就创建一个核心线程；</p>
<p>当正在运行的线程数大于或等于核心线程数时，任务来了先不创建线程而是丢到任务队列中。</p>
</li>
<li>
<p>maximumPoolSize</p>
<p>最大线程数。</p>
<p>当任务队列满了时，来一个任务才创建一个非核心线程，但不能超过最大线程数。</p>
</li>
<li>
<p>keepAliveTime + unit</p>
<p>线程保持空闲时间及单位。</p>
<p>默认情况下，此两参数仅当正在运行的线程数大于核心线程数时才有效，即只针对非核心线程。</p>
<p>但是，如果allowCoreThreadTimeOut被设置成了true，针对核心线程也有效。</p>
<p>即当任务队列为空时，线程保持多久才会销毁，内部主要是通过阻塞队列带超时的poll(timeout, unit)方法实现的。</p>
</li>
<li>
<p>workQueue</p>
<p>任务队列。</p>
<p>当正在运行的线程数大于或等于核心线程数时，任务来了是先进入任务队列中的。</p>
<p>这个队列必须是阻塞队列，所以像ConcurrentLinkedQueue就不能作为参数，因为它虽然是并发安全的队列，但是它不是阻塞队列。</p>
</li>
<li>
<p>threadFactory</p>
<p>线程工厂。</p>
<p>默认使用的是Executors工具类中的DefaultThreadFactory类，这个类有个缺点，创建的线程的名称是自动生成的，无法自定义以区分不同的线程池，且它们都是非守护线程。</p>
</li>
<li>
<p>handler</p>
<p>拒绝策略。</p>
<p>拒绝策略表示当任务队列满了且线程数也达到最大了，这时候再新加任务，线程池已经无法承受了，这些新来的任务应该按什么逻辑来处理。</p>
<p>常用的拒绝策略有丢弃当前任务、丢弃最老的任务、抛出异常、调用者自己处理等待。</p>
<p>默认的拒绝策略是抛出异常，即线程池无法承载了，调用者再往里面添加任务会抛出异常。</p>
<p>默认的拒绝策略虽然比较简单粗暴，但是相对于丢弃任务策略明显要好很多，最起码调用者自己可以捕获这个异常再进行二次处理。</p>
</li>
</ul>
<h3 id="synchronized关键字怎么优化的膨胀的流程">synchronized关键字，怎么优化的，膨胀的流程</h3>
<p><strong>简介</strong></p>
<p>synchronized关键字是Java里面最基本的同步手段，它经过编译之后，会在同步块的前后分别生成 monitorenter 和 monitorexit 字节码指令，这两个字节码指令都需要一个引用类型的参数来指明要锁定和解锁的对象。</p>
<p><strong>实现原理</strong></p>
<p>在学习Java内存模型的时候，我们介绍过两个指令：lock 和 unlock。</p>
<p>lock，锁定，作用于主内存的变量，它把主内存中的变量标识为一条线程独占状态。</p>
<p>unlock，解锁，作用于主内存的变量，它把锁定的变量释放出来，释放出来的变量才可以被其它线程锁定。</p>
<p>但是这两个指令并没有直接提供给用户使用，而是提供了两个更高层次的指令 monitorenter 和 monitorexit 来隐式地使用 lock 和 unlock 指令。</p>
<p>而 synchronized 就是使用 monitorenter 和 monitorexit 这两个指令来实现的。</p>
<p>根据JVM规范的要求，在执行monitorenter指令的时候，首先要去尝试获取对象的锁，如果这个对象没有被锁定，或者当前线程已经拥有了这个对象的锁，就把锁的计数器加1，相应地，在执行monitorexit的时候会把计数器减1，当计数器减小为0时，锁就释放了。</p>
<blockquote>
<p>前面讲解Java内存模型的时候我们说过内存模型主要就是用来解决缓存一致性的问题的，而缓存一致性主要包括原子性、可见性、有序性。</p>
<p>那么，synchronized关键字能否保证这三个特性呢？</p>
<p>还是回到Java内存模型上来，synchronized关键字底层是通过monitorenter和monitorexit实现的，而这两个指令又是通过lock和unlock来实现的。</p>
<p>而lock和unlock在Java内存模型中是必须满足下面四条规则的：</p>
<p>（1）一个变量同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一个线程执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才能被解锁。</p>
<p>（2）如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值；</p>
<p>（3）如果一个变量没有被lock操作锁定，则不允许对其执行unlock操作，也不允许unlock一个其它线程锁定的变量；</p>
<p>（4）对一个变量执行unlock操作之前，必须先把此变量同步回主内存中，即执行store和write操作；</p>
<p>通过规则（1），我们知道对于lock和unlock之间的代码，同一时刻只允许一个线程访问，所以，synchronized是具有原子性的。</p>
<p>通过规则（1）（2）和（4），我们知道每次lock和unlock时都会从主内存加载变量或把变量刷新回主内存，而lock和unlock之间的变量（这里是指锁定的变量）是不会被其它线程修改的，所以，synchronized是具有可见性的。</p>
<p>通过规则（1）和（3），我们知道所有对变量的加锁都要排队进行，且其它线程不允许解锁当前线程锁定的对象，所以，synchronized是具有有序性的。</p>
<p>综上所述，synchronized是可以保证原子性、可见性和有序性的。</p>
</blockquote>
<p>优化过程：</p>
<p>（1）偏向锁，是指一段同步代码一直被一个线程访问，那么这个线程会自动获取锁，降低获取锁的代价。</p>
<p>（2）轻量级锁，是指当锁是偏向锁时，被另一个线程所访问，偏向锁会升级为轻量级锁，这个线程会通过自旋的方式尝试获取锁，不会阻塞，提高性能。</p>
<p>（3）重量级锁，是指当锁是轻量级锁时，当自旋的线程自旋了一定的次数后，还没有获取到锁，就会进入阻塞状态，该锁升级为重量级锁，重量级锁会使其他线程阻塞，性能降低。</p>
<h3 id="volatile关键字">volatile关键字</h3>
<p>我们说过可见性是指当一个线程修改了共享变量的值，其它线程能立即感知到这种变化。而普通变量无法做到立即感知这一点，变量的值在线程之间的传递均需要通过主内存来完成，比如，线程A修改了一个普通变量的值，然后向主内存回写，另外一条线程B只有在线程A的回写完成之后再从主内存中读取变量的值，才能够读取到新变量的值，也就是新变量才能对线程B可见。</p>
<p><strong>java内存模型规定，volatile变量的每次修改都必须立即回写到主内存中，volatile变量的每次使用都必须从主内存刷新最新的值。</strong></p>
<ul>
<li>
<p>volatile可以禁止cpu语意重排，保证了有序性</p>
<blockquote>
<p>普通变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获得正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致，因为一个线程的方法执行过程中无法感知到这点，这就是“线程内表现为串行的语义”</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">VolatileTest3</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> Config config <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">boolean</span> initialized <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 线程1负责初始化配置信息
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
            config <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Config<span style="color:#f92672">();</span>
            config<span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;config&#34;</span><span style="color:#f92672">;</span>
            initialized <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>

        <span style="color:#75715e">// 线程2检测到配置初始化完成后使用配置信息
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>initialized<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                LockSupport<span style="color:#f92672">.</span><span style="color:#a6e22e">parkNanos</span><span style="color:#f92672">(</span>TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">MILLISECONDS</span><span style="color:#f92672">.</span><span style="color:#a6e22e">toNanos</span><span style="color:#f92672">(</span>100<span style="color:#f92672">));</span>
            <span style="color:#f92672">}</span>

            <span style="color:#75715e">// do sth with config
</span><span style="color:#75715e"></span>            String name <span style="color:#f92672">=</span> config<span style="color:#f92672">.</span><span style="color:#a6e22e">name</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Config</span> <span style="color:#f92672">{</span>
    String name<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>在这个例子中，如果initialized不使用volatile来修饰，可能就会出现重排序，比如在初始化配置之前把initialized的值设置为了true，这样线程2读取到这个值为true了，就去使用配置了，这时候可能就会出现错误。</p>
</li>
<li>
<p>volatile提供了变量的可见性</p>
</li>
<li>
<p>缺陷，无法保证原子性</p>
</li>
</ul>
<h3 id="java内存模型">Java内存模型</h3>
<p>什么是Java内存模型？</p>
<p>多个缓存读写一致性以及乱序排序优化的问题，这就有了内存模型，它定义了共享内存系统中多线程读写操作行为的规范。</p>
<blockquote>
<p>Java内存模型（Java Memory Model，JMM）是在硬件内存模型基础上更高层的抽象，它屏蔽了各种硬件和操作系统对内存访问的差异性，从而实现让Java程序在各种平台下都能达到一致的并发效果。</p>
<p>Java内存模型定义了程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出这样的底层细节。这里所说的变量包括实例字段、静态字段，但不包括局部变量和方法参数，因为它们是线程私有的，它们不会被共享，自然不存在竞争问题。</p>
<p>为了获得更好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器调整代码的执行顺序等这类权利。</p>
<p>Java内存模型规定了所有的变量都存储在主内存中，这里的主内存跟介绍硬件时所用的名字一样，两者可以类比，但此处仅指虚拟机中内存的一部分。</p>
<p>除了主内存，每条线程还有自己的工作内存，此处可与CPU的高速缓存进行类比。工作内存中保存着该线程使用到的变量的主内存副本的拷贝，线程对变量的操作都必须在工作内存中进行，包括读取和赋值等，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递必须通过主内存来完成。</p>
</blockquote>
<!-- raw HTML omitted -->
<p>Java内存模型规定了所有的变量都存储在主内存中，这里的主内存跟介绍硬件时所用的名字一样，两者可以类比，但此处仅指虚拟机中内存的一部分。</p>
<p>除了主内存，每条线程还有自己的工作内存，此处可与CPU的高速缓存进行类比。工作内存中保存着该线程使用到的变量的主内存副本的拷贝，线程对变量的操作都必须在工作内存中进行，包括读取和赋值等，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递必须通过主内存来完成。</p>
<blockquote>
<p>Java内存模型就是为了解决多线程环境下共享变量的一致性问题，那么一致性包含哪些内容呢？</p>
<p>一致性主要包含三大特性：原子性、可见性、有序性，下面我们就来看看Java内存模型是怎么实现这三大特性的。</p>
<p>（1）原子性</p>
<p>原子性是指一段操作一旦开始就会一直运行到底，中间不会被其它线程打断，这段操作可以是一个操作，也可以是多个操作。</p>
<p>由Java内存模型来直接保证的原子性操作包括read、load、user、assign、store、write这两个操作，我们可以大致认为基本类型变量的读写是具备原子性的。</p>
<p>如果应用需要一个更大范围的原子性，Java内存模型还提供了lock和unlock这两个操作来满足这种需求，尽管不能直接使用这两个操作，但我们可以使用它们更具体的实现synchronized来实现。</p>
<p>因此，synchronized块之间的操作也是原子性的。</p>
<p>（2）可见性</p>
<p>可见性是指当一个线程修改了共享变量的值，其它线程能立即感知到这种变化。</p>
<p>Java内存模型是通过在变更修改后同步回主内存，在变量读取前从主内存刷新变量值来实现的，它是依赖主内存的，无论是普通变量还是volatile变量都是如此。</p>
<p>普通变量与volatile变量的主要区别是是否会在修改之后立即同步回主内存，以及是否在每次读取前立即从主内存刷新。因此我们可以说volatile变量保证了多线程环境下变量的可见性，但普通变量不能保证这一点。</p>
<p>除了volatile之外，还有两个关键字也可以保证可见性，它们是synchronized和final。</p>
<p>synchronized的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中，即执行store和write操作”这条规则获取的。</p>
<p>final的可见性是指被final修饰的字段在构造器中一旦被初始化完成，那么其它线程中就能看见这个final字段了。</p>
<p>（3）有序性</p>
<p>Java程序中天然的有序性可以总结为一句话：如果在本线程中观察，所有的操作都是有序的；如果在另一个线程中观察，所有的操作都是无序的。</p>
<p>前半句是指线程内表现为串行的语义，后半句是指“指令重排序”现象和“工作内存和主内存同步延迟”现象。</p>
<p>Java中提供了volatile和synchronized两个关键字来保证有序性。</p>
<p>volatile天然就具有有序性，因为其禁止重排序。</p>
<p>synchronized的有序性是由“一个变量同一时刻只允许一条线程对其进行lock操作”这条规则获取的。</p>
</blockquote>
<h3 id="threadlocal">ThreadLocal</h3>
<h1 id="java基础">Java基础</h1>
<h3 id="说下java的基本类型">说下Java的基本类型</h3>
<ul>
<li>
<p>byte/8bit/1B</p>
</li>
<li>
<p>char/16Bit/2B</p>
</li>
<li>
<p>short/16Bit/2B</p>
</li>
<li>
<p>int/32Bit/4B</p>
</li>
<li>
<p>float/32Bit/4B</p>
</li>
<li>
<p>long/64Bit/8B</p>
</li>
<li>
<p>double/64Bit/8B</p>
</li>
<li>
<p>boolen/~</p>
<blockquote>
<p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p>
</blockquote>
</li>
<li>
<p>自动拆包箱</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Integer x <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span>     <span style="color:#75715e">// 装箱 调用了 Integer.valueOf(2)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span>         <span style="color:#75715e">// 拆箱 调用了 X.intValue()
</span></code></pre></div><p><a href="https://blog.csdn.net/wufaliang003/article/details/82347077">参考</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Integer a <span style="color:#f92672">=</span> 300<span style="color:#f92672">;</span>
Integer b <span style="color:#f92672">=</span> 300<span style="color:#f92672">;</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>a <span style="color:#f92672">==</span> b<span style="color:#f92672">);</span><span style="color:#75715e">//返回false，因==比较的是对象的地址
</span><span style="color:#75715e"></span>
Integer a <span style="color:#f92672">=</span> 127<span style="color:#f92672">;</span>
Integer b <span style="color:#f92672">=</span> 127<span style="color:#f92672">;</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>a <span style="color:#f92672">==</span> b<span style="color:#f92672">);</span><span style="color:#75715e">//返回true，因java默认缓存了-128到127之间的值
</span><span style="color:#75715e"></span>
</code></pre></div></li>
<li>
<p>缓存池</p>
<p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象；</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Integer x <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>123<span style="color:#f92672">);</span>
Integer y <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>123<span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> y<span style="color:#f92672">);</span>    <span style="color:#75715e">// false
</span><span style="color:#75715e"></span>Integer z <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">valueOf</span><span style="color:#f92672">(</span>123<span style="color:#f92672">);</span>
Integer k <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">valueOf</span><span style="color:#f92672">(</span>123<span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>z <span style="color:#f92672">==</span> k<span style="color:#f92672">);</span>   <span style="color:#75715e">// true
</span></code></pre></div><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Integer <span style="color:#a6e22e">valueOf</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&gt;=</span> IntegerCache<span style="color:#f92672">.</span><span style="color:#a6e22e">low</span> <span style="color:#f92672">&amp;&amp;</span> i <span style="color:#f92672">&lt;=</span> IntegerCache<span style="color:#f92672">.</span><span style="color:#a6e22e">high</span><span style="color:#f92672">)</span>
        <span style="color:#66d9ef">return</span> IntegerCache<span style="color:#f92672">.</span><span style="color:#a6e22e">cache</span><span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> <span style="color:#f92672">(-</span>IntegerCache<span style="color:#f92672">.</span><span style="color:#a6e22e">low</span><span style="color:#f92672">)];</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
</ul>
<h3 id="重载和重写">重载和重写</h3>
<ul>
<li>重写是使用注解<code>@Override</code>重写父类的方法</li>
<li>重载是同一个类，相同方法名，但是参数个数，类型，顺序，有一个不一样。返回值类型可以一样可以不一样</li>
</ul>
<h3 id="讲一下string">讲一下String</h3>
<p>String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）</p>
<p>在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">String</span>
    <span style="color:#66d9ef">implements</span> java<span style="color:#f92672">.</span><span style="color:#a6e22e">io</span><span style="color:#f92672">.</span><span style="color:#a6e22e">Serializable</span><span style="color:#f92672">,</span> Comparable<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;,</span> CharSequence <span style="color:#f92672">{</span>
    <span style="color:#75715e">/** The value is used for character storage. */</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">char</span> value<span style="color:#f92672">[];</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">String</span>
    <span style="color:#66d9ef">implements</span> java<span style="color:#f92672">.</span><span style="color:#a6e22e">io</span><span style="color:#f92672">.</span><span style="color:#a6e22e">Serializable</span><span style="color:#f92672">,</span> Comparable<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;,</span> CharSequence <span style="color:#f92672">{</span>
    <span style="color:#75715e">/** The value is used for character storage. */</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> value<span style="color:#f92672">;</span>

    <span style="color:#75715e">/** The identifier of the encoding used to encode the bytes in {@code value}. */</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">byte</span> coder<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p>
<ul>
<li>String Pool</li>
</ul>
<p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。</p>
<p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p>
<p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 和 s2.intern() 方法取得同一个字符串引用。intern() 首先把 &ldquo;aaa&rdquo; 放到 String Pool 中，然后返回这个字符串引用，因此 s3 和 s4 引用的是同一个字符串。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">String s1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;aaa&#34;</span><span style="color:#f92672">);</span>
String s2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;aaa&#34;</span><span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>s1 <span style="color:#f92672">==</span> s2<span style="color:#f92672">);</span>           <span style="color:#75715e">// false
</span><span style="color:#75715e"></span>String s3 <span style="color:#f92672">=</span> s1<span style="color:#f92672">.</span><span style="color:#a6e22e">intern</span><span style="color:#f92672">();</span>
String s4 <span style="color:#f92672">=</span> s2<span style="color:#f92672">.</span><span style="color:#a6e22e">intern</span><span style="color:#f92672">();</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>s3 <span style="color:#f92672">==</span> s4<span style="color:#f92672">);</span>           <span style="color:#75715e">// true
</span></code></pre></div><p>如果是采用 &ldquo;bbb&rdquo; 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">String s5 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;bbb&#34;</span><span style="color:#f92672">;</span>
String s6 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;bbb&#34;</span><span style="color:#f92672">;</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>s5 <span style="color:#f92672">==</span> s6<span style="color:#f92672">);</span>  <span style="color:#75715e">// true
</span></code></pre></div><ul>
<li>
<p>new String(&ldquo;abc&rdquo;)</p>
<p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 &ldquo;abc&rdquo; 字符串对象）。</p>
<ul>
<li>&ldquo;abc&rdquo; 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 &ldquo;abc&rdquo; 字符串字面量；</li>
<li>而使用 new 的方式会在堆中创建一个字符串对象。</li>
</ul>
<p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NewStringTest</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        String s <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;abc&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
</ul>
<h3 id="讲一下final">讲一下final</h3>
<ul>
<li>final声明的数据为常量，初始化后不可以被更改</li>
<li>对于基本类型，final声明的变量，值不可以被更改</li>
<li>对于引用类型，final声明的变量，引用不可以被更改，也就是不能引用其他对象，但是被引用的对象本身可以修改</li>
<li>final修饰的方法，不能被子类重写</li>
<li>final修饰的类，不能被继承</li>
</ul>
<h3 id="讲一下static">讲一下Static</h3>
<ul>
<li>
<p>static修饰的变量叫静态变量，这个变量属于这个类，类的所有都共享变量，可以通过类名直接访问他，整个内存中只存在一份，在jvm方法区的静态常量池里</p>
</li>
<li>
<p>static修饰的方法叫静态方法，它不依赖于任何实例，所以静态方法必须要有实现，也就是不能abstract，内部也只能访问静态字段和静态方法，方法中不能有this或者super关键字，因为这两个关键字与具体的对象关联</p>
</li>
<li>
<p>static修饰的代码块，只会在类初始化的时候执行一次</p>
</li>
<li>
<p>static修饰的内部类是静态内部类，非静态内部类依赖于外部类的实例，也就是要先创建外部类的实例才可以用这个实例去创建非静态内部类，而静态内部类不需要。静态内部类不能访问外部类的非静态的变量和方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OuterClass</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InnerClass</span> <span style="color:#f92672">{</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StaticInnerClass</span> <span style="color:#f92672">{</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// InnerClass innerClass = new InnerClass(); // &#39;OuterClass.this&#39; cannot be referenced from a static context
</span><span style="color:#75715e"></span>        OuterClass outerClass <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> OuterClass<span style="color:#f92672">();</span>
        InnerClass innerClass <span style="color:#f92672">=</span> outerClass<span style="color:#f92672">.</span><span style="color:#a6e22e">new</span> <span style="color:#a6e22e">InnerClass</span><span style="color:#f92672">();</span>
        StaticInnerClass staticInnerClass <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StaticInnerClass<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p>存在继承的情况下，初始化顺序为：</p>
<ul>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
</li>
</ul>
<h3 id="讲一下equals和hashcode以及clone">讲一下equals和hashCode以及clone</h3>
<ul>
<li>
<p>equals</p>
<p><strong>等价与相等</strong></p>
<ul>
<li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li>
<li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">//重写
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EqualExample</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> x<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> y<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> z<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">EqualExample</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> x<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> y<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> z<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> y<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">z</span> <span style="color:#f92672">=</span> z<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Object o<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span> <span style="color:#f92672">==</span> o<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>o <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> getClass<span style="color:#f92672">()</span> <span style="color:#f92672">!=</span> o<span style="color:#f92672">.</span><span style="color:#a6e22e">getClass</span><span style="color:#f92672">())</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>

        EqualExample that <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>EqualExample<span style="color:#f92672">)</span> o<span style="color:#f92672">;</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">!=</span> that<span style="color:#f92672">.</span><span style="color:#a6e22e">x</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>y <span style="color:#f92672">!=</span> that<span style="color:#f92672">.</span><span style="color:#a6e22e">y</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span> z <span style="color:#f92672">==</span> that<span style="color:#f92672">.</span><span style="color:#a6e22e">z</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p>hashCode</p>
<p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</p>
<p>所以在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，<strong>保证等价的两个对象哈希值也相等</strong>。</p>
<p>HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。</p>
</li>
<li>
<p>clone</p>
<p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CloneExample</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> a<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> b<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>			
CloneExample e1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CloneExample<span style="color:#f92672">();</span>
<span style="color:#75715e">// CloneExample e2 = e1.clone(); // &#39;clone()&#39; has protected access in &#39;java.lang.Object&#39;
</span></code></pre></div><p>重写 clone() 得到以下实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CloneExample</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> a<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> b<span style="color:#f92672">;</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> CloneExample <span style="color:#a6e22e">clone</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> CloneNotSupportedException <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>CloneExample<span style="color:#f92672">)</span><span style="color:#66d9ef">super</span><span style="color:#f92672">.</span><span style="color:#a6e22e">clone</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
CloneExample e1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CloneExample<span style="color:#f92672">();</span>
<span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
    CloneExample e2 <span style="color:#f92672">=</span> e1<span style="color:#f92672">.</span><span style="color:#a6e22e">clone</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>CloneNotSupportedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
java<span style="color:#f92672">.</span><span style="color:#a6e22e">lang</span><span style="color:#f92672">.</span><span style="color:#a6e22e">CloneNotSupportedException</span><span style="color:#f92672">:</span> CloneExample
</code></pre></div><p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p>
<p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CloneExample</span> <span style="color:#66d9ef">implements</span> Cloneable <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> a<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> b<span style="color:#f92672">;</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> Object <span style="color:#a6e22e">clone</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> CloneNotSupportedException <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">super</span><span style="color:#f92672">.</span><span style="color:#a6e22e">clone</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
</ul>
<h3 id="如何实现浅拷贝和深拷贝">如何实现浅拷贝和深拷贝</h3>
<ul>
<li>
<p>浅拷贝</p>
<p>拷贝对象和原始对象的引用类型引用同一个对象。</p>
</li>
<li>
<p>深拷贝</p>
<p>拷贝对象和原始对象的引用类型引用不同对象。</p>
</li>
<li>
<p>替代clone的方法</p>
<p>重写一个工厂构造方法</p>
<p>用ObjectInputStrem和ObjectOutputStream</p>
</li>
</ul>
<h3 id="java限定符">java限定符</h3>
<p><img src="https://pic-frank.oss-cn-beijing.aliyuncs.com/img/202201261420990.png" alt="image-20220126142057927"></p>
<p>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p>
<p>可以对类或类中的成员（字段和方法）加上访问修饰符。</p>
<ul>
<li>类可见表示其它类可以用这个类创建实例对象。</li>
<li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li>
</ul>
<h3 id="接口和抽象类">接口和抽象类</h3>
<ul>
<li>
<p><strong>抽象类</strong></p>
<p>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。</p>
<p>抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。</p>
</li>
<li>
<p><strong>接口</strong></p>
<p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p>
<p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。</p>
<p>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。从 Java 9 开始，允许将方法定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去。</p>
<p>接口的字段默认都是 static 和 final 的。</p>
</li>
<li>
<p><strong>比较</strong></p>
<ul>
<li>从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li>
<li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li>
<li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li>
<li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li>
</ul>
</li>
</ul>
<h3 id="说一说你理解的多态">说一说你理解的多态</h3>
<ul>
<li>实现多态的必要条件：
<ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象：<strong>Parent p = new Child();</strong></li>
</ul>
</li>
<li>重写、接口、抽象类和抽象方法</li>
<li>多态实际上就是一种事物的不同体现，例如同样的human对象，实现可以是women也可以是man，这就是多态</li>
</ul>
<h3 id="讲一下泛型和注解">讲一下泛型和注解</h3>
<ul>
<li>
<p>注解就是代码中的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相对应的处理</p>
</li>
<li>
<p>开发中用到了哪些注解？</p>
<p>我用到Spring特别多，常见的@Controller，@Param，@Service，有的项目会用到lombok注解，@Data，@Slf4j等。java原生也有@Overried，@Deprecated，@FunctionalInterface，java原生的注解多用于标记和检查。</p>
<p>除了这些基本注解，还有一个注解叫元注解，用于描述注解的注解。常见的有@Retention,@Target。@Retention用于设置注解的生命周期，@Target用于设置注解的修饰地方，例如类、方法、参数，成员变量等</p>
<ul>
<li>@Retention注解传入的是RetentionPolicy枚举，该枚举有三个常量，分别是<strong>SOURCE、CLASS和RUNTIME</strong>，SOURCE代表着注解仅保留在源级别中，并由编译器忽略。CLASS代表着注解在编译时由编译器保留，但Java虚拟机（JVM）会忽略。RUNTIME代表着标记的注解会由JVM保留，因此运行时环境可以使用它。</li>
<li>
<!-- raw HTML omitted -->
</li>
<li>从上面的图可以发现有个「注解抽象语法树」，这里其实就会去解析注解，然后做处理的逻辑。如果你想要在编译期间处理注解相关的逻辑，你需要继承AbstractProcessor 并实现process方法。比如可以看到lombok就用AnnotationProcessor继承了AbstractProcessor。lombok的实现原理就是在这（为什么使用了个@Data这样的注解就能有set/get等方法了，就是在这里加上去的）</li>
</ul>
</li>
<li>
<p>泛型就是在创建对象或者调用方法时才明确具体的类型，使用泛型的好处就是代码更加简洁（不再需要强制转换），程序更加健壮（在编译期间没有警告，在运行期就不会出现ClassCastException异常），再明确一下泛型就是「在创建对象或调用方法的时候才明确下具体的类型」，而组件为了做到足够的通用性，是不知道「用户」传入什么类型参数进来的，所以在这种情况下用泛型就是很好的实践。</p>
<p>一般会使用反射+泛型组合使用</p>
</li>
</ul>
<h3 id="讲一下反射和动态代理">讲一下反射和动态代理</h3>
<ul>
<li>
<p>反射：简单说反射就是Java可以给我们在运行时获取类的信息，核心是在运行时。</p>
<p>运行时指的就是我们在编译器写的代码是 .java 文件，经过javac 编译会变成 .class 文件，class 文件会被JVM装载运行（这里就是真正运行着我们所写的代码（虽然是被编译过的），也就所谓的运行时。</p>
<p>获取类的原信息，字段和方法用的比较多</p>
<blockquote>
<p>每个类都有一个 <strong>Class</strong> 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p>
<p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>
<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p>
<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p>
<ul>
<li><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li>
<li><strong>Method</strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li>
<li><strong>Constructor</strong> ：可以用 Constructor 的 newInstance() 创建新的对象。</li>
</ul>
<p><strong>反射的优点：</strong></p>
<ul>
<li><strong>可扩展性</strong> ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</li>
<li><strong>类浏览器和可视化开发环境</strong> ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</li>
<li><strong>调试器和测试工具</strong> ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li>
</ul>
<p><strong>反射的缺点：</strong></p>
<p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p>
<ul>
<li><strong>性能开销</strong> ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</li>
<li><strong>安全限制</strong> ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</li>
<li><strong>内部暴露</strong> ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</li>
</ul>
</blockquote>
</li>
<li>
<p>动态代理</p>
<p>JDK自带的动态代理，实现InvocationHandler接口</p>
<p>CGLIB，通过修改字节码文件达到代理</p>
</li>
</ul>
<h3 id="java的几种引用你用过几种">Java的几种引用，你用过几种</h3>
<h3 id="说说进程和线程的区别">说说进程和线程的区别</h3>
<h1 id="java集合">Java集合</h1>
<h3 id="讲一讲集合类常用的集合以及在多线程下你是如何保集合安全的">讲一讲集合类，常用的集合，以及在多线程下你是如何保集合安全的</h3>
<ul>
<li>
<p>ArrayList</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 默认容量
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> DEFAULT_CAPACITY <span style="color:#f92672">=</span> 10<span style="color:#f92672">;</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 空数组，如果传入的容量为0时使用
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Object<span style="color:#f92672">[]</span> EMPTY_ELEMENTDATA <span style="color:#f92672">=</span> <span style="color:#f92672">{};</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 空数组，传传入容量时使用，添加第一个元素的时候会重新初始为默认容量大小
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Object<span style="color:#f92672">[]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span style="color:#f92672">=</span> <span style="color:#f92672">{};</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 存储元素的数组
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">transient</span> Object<span style="color:#f92672">[]</span> elementData<span style="color:#f92672">;</span> <span style="color:#75715e">// non-private to simplify nested class access
</span><span style="color:#75715e"></span>
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 集合中元素的个数
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> size<span style="color:#f92672">;</span>

</code></pre></div><p>（1）ArrayList内部使用数组存储元素，当数组长度不够时进行扩容，每次加一半的空间，ArrayList不会进行缩容；</p>
<p>（2）ArrayList支持随机访问，通过索引访问元素极快，时间复杂度为O(1)；</p>
<p>（3）ArrayList添加元素到尾部极快，平均时间复杂度为O(1)；</p>
<p>（4）ArrayList添加元素到中间比较慢，因为要搬移元素，平均时间复杂度为O(n)；</p>
<p>（5）ArrayList从尾部删除元素极快，时间复杂度为O(1)；</p>
<p>（6）ArrayList从中间删除元素比较慢，因为要搬移元素，平均时间复杂度为O(n)；</p>
<p>（7）ArrayList支持求并集，调用addAll(Collection&lt;? extends E&gt; c)方法即可；</p>
<p>（8）ArrayList支持求交集，调用retainAll(Collection&lt;? extends E&gt; c)方法即可；</p>
<p>（7）ArrayList支持求单向差集，调用removeAll(Collection&lt;? extends E&gt; c)方法即可；</p>
</li>
<li>
<p>CopyOnWriteArrayList</p>
<p>（1）CopyOnWriteArrayList使用ReentrantLock重入锁加锁，保证线程安全；</p>
<p>（2）CopyOnWriteArrayList的写操作都要先拷贝一份新数组，在新数组中做修改，修改完了再用新数组替换老数组，所以空间复杂度是O(n)，性能比较低下；</p>
<p>（3）CopyOnWriteArrayList的读操作支持随机访问，时间复杂度为O(1)；</p>
<p>（4）CopyOnWriteArrayList采用读写分离的思想，读操作不加锁，写操作加锁，且写操作占用较大内存空间，所以适用于读多写少的场合；</p>
<p>（5）CopyOnWriteArrayList只保证最终一致性，不保证实时一致性；</p>
</li>
<li>
<p>HashMap</p>
<p><img src="https://pic-frank.oss-cn-beijing.aliyuncs.com/img/202201201632349.png" alt="image-20220120163254296"></p>
<p>在Java中，HashMap的实现采用了（数组 + 链表 + 红黑树）的复杂结构，数组的一个元素又称作桶。</p>
<p>在添加元素时，会根据hash值算出元素在数组中的位置，如果该位置没有元素，则直接把元素放置在此处，如果该位置有元素了，则把元素以链表的形式放置在链表的尾部。</p>
<p>当一个链表的元素个数达到一定的数量（且数组的长度达到一定的长度）后，则把链表转化为红黑树，从而提高效率。</p>
<p>数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数，所以当元素数量非常多的时候，转化为红黑树能极大地提高效率。</p>
<p>（1）容量</p>
<p>容量为数组的长度，亦即桶的个数，默认为16，最大为2的30次方，当容量达到64时才可以树化。</p>
<p>（2）装载因子</p>
<p>装载因子用来计算容量达到多少时才进行扩容，默认装载因子为0.75。</p>
<p>（3）树化</p>
<p>树化，当容量达到64且链表的长度达到8时进行树化，当链表的长度小于6时反树化。</p>
<p><strong>总结</strong></p>
<p>（1）HashMap是一种散列表，采用（数组 + 链表 + 红黑树）的存储结构；</p>
<p>（2）HashMap的默认初始容量为16（1&laquo;4），默认装载因子为0.75f，容量总是2的n次方；</p>
<p>（3）HashMap扩容时每次容量变为原来的两倍；</p>
<p>（4）当桶的数量小于64时不会进行树化，只会扩容；</p>
<p>（5）当桶的数量大于64且单个桶中元素的数量大于8时，进行树化；</p>
<p>（6）当单个桶中元素数量小于6时，进行反树化；</p>
<p>（7）HashMap是非线程安全的容器；</p>
<p>（8）HashMap查找添加元素的时间复杂度都为O(1)；</p>
</li>
</ul>
<h1 id="jvm">JVM</h1>
<h3 id="jvm是什么">JVM是什么</h3>
<p>java虚拟机</p>
<h3 id="java内存模型-1">Java内存模型</h3>
<p>Java内存模型是跟「并发」相关的，它是为了屏蔽底层细节而提出的规范，希望在上层(Java层面上)在操作内存时在不同的平台上也有相同的效果</p>
<h3 id="java编译到执行的过程">Java编译到执行的过程</h3>
<ul>
<li>
<p>编译</p>
<p>将源码文件编译成JVM可以解释的class文件。</p>
<p>编译过程会对源代码程序做 「语法分析」「语义分析」「注解处理」等等处理，最后才生成字节码文件。</p>
<p>比如对泛型的擦除和我们经常用的Lombok就是在编译阶段干的。</p>
</li>
<li>
<p>加载</p>
<ul>
<li>
<p>装载</p>
<p>【装载时机】为了节省内存的开销，并不会一次性把所有的类都装载至JVM，而是等到「有需要」的时候才进行装载（比如new和反射等等）</p>
<p>【装载发生】class文件是通过「类加载器」装载到jvm中的，为了防止内存中出现多份同样的字节码，使用了双亲委派机制（它不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上）</p>
<p>【装载规则】JDK 中的本地方法类一般由根加载器（Bootstrp loader）装载，JDK 中内部实现的扩展类一般由扩展加载器（ExtClassLoader ）实现装载，而程序中的类文件则由系统加载器（AppClassLoader ）实现装载。</p>
<p>装载这个阶段它做的事情可以总结为：查找并加载类的二进制数据，在JVM「堆」中创建一个java.lang.Class类的对象，并将类相关的信息存储在JVM「方法区」中，</p>
<p>通过「装载」这个步骤后，现在已经把class文件装载到JVM中了，并创建出对应的Class对象以及类信息存储至方法区了。</p>
</li>
<li>
<p>连接</p>
<ul>
<li>验证：验证类是否符合 Java 规范和 JVM 规范</li>
<li>准备：为类的静态变量分配内存，初始化为系统的初始值</li>
<li>解析：将符号引用转为直接引用的过程</li>
</ul>
<p>通过「连接」这个步骤后，现在已经对class信息做校验并分配了内存空间和默认值了。</p>
</li>
<li>
<p>初始化</p>
<p>收集class的静态变量、静态代码块、静态方法至()方法，随后从上往下开始执行。</p>
</li>
</ul>
</li>
<li>
<p>解释</p>
<p>把字节码转换为操作系统识别的指令</p>
</li>
<li>
<p>执行</p>
<p>操作系统把解释器解析出来的指令码，调用系统的硬件执行最终的程序指令。</p>
</li>
</ul>
<h3 id="双亲委派机制是干什么的">双亲委派机制是干什么的</h3>
<!-- raw HTML omitted -->
<ul>
<li>
<p>**前置知识：**JDK中默认类加载器有三个：AppClassLoader、Ext ClassLoader、BootStrap ClassLoader。AppClassLoader的父加载器为Ext ClassLoader、Ext ClassLoader的父加载器为BootStrap ClassLoader。这里的父子关系并不是通过继承实现的，而是组合。</p>
</li>
<li>
<p>**什么是双亲委派机制：**加载器在加载过程中，先把类交由父类加载器进行加载，父类加载器没找到才由自身加载。</p>
</li>
<li>
<p>**双亲委派机制目的：**为了防止内存中存在多份同样的字节码（安全）</p>
</li>
<li>
<p>**类加载规则：**如果一个类由类加载器A加载，那么这个类的依赖类也是由「相同的类加载器」加载。</p>
</li>
<li>
<p>**如何打破双亲委派机制：**自定义ClassLoader，重写loadClass方法（只要不依次往上交给父加载器进行加载，就算是打破双亲委派机制）</p>
</li>
<li>
<p>**打破双亲委派机制案例：**Tomcat</p>
<!-- raw HTML omitted -->
<ul>
<li>为了Web应用程序类之间隔离，为每个应用程序创建WebAppClassLoader类加载器</li>
<li>为了Web应用程序类之间共享，把ShareClassLoader作为WebAppClassLoader的父类加载器，如果WebAppClassLoader加载器找不到，则尝试用ShareClassLoader进行加载</li>
<li>为了Tomcat本身与Web应用程序类隔离，用CatalinaClassLoader类加载器进行隔离，CatalinaClassLoader加载Tomcat本身的类</li>
<li>为了Tomcat与Web应用程序类共享，用CommonClassLoader作为CatalinaClassLoader和ShareClassLoader的父类加载器</li>
<li>ShareClassLoader、CatalinaClassLoader、CommonClassLoader的目录可以在Tomcat的catalina.properties进行配置</li>
</ul>
</li>
<li>
<p>**线程上下文加载器：**由于类加载的规则，很可能导致父加载器加载时依赖子加载器的类，导致无法加载成功（BootStrap ClassLoader无法加载第三方库的类），所以存在「线程上下文加载器」来进行加载。</p>
</li>
</ul>
<h3 id="jvm内存结构">JVM内存结构</h3>
<!-- raw HTML omitted -->
<p><code>其中：堆和方法区是线程共享的，其他地方是线程隔离的</code></p>
<ul>
<li>
<p>堆：</p>
<p>嗯，「堆」是线程共享的区域，几乎类的实例和数组分配的内存都来自于它</p>
<p>堆又可以细分为以下几个区域</p>
<!-- raw HTML omitted -->
<ul>
<li>伊甸园区</li>
<li>生存者区1，生存者区2</li>
<li>老年区</li>
</ul>
</li>
<li>
<p>虚拟机栈：每个线程在创建的时候都会创建一个「虚拟机栈」，每次方法调用都会创建一个「栈帧」。每个「栈帧」会包含几块内容：局部变量表、操作数栈、动态连接和返回地址，了解了「虚拟机栈」的组成后，也不难猜出它的作用了：它保存方法了局部变量、部分变量的计算并参与了方法的调用和返回。</p>
<p><strong>就是保存了方法的局部变量表，方法的调用和返回都在里面</strong></p>
<!-- raw HTML omitted -->
</li>
<li>
<p>本地方法栈：本地方法栈跟虚拟机栈的功能类似，虚拟机栈用于管理 Java 函数的调用，而本地方法栈则用于管理本地方法的调用。这里的「本地方法」指的是「非Java方法」，一般本地方法是使用C语言实现的。<strong>和虚拟机栈保存的东西一样，只不过不是java方法</strong></p>
</li>
<li>
<p>方法区：</p>
<p>HotSpot虚拟机中，在JDK8中，已经用「元空间」来替代了「永久代」作为「方法区」的实现了。方法区主要是用来存放已被虚拟机加载的「类相关信息」：包括类信息、常量池。</p>
<ul>
<li>
<p>类信息又包括了类的版本、字段、方法、接口和父类等信息</p>
</li>
<li>
<p>常量池又可以分「静态常量池」和「运行时常量池」</p>
<p>静态常量池主要存储的是「字面量」以及「符号引用」等信息，静态常量池也包括了我们说的「字符串常量池」。</p>
<p>「运行时常量池」存储的是「类加载」时生成的「直接引用」等信息。</p>
<blockquote>
<p>又值得注意的是：从「逻辑分区」的角度而言「常量池」是属于「方法区」的，但自从在「JDK7」以后，就已经把「运行时常量池」和「静态常量池」转移到了「堆」内存中进行存储（对于「物理分区」来说「运行时常量池」和「静态常量池』就属于堆）</p>
</blockquote>
<p>元空间和永久代最主要的区别就是：「元空间」存储不在虚拟机中，而是使用本地内存，JVM 不会再出现方法区的内存溢出，以往「永久代」经常因为内存不够用导致跑出OOM异常。</p>
<!-- raw HTML omitted -->
</li>
</ul>
</li>
<li>
<p>程序计数器：Java是多线程的语言，我们知道假设线程数大于CPU数，就很有可能有「线程切换」现象，切换意味着「中断」和「恢复」，那自然就需要有一块区域来保存「当前线程的执行信息」，所以，程序计数器就是用于记录各个线程执行的字节码的地址（分支、循环、跳转、异常、线程恢复等都依赖于计数器），<strong>简单点说就是记录线程中代码走到哪了</strong></p>
</li>
</ul>
<h3 id="垃圾回收">垃圾回收</h3>
<ul>
<li>
<p>如何判断是否是一个垃圾呢</p>
<ul>
<li>
<p>引用计数法：</p>
<p>引用计数法思路很简单：当对象被引用则+1，但对象引用失败则-1。当计数器为0时，说明对象不再被引用，可以被可回收，</p>
<p>引用计数法最明显的缺点就是：如果对象存在循环依赖，那就无法定位该对象是否应该被回收（A依赖B，B依赖A）</p>
</li>
<li>
<p>可达性算法</p>
<p>判断对象与GCROOT之间是否可达，不可达即是垃圾</p>
<p><strong>GCROOT</strong></p>
<p>「GC Roots」是一组必须「活跃」的引用。从「GC Root」出发，程序通过直接引用或者间接引用，能够找到可能正在被使用的对象</p>
<ul>
<li>
<p>当前活跃的栈帧指向堆里的对象引用就可以是「GC Roots」</p>
<blockquote>
<p>比如我们上次不是聊到JVM内存结构中的虚拟机栈吗，虚拟机栈里不是有栈帧吗，栈帧不是有局部变量吗？局部变量不就存储着引用嘛。</p>
<p>那如果栈帧位于虚拟机栈的栈顶，是不是就可以说明这个栈帧是活跃的（换言之，是线程正在被调用的）</p>
<p>既然是线程正在调用的，那栈帧里的指向「堆」的对象引用，是不是一定是「活跃」的引用？</p>
<p>所以，当前活跃的栈帧指向堆里的对象引用就可以是「GC Roots」</p>
</blockquote>
</li>
<li>
<p>比如类的静态变量引用是「GC Roots」，被「Java本地方法」所引用的对象也是「GC Roots」</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>回收过程</p>
<ul>
<li>
<p>标记</p>
<!-- raw HTML omitted -->
</li>
<li>
<p>清除</p>
<p>直接清除会有「内存碎片」的问题：可能我有10M的空余内存，但程序申请9M内存空间却申请不下来（10M的内存空间是垃圾清除后的，不连续的）</p>
<p>我把「标记」存活的对象「复制」到另一块空间，复制完了之后，直接把原有的整块空间给干掉！这样就没有内存碎片的问题了</p>
<p>这种做法缺点又很明显：内存利用率低，得有一块新的区域给我复制(移动)过去</p>
<p>还有一种「折中」的办法，我未必要有一块「大的完整空间」才能解决内存碎片的问题，我只要能在「当前区域」内进行移动</p>
<p>把存活的对象移到一边，把垃圾移到一边，那再将垃圾一起删除掉，不就没有内存碎片了嘛</p>
<p>这种专业的术语就叫做「整理」</p>
</li>
</ul>
</li>
<li>
<p>STW：stop the world</p>
<p>回收垃圾的时候，程序是有短暂的时间不能正常继续运作啊。不然JVM在回收的时候，用户线程还继续分配修改引用，JVM怎么搞</p>
</li>
<li>
<p>年轻代的垃圾收集器使用的都是「标记复制算法」</p>
<p>所以在「堆内存」划分中，将年轻代划分出Survivor区（Survivor From 和Survivor To），目的就是为了有一块完整的内存空间供垃圾回收器进行拷贝(移动)</p>
<!-- raw HTML omitted -->
</li>
<li>
<p>什么时候会从新生代进入老年代</p>
<ul>
<li>如果对象太大了，就会直接进入老年代（对象创建时就很大 || Survivor区没办法存下该对象）</li>
<li>如果对象太老了，那就会晋升至老年代（每发生一次Minor GC ，存活的对象年龄+1，达到默认值15则晋升老年代 || 动态对象年龄判定 可以进入老年代）</li>
</ul>
</li>
<li>
<p>当Eden区空间不足时，就会触发Minor GC</p>
</li>
</ul>
<h3 id="平时如何调优">平时如何调优</h3>
<p>一般调优JVM我们认为会有几种指标可以参考：『吞吐量』、『停顿时间』和『垃圾回收频率』</p>
<ul>
<li>内存区域大小以及相关策略（比如整块堆内存占多少、新生代占多少、老年代占多少、Survivor占多少、晋升老年代的条件等等）</li>
</ul>
<p>比如（-Xmx：设置堆的最大值、-Xms：设置堆的初始值、-Xmn：表示年轻代的大小、-XX:SurvivorRatio：伊甸区和幸存区的比例等等）</p>
<p>（按经验来说：IO密集型的可以稍微把「年轻代」空间加大些，因为大多数对象都是在年轻代就会灭亡。内存计算密集型的可以稍微把「老年代」空间加大些，对象存活时间会更长些）</p>
<ul>
<li>
<p>通过jps命令查看Java进程「基础」信息（进程号、主类）。这个命令很常用的就是用来看当前服务器有多少Java进程在运行，它们的进程号和加载主类是啥</p>
</li>
<li>
<p>jps -l 查看主类，进程</p>
</li>
<li>
<p>jps -v 查看jvm参数</p>
</li>
<li>
<p>通过jstat命令查看Java进程「统计类」相关的信息（类加载、编译相关信息统计，各个内存区域GC概况和统计）。这个命令很常用于看GC的情况</p>
</li>
<li>
<p>gc回收统计 jstat -gc pid</p>
</li>
<li>
<p>堆内存统计 jstat -gccapacity pid</p>
</li>
<li>
<p>jmap -dump:live,format=b,file=/home/tess.dump</p>
<p>产生一个HeapDump文件</p>
</li>
<li>
<p>XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof</p>
<p>增加oom的时候，自动导出当前堆的dump</p>
<p>这个命令很常用于把JVM内存信息dump到文件，然后再用MAT( Memory Analyzer tool 内存解析工具)把文件进行分析</p>
</li>
<li>
<p>通过jinfo命令来查看和调整Java进程的「运行参数」。</p>
</li>
<li>
<p>通过jstack命令来查看JVM「线程信息」。这个命令用常用语排查死锁相关的问题</p>
</li>
</ul>
<h3 id="一个对象到底有多大对象在内存中长什么样子">一个对象到底有多大，“对象在内存中长什么样子”</h3>
<!-- raw HTML omitted -->
<p>1.对象头中的Mark Word（标记字）主要用来表示对象的线程锁状态，另外还可以用来配合GC、存放该对象的hashCode；</p>
<p>2.Klass Word是一个指向方法区中Class信息的指针，意味着该对象可随时知道自己是哪个Class的实例；</p>
<p>3.数组长度也是占用64位（8字节）的空间，这是可选的，只有当本对象是一个数组对象时才会有这个部分；</p>
<p>4.对象体是用于保存对象属性和值的主体部分，占用内存空间取决于对象的属性数量和类型；</p>
<p>5.对齐字是为了减少堆内存的碎片空间（不一定准确）。</p>
<!-- raw HTML omitted -->
<h1 id="网络">网络</h1>
<h3 id="交换机和路由器区别">交换机和路由器区别</h3>
<h3 id="nas知道吗">Nas知道吗</h3>
<h3 id="什么长链接什么时候该用长链接什么又是长轮训短轮训java怎么实现">什么长链接，什么时候该用长链接，什么又是长轮训，短轮训。java怎么实现</h3>
<h3 id="java怎么写udp为什么要用udp">java怎么写UDP？为什么要用UDP</h3>
<h3 id="异步请求知道吗有什么场景可以用到吗java怎么写">异步请求知道吗？有什么场景可以用到吗，java怎么写？</h3>
<h3 id="讲一下tcpip它和http的关系">讲一下TCP/IP，它和HTTP的关系</h3>
<h3 id="什么是websocketws是长链接吗wss又有什么区别">什么是WebSocket，WS是长链接吗，WSS又有什么区别？</h3>
<h3 id="tcp长链接和http长链接有什么区别">TCP长链接和HTTP长链接有什么区别</h3>
<h3 id="netty干什么的用过吗">Netty干什么的，用过吗</h3>
<h3 id="你知道哪些网络模型">你知道哪些网络模型？</h3>
<!-- raw HTML omitted -->
<ul>
<li>
<p>OSI网络7层模型</p>
<ul>
<li>应用层：各种web应用</li>
<li>表示层：数据格式标识，基本加解密</li>
<li>会话层：控制各个程序之间的会话能力，软件数据分发给其他不同的软件</li>
<li>传输层：TCP UDP协议</li>
<li>网络层：定义IP地址，定义路由的基本功能，实现设备之间的数据转发</li>
<li>数据链路层：定义数据的基本格式，如何传输、如何标识，例如网卡的MAC地址</li>
<li>物理层：物理设备的传输，例如网卡标准、网线标准</li>
</ul>
</li>
<li>
<p>TCP/IP模型</p>
<ul>
<li>应用层：各种基于TCP/IP的协议，例如HTTP、FTP、SMTP</li>
<li>传输层：TCP或者UDP协议</li>
<li>网络层：它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。</li>
<li>网络接口层：物理设备的环境</li>
</ul>
</li>
<li>
<p>五层网络模型</p>
<p>由OSI7层模型演变而来</p>
</li>
</ul>
<h3 id="你知道哪些io模型bionioaio都是什么他们的使用场景是什么">你知道哪些IO模型，BIO、NIO、AIO都是什么，他们的使用场景是什么</h3>
<ul>
<li>
<p>java中的IO模型</p>
<ul>
<li>
<p>BIO</p>
<p>Blocking IO，传统的同步阻塞IO，对应着java.io，例如文件的读取，输入输出流，Socket的网络编程</p>
</li>
<li>
<p>NIO</p>
<p>No Blocking IO/New IO，同步非阻塞IO，对应着jdk1.4之后进入的nio，对于java.nio，提供了Channel，Buffer，Selector等抽象</p>
</li>
<li>
<p>AIO</p>
<p>Async IO ，异步非阻塞IO，在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型</p>
</li>
</ul>
</li>
</ul>
<p><strong>java中的io操作最终还是依赖于操作系统的io实现的，如在Linux 2.6以后，Java中的NIO和AIO都是通过 epoll</strong></p>
<ul>
<li>
<p>Linux中的IO模型</p>
<ul>
<li>
<p>BIO</p>
<!-- raw HTML omitted -->
<blockquote>
<p>一个输入操作通常包括两个不同的阶段:</p>
<ul>
<li>等待数据准备好</li>
<li>从内核向进程复制数据</li>
</ul>
<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达，当所等待分组到达时，它被复制到内核中的某个缓冲区，第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>
<p>从上图可以看出，<strong>应用进程通过 系统调用 <code>recvfrom</code> 去接收数据，而由于内核数据没有准备好，应用进程就会阻塞，直到内核准备好数据并将其从内核复制到应用进程的缓冲区中或者发生错误才返回</strong>。最常见的错误就是系统调用被信号中断。进程从调用recvfrom开始到它返回的整段时间内是被阻塞的。</p>
<p>Linux下的阻塞式I/O模型就对应了Java下的BIO模型，BIO的底层实现是调用操作系统的API去执行的，也就是调用操作系统的Socket套接字。</p>
</blockquote>
</li>
<li>
<p>NIO</p>
<!-- raw HTML omitted -->
<blockquote>
<p>应用进程通过系统调用 <code>recvfrom</code> 不断的去和内核交互，直到内核数据报准备好，而如果内核无数据准备好，转而立即返回一个 <code>EWOULDBLOCK</code>的错误，过一段时间再次发送 <code>recvfrom</code>请求，在此期间进程可以做其他事情，不用一直等待，这就是非阻塞。</p>
<p>当一个应用进程循环调用 <code>recvfrom</code>时，我们称之为<strong>轮询(polling)</strong>，应用进程持续轮询内核，以查看某个操作是否就绪。Java的NIO映射到Linux操作系统就是如上图所示的非阻塞I/O模型</p>
</blockquote>
</li>
<li>
<p>I/O复用模型</p>
<!-- raw HTML omitted -->
<blockquote>
<p>IO多路复用使用<code>select/poll/epoll</code>函数，多个进程的IO都可以注册在同一个 <code>select</code> 上，当用户进程调用该 <code>select</code>时，<code>select</code>去监听所有注册好的IO,<strong>如果所有被监听的IO需要的数据都没有准备好，那么 <code>select</code>调用进程会被阻塞</strong>，只要任意一个IO的数据报套接字变为可读，即数据报已经准备好，<code>select</code> 就返回套接字可读这一条件，然后调用 <code>recvfrom</code>把所读数据报复制到应用进程缓冲区。</p>
<p><strong>强调一点就是，IO多路复用模型并没有涉及到非阻塞</strong>，进程在发出<code>select</code>后，要一直阻塞等待其监听的所有IO操作至少有一个数据准备好才返回，强调阻塞状态，不存在非阻塞。</p>
<p>而在 Java NIO中也可以实现多路复用，主要是利用多路复用器 <strong>Selector</strong>，与这里的 <code>select</code>函数类型，<strong>Selector</strong>会不断轮询注册在其上的通道Channel，如果有某一个Channel上面发生读或写事件，这个Channel处于就绪状态，就会被Selector轮询出来。</p>
</blockquote>
</li>
<li>
<p>信号驱动式/io模型</p>
<!-- raw HTML omitted -->
<blockquote>
<p>应用进程预先向内核安装一个信号处理函数，然后立即返回，进程继续工作，不阻塞，当数据报准备好读取时，内核就为该进程产生一个信号通知进程，然后进程再调用recvfrom读取数据报。</p>
<p>信号驱动式IO在数据准备阶段是异步的，当内核中有数据报准备后再通知进程，但是在调用 recvfrom操作进行数据拷贝时是同步的，所以总体来说，整个IO过程不能是异步的。</p>
</blockquote>
</li>
<li>
<p>异步IO模型，AIO</p>
<!-- raw HTML omitted -->
<blockquote>
<p>应用进程调用<code>aio_read</code>函数，给内核传递描述符，缓存区指针，缓存区大小和文件偏移，并告诉内核当整个操作完成时如何通知进程，然后该系统调用立即返回，而且在等待I/O完成期间，我们的进程不被阻塞，进程可以去干其他事情，然后内核开始等待数据准备，数据准备好以后再拷贝数据到进程缓冲区，最后通知整个IO操作已完成。</p>
<p>Java的AIO提供了异步通道API，其操作系统底层实现就是这个异步I/O模型</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>使用场景</p>
<blockquote>
<p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</p>
<p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</p>
<p>AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p>
</blockquote>
</li>
</ul>
<h3 id="讲一下httpshttphttp10http11http2">讲一下Https、Http、Http1.0、Http1.1、Http2</h3>
<h3 id="什么是多路复用">什么是多路复用</h3>
<ul>
<li>
<p>IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。多路是指多个网络连接多个句柄，复用指的是同一个线程（结合上图），实际上在代码中，一个线程去调用select方法，当没有连接准备好的时候，select阻塞。select返回连接列表，进行处理</p>
<pre tabindex="0"><code>fds = [listen_fd]
// 伪代码描述
while(1) {
  // 通过内核获取有读写事件发生的fd，只要有一个则返回，无则阻塞
  // 整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，accept/recv是不会阻塞
  for (fd in select(fds)) {
    if (fd == listen_fd) {
        client_fd = accept(listen_fd)
        fds.append(client_fd)
    } elseif (len = recv(fd) &amp;&amp; len != -1) { 
      // logic
    }
  }  
}
</code></pre></li>
<li>
<p>linux实现多路复用的方式</p>
<!-- raw HTML omitted -->
</li>
<li>
<p>epoll的et和lt的区别</p>
<p>epoll LT 与 ET模式的区别</p>
<ul>
<li>epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。</li>
<li>LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作</li>
<li>ET模式下，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读完，或者遇到EAGAIN错误</li>
</ul>
</li>
</ul>
<h1 id="代码书写">代码书写</h1>
<h3 id="聊聊设计模式你知道哪些用过哪些为什么要用设计模式">聊聊设计模式，你知道哪些，用过哪些，为什么要用设计模式</h3>
<h1 id="数据结构">数据结构</h1>
<h3 id="你知道哪些数据结构">你知道哪些数据结构</h3>
<ul>
<li>树</li>
<li>线性表（数组和链表实现）</li>
<li>堆</li>
<li>图</li>
<li>字典（hashMap）</li>
</ul>
<h3 id="红黑树b树b树二叉树完全平衡二叉树">红黑树、B树、B+树、二叉树、完全平衡二叉树</h3>
<ul>
<li>
<p>树</p>
<p>一种数据结构，每个元素可以有子树</p>
</li>
<li>
<p>二叉树</p>
<p>一种“树”数据结构，满足每个元素最多只有2个子树。</p>
<ul>
<li>
<p>遍历方式</p>
<ul>
<li>前序遍历：中左右逐渐遍历，可以得到一条搜索路径，用于搜索。</li>
<li>中序遍历：左中右，可以得到一个有序列表。</li>
<li>后序遍历：用来计算一颗树算术表达式</li>
</ul>
</li>
<li>
<p>满二叉树，所有除了叶子结点的节点都有2个节点</p>
</li>
<li>
<p>完全二叉树，叶子结点只会存在于倒数第一和倒数第二层，并且叶子结点都都偏左</p>
<p>完全二叉树由于他的定义，可以使用数组来存放，而不用链表来存储，可以节省左右两个指针的大小空间。例如根节点是下标i，左节点下标就是2i，右节点下标就是2i+1</p>
</li>
<li>
<p>二叉搜索树(BST)</p>
<p>根节点的值大于其左子树中任意一个节点的值，小于其右节点中任意一节点的值，这一规则适用于二叉查找树中的每一个节点。</p>
<p>最好的时间复杂度是O(logn)，最快的情况会退化为链表</p>
</li>
<li>
<p>平衡二叉树(AVL)</p>
<p>通过平衡的动作左旋和右旋，解决二叉搜索树退化为链表的问题。<strong>完全平衡二叉树是只保证左右子树的深度不会超过1</strong></p>
</li>
<li>
<p>红黑树</p>
<p>由于完全平衡二叉树要求左右子树深度不能超过1，导致每次插入一个新节点时都会带来平衡的动作。因为1特别苛刻，几乎每次都要平衡。最后平衡所花费的时间代价过高。</p>
<p>解决，完全平衡二叉树平衡频率过于频繁。</p>
<p><!-- raw HTML omitted -->能够保证左右子树的高度不超过2倍<!-- raw HTML omitted --></p>
<p>时间复杂度<em>l<strong>o</strong>g</em>(<em>n</em>)</p>
<blockquote>
<p>二叉搜索树：也称二叉查找树，或二叉排序树。定义也比较简单，要么是一颗空树，要么就是具有如下性质的二叉树：
（1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的
值；
（2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的
值；
（3）任意节点的左、右子树也分别为二叉查找树；
（4）没有键值相等的节点。</p>
<p>平衡二叉树：在二叉搜索树的基础上多了两个重要的特点：
（1）左右两子树的高度差的绝对值不能超过 1；
（2）左右两子树也是一颗平衡二叉树。</p>
<p>红黑树：红黑树是在普通二叉树上，对每个节点添加一个颜色属性形成的，需要同时满足一下五条性质：
（1）节点是红色或者是黑色；
（2）根节点是黑色；
（3）每个叶节点（NIL 或空节点）是黑色；
（4）每个红色节点的两个子节点都是黑色的（也就是说不存在两个连续的红色节
点）；
（5）从任一节点到其没个叶节点的所有路径都包含相同数目的黑色节点。</p>
<p>区别：AVL 树需要保持平衡，但它的旋转太耗时，而红黑树就是一个没有 AVL 树 那样平衡，因此插入、删除效率会高于 AVL 树，而 AVL
树的查找效率显然高于红黑树。</p>
</blockquote>
<ul>
<li>
<p>如果插入一个node引起了树的不平衡，AVL和RB-Tree(红黑树)都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次(因为不需要严格的平衡，从根到叶子的最长的可能路径不多于最短的可能路径的两倍长)旋转以及修改节点的颜色，只需要O(1)的复杂度。</p>
</li>
<li>
<p>其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。</p>
</li>
<li>
<p>使用场景：IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查.
ngnix中,用红黑树管理timer,因为红黑树是有序的,可以很快的得到距离当前最小的定时器.
java中TreeMap，jdk1.8的hashmap的实现.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>B树和B+树</p>
<p>B树也是平时说的“B-”树，又叫平衡多路树。和二叉树不同，二叉树每个节点只会有2个子树。而B树有多个子树。M阶的B树是只最多子树是M个的B树。</p>
<p>和二叉树一样，也是左小右大。</p>
<ul>
<li>B树节点存放数据，并且叶子节点不需要使用链表串联</li>
</ul>
</li>
</ul>
<h3 id="手写一个链表实现正向输出反向输出找到最中间的元素">手写一个链表，实现正向输出，反向输出，找到最中间的元素</h3>
<h3 id="什么是堆">什么是堆</h3>
<p>堆是一种非线性结构，<strong>可以</strong>把堆看作一个数组，<strong>也可以</strong>被看作一个完全二叉树，通俗来讲堆其实就是<strong>利用完全二叉树的结构来维护的一维数组</strong><code>但堆并不一定是完全二叉树</code></p>
<p>按照堆的特点可以把堆分为大顶堆和小顶堆
大顶堆：每个结点的值都大于或等于其左右孩子结点的值
小顶堆：每个结点的值都小于或等于其左右孩子结点的值</p>
<h3 id="使用堆的原因">使用堆的原因？</h3>
<p>如果仅仅是需要得到一个有序的序列，使用排序就可以很快完成，并不需要去组织一个新的数据结构。但是如果我们的需求是对于一个随时会有更新的序列，我要随时知道这个序列的最小值或最大值是什么。显然如果是线性结构，每次插入之后，假设原数组是有序的，那使用二分把它放在正确的位置也未尝不可，但是插入的时候从数组中留出空位就需要O(n)的时间复杂度，删除的时候亦然。</p>
<p><strong>时间复杂度</strong></p>
<p><strong>插入和删除的时间复杂度是O(logn)</strong></p>
<p>场景：</p>
<p>java中的Timer，就是通过堆来找到当前最小的时间戳，进行任务执行的</p>
<h3 id="环形队列">环形队列</h3>
<ul>
<li>
<p>普通队列</p>
<p>普通队列，数组实现时，出队后，原来的空间就浪费了。</p>
<!-- raw HTML omitted -->
<p>​	环形队列，数组实现时，下标用模取运算，例如最大空间为5，模取后只会有0，1，2，3，4下标，组成了循环。</p>
<ol>
<li><code>front</code> 变量的含义做一个调整： <code>front</code> 就指向队列的第一个元素, 也就是说 <code>arr[front]</code> 就是队列的第一个元素
<code>front</code> 的初始值 = 0</li>
<li><code>rear</code> 变量的含义做一个调整：<code>rear</code> 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.
<code>rear</code> 的初始值 = 0</li>
<li>当队列满时，条件是 <code>(rear + 1) % maxSize == front</code> 【满】</li>
<li>对队列为空的条件， <code>rear == front</code> 空</li>
<li>当我们这样分析， 队列中有效的数据的个数 <code>(rear + maxSize - front) % maxSize</code> // rear = 1 front = 0</li>
</ol>
</li>
<li>
<p>时间轮</p>
<p>使用场景，处理大批量的定时任务</p>
<p>利用环形队列，队列的每个空间里存放的是任务的集合。</p>
<p>例如以60秒为一个轮，70秒后执行一个任务。只需要一个timer按秒去旋转时间轮，70%60=10，到达第10个槽的时候，执行内部的所有任务即可。</p>
<p>为了解决10秒和70秒落在同一个槽上，可以在任务身上加一个属性，圈数，例如10秒的任务圈数是0，70秒的任务是1，只有达到槽位置，并且圈数为0的任务才会被执行。</p>
<p>kafaka的做法是，再做一个分钟轮，先转分钟轮。再转秒的轮。</p>
</li>
</ul>
<h1 id="算法">算法</h1>
<h3 id="你能写出几个排序算法">你能写出几个排序算法</h3>
<ul>
<li>
<p>冒泡</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> array<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]{</span>2<span style="color:#f92672">,</span>4<span style="color:#f92672">,</span>62<span style="color:#f92672">,</span>6<span style="color:#f92672">,</span>457<span style="color:#f92672">,</span>2<span style="color:#f92672">,</span>3<span style="color:#f92672">,</span>5<span style="color:#f92672">,</span>7<span style="color:#f92672">,</span>8<span style="color:#f92672">,</span>9<span style="color:#f92672">};</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span>i<span style="color:#f92672">&lt;</span>array<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>i<span style="color:#f92672">++){</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span>1<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> array<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>array<span style="color:#f92672">[</span>i<span style="color:#f92672">]&gt;</span>array<span style="color:#f92672">[</span>j<span style="color:#f92672">]){</span>
                    <span style="color:#66d9ef">int</span> tmp<span style="color:#f92672">=</span>array<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
                    array<span style="color:#f92672">[</span>i<span style="color:#f92672">]=</span>array<span style="color:#f92672">[</span>j<span style="color:#f92672">];</span>
                    array<span style="color:#f92672">[</span>j<span style="color:#f92672">]=</span>tmp<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span>array<span style="color:#f92672">));</span>
</code></pre></div></li>
<li>
<p>选择排序</p>
<ul>
<li>初始状态：无序区为R[1..n]，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟结束，数组有序化了。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> array<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]{</span>2<span style="color:#f92672">,</span>4<span style="color:#f92672">,</span>62<span style="color:#f92672">,</span>6<span style="color:#f92672">,</span>457<span style="color:#f92672">,</span>2<span style="color:#f92672">,</span>3<span style="color:#f92672">,</span>5<span style="color:#f92672">,</span>7<span style="color:#f92672">,</span>8<span style="color:#f92672">,</span>9<span style="color:#f92672">};</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> array<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> minIndex<span style="color:#f92672">=</span>i<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> array<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>array<span style="color:#f92672">[</span>j<span style="color:#f92672">]&lt;=</span>array<span style="color:#f92672">[</span>minIndex<span style="color:#f92672">]){</span>
                    minIndex<span style="color:#f92672">=</span>j<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">int</span> tmp<span style="color:#f92672">=</span>array<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
            array<span style="color:#f92672">[</span>i<span style="color:#f92672">]=</span>array<span style="color:#f92672">[</span>minIndex<span style="color:#f92672">];</span>
            array<span style="color:#f92672">[</span>minIndex<span style="color:#f92672">]=</span>tmp<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span>array<span style="color:#f92672">));</span>
</code></pre></div></li>
<li>
<p>插入排序</p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> array<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]{</span>2<span style="color:#f92672">,</span>4<span style="color:#f92672">,</span>62<span style="color:#f92672">,</span>6<span style="color:#f92672">,</span>457<span style="color:#f92672">,</span>2<span style="color:#f92672">,</span>3<span style="color:#f92672">,</span>5<span style="color:#f92672">,</span>7<span style="color:#f92672">,</span>8<span style="color:#f92672">,</span>9<span style="color:#f92672">};</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> array<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> cur<span style="color:#f92672">=</span>array<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i<span style="color:#f92672">-</span>1<span style="color:#f92672">;</span> j <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">;</span> j<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>array<span style="color:#f92672">[</span>j<span style="color:#f92672">]&gt;</span>cur<span style="color:#f92672">){</span>
                    array<span style="color:#f92672">[</span>j<span style="color:#f92672">+</span>1<span style="color:#f92672">]=</span>array<span style="color:#f92672">[</span>j<span style="color:#f92672">];</span>
                <span style="color:#f92672">}</span><span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                    array<span style="color:#f92672">[</span>j<span style="color:#f92672">+</span>1<span style="color:#f92672">]=</span>cur<span style="color:#f92672">;</span>
                    <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span>array<span style="color:#f92672">));</span>
</code></pre></div></li>
<li>
<p>快排</p>
<p><a href="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html">参考</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> array<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]{</span>2<span style="color:#f92672">,</span>4<span style="color:#f92672">,</span>62<span style="color:#f92672">,</span>6<span style="color:#f92672">,</span>457<span style="color:#f92672">,</span>2<span style="color:#f92672">,</span>3<span style="color:#f92672">,</span>5<span style="color:#f92672">,</span>7<span style="color:#f92672">,</span>8<span style="color:#f92672">,</span>9<span style="color:#f92672">};</span>
        sort<span style="color:#f92672">(</span>array<span style="color:#f92672">,</span>0<span style="color:#f92672">,</span>array<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span>array<span style="color:#f92672">));</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arrays<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> startIndex<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> endIndex<span style="color:#f92672">){</span>
        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>startIndex<span style="color:#f92672">&gt;=</span>endIndex<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> right<span style="color:#f92672">=-</span>1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> left<span style="color:#f92672">=-</span>1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> endIndex<span style="color:#f92672">;</span> j <span style="color:#f92672">&gt;=</span>startIndex<span style="color:#f92672">;</span> j<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>arrays<span style="color:#f92672">[</span>j<span style="color:#f92672">]&lt;</span>arrays<span style="color:#f92672">[</span>startIndex<span style="color:#f92672">]){</span>
                right<span style="color:#f92672">=</span>j<span style="color:#f92672">;</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>right<span style="color:#f92672">==-</span>1<span style="color:#f92672">){</span>
            <span style="color:#75715e">//说明已经排序好了
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//递归
</span><span style="color:#75715e"></span>            sort<span style="color:#f92672">(</span>arrays<span style="color:#f92672">,</span>startIndex<span style="color:#f92672">+</span>1<span style="color:#f92672">,</span>endIndex<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span><span style="color:#66d9ef">else</span>
        <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> startIndex<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;=</span> endIndex<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">//相交了，直接与基数互换
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>right<span style="color:#f92672">==</span>i<span style="color:#f92672">){</span>
                    <span style="color:#66d9ef">int</span> tmp<span style="color:#f92672">=</span>arrays<span style="color:#f92672">[</span>startIndex<span style="color:#f92672">];</span>
                    arrays<span style="color:#f92672">[</span>startIndex<span style="color:#f92672">]=</span>arrays<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
                    arrays<span style="color:#f92672">[</span>i<span style="color:#f92672">]=</span>tmp<span style="color:#f92672">;</span>
                    <span style="color:#75715e">//当前轮走完，走子轮，
</span><span style="color:#75715e"></span>                    sort<span style="color:#f92672">(</span>arrays<span style="color:#f92672">,</span>startIndex<span style="color:#f92672">,</span>i<span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>
                    sort<span style="color:#f92672">(</span>arrays<span style="color:#f92672">,</span>i<span style="color:#f92672">+</span>1<span style="color:#f92672">,</span>endIndex<span style="color:#f92672">);</span>
                    <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
                <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>arrays<span style="color:#f92672">[</span>i<span style="color:#f92672">]&gt;</span>arrays<span style="color:#f92672">[</span>startIndex<span style="color:#f92672">]){</span>
                    left<span style="color:#f92672">=</span>i<span style="color:#f92672">;</span>
                    <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>left<span style="color:#f92672">!=-</span>1<span style="color:#f92672">){</span>
                <span style="color:#75715e">//交换
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">int</span> tmp<span style="color:#f92672">=</span>arrays<span style="color:#f92672">[</span>left<span style="color:#f92672">];</span>
                arrays<span style="color:#f92672">[</span>left<span style="color:#f92672">]=</span>arrays<span style="color:#f92672">[</span>right<span style="color:#f92672">];</span>
                arrays<span style="color:#f92672">[</span>right<span style="color:#f92672">]=</span>tmp<span style="color:#f92672">;</span>
                <span style="color:#75715e">//继续
</span><span style="color:#75715e"></span>                sort<span style="color:#f92672">(</span>arrays<span style="color:#f92672">,</span>startIndex<span style="color:#f92672">,</span>endIndex<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p>并归排序</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> array<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]{</span>2<span style="color:#f92672">,</span>55<span style="color:#f92672">,</span>62<span style="color:#f92672">,</span>6<span style="color:#f92672">,</span>45<span style="color:#f92672">,</span>2<span style="color:#f92672">,</span>3<span style="color:#f92672">,</span>5<span style="color:#f92672">,</span>7<span style="color:#f92672">,</span>8<span style="color:#f92672">,</span>9<span style="color:#f92672">,</span>1<span style="color:#f92672">,</span>2<span style="color:#f92672">,</span>14<span style="color:#f92672">,</span>6<span style="color:#f92672">,</span>67<span style="color:#f92672">,</span>34<span style="color:#f92672">,</span>5<span style="color:#f92672">,</span>7<span style="color:#f92672">,</span>8<span style="color:#f92672">,</span>95<span style="color:#f92672">,</span>312<span style="color:#f92672">,</span>68<span style="color:#f92672">,</span>0<span style="color:#f92672">,</span>457<span style="color:#f92672">,</span>0<span style="color:#f92672">};</span>
        array<span style="color:#f92672">=</span>mergeSort<span style="color:#f92672">(</span>array<span style="color:#f92672">,</span>0<span style="color:#f92672">,</span>array<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span>array<span style="color:#f92672">));</span>
        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> ints <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>1<span style="color:#f92672">,</span>2<span style="color:#f92672">,</span>3<span style="color:#f92672">,</span>0<span style="color:#f92672">,</span>0<span style="color:#f92672">,</span>0<span style="color:#f92672">};</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span>ints<span style="color:#f92672">));</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">mergeSort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> array<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> startIndex<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> endIndex<span style="color:#f92672">){</span>
        <span style="color:#75715e">//数组长度
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> length<span style="color:#f92672">=</span>endIndex<span style="color:#f92672">-</span>startIndex<span style="color:#f92672">+</span>1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>length<span style="color:#f92672">==</span>1<span style="color:#f92672">){</span>
            <span style="color:#75715e">//只有一个，返回本身
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]{</span>array<span style="color:#f92672">[</span>startIndex<span style="color:#f92672">]};</span>
        <span style="color:#f92672">}</span><span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>length<span style="color:#f92672">==</span>2<span style="color:#f92672">){</span>
         <span style="color:#75715e">//等于2,看是否需要交换
</span><span style="color:#75715e"></span>         <span style="color:#66d9ef">int</span> left<span style="color:#f92672">=</span>array<span style="color:#f92672">[</span>startIndex<span style="color:#f92672">];</span>
         <span style="color:#66d9ef">int</span> right<span style="color:#f92672">=</span>array<span style="color:#f92672">[</span>endIndex<span style="color:#f92672">];</span>
         <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>left<span style="color:#f92672">&gt;</span>right<span style="color:#f92672">){</span>
             <span style="color:#75715e">//交换
</span><span style="color:#75715e"></span>             <span style="color:#66d9ef">int</span> tmp<span style="color:#f92672">=</span>left<span style="color:#f92672">;</span>
             left<span style="color:#f92672">=</span>right<span style="color:#f92672">;</span>
             right<span style="color:#f92672">=</span>tmp<span style="color:#f92672">;</span>
         <span style="color:#f92672">}</span>
         <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]{</span>left<span style="color:#f92672">,</span>right<span style="color:#f92672">};</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> startIndex<span style="color:#f92672">+</span>length <span style="color:#f92672">/</span> 2<span style="color:#f92672">;</span>
            <span style="color:#75715e">//合并
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> left <span style="color:#f92672">=</span> mergeSort<span style="color:#f92672">(</span>array<span style="color:#f92672">,</span> startIndex<span style="color:#f92672">,</span> m<span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> right <span style="color:#f92672">=</span> mergeSort<span style="color:#f92672">(</span>array<span style="color:#f92672">,</span> m <span style="color:#f92672">,</span> endIndex<span style="color:#f92672">);</span>
            <span style="color:#75715e">//左边一定&lt;=右边
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> r <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>left<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">+</span> right<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">];</span>

            <span style="color:#66d9ef">int</span> leftIndex<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">int</span> rightIndex<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>leftIndex<span style="color:#f92672">&lt;</span>left<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">&amp;&amp;</span> rightIndex<span style="color:#f92672">&lt;</span>right<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">){</span>
                <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>left<span style="color:#f92672">[</span>leftIndex<span style="color:#f92672">]&lt;</span>right<span style="color:#f92672">[</span>rightIndex<span style="color:#f92672">]){</span>
                    r<span style="color:#f92672">[</span>leftIndex<span style="color:#f92672">+</span>rightIndex<span style="color:#f92672">]=</span>left<span style="color:#f92672">[</span>leftIndex<span style="color:#f92672">];</span>
                    leftIndex<span style="color:#f92672">++;</span>
                <span style="color:#f92672">}</span><span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                    r<span style="color:#f92672">[</span>leftIndex<span style="color:#f92672">+</span>rightIndex<span style="color:#f92672">]=</span>right<span style="color:#f92672">[</span>rightIndex<span style="color:#f92672">];</span>
                    rightIndex<span style="color:#f92672">++;</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>leftIndex<span style="color:#f92672">&lt;</span>left<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">){</span>
                r<span style="color:#f92672">[</span>leftIndex<span style="color:#f92672">+</span>rightIndex<span style="color:#f92672">]=</span>left<span style="color:#f92672">[</span>leftIndex<span style="color:#f92672">];</span>
                leftIndex<span style="color:#f92672">++;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>rightIndex<span style="color:#f92672">&lt;</span>right<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">){</span>
                r<span style="color:#f92672">[</span>leftIndex<span style="color:#f92672">+</span>rightIndex<span style="color:#f92672">]=</span>right<span style="color:#f92672">[</span>rightIndex<span style="color:#f92672">];</span>
                rightIndex<span style="color:#f92672">++;</span>
            <span style="color:#f92672">}</span>

            <span style="color:#66d9ef">return</span> r<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p>桶排序</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> array<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]{</span>2<span style="color:#f92672">,</span>4<span style="color:#f92672">,</span>62<span style="color:#f92672">,</span>6<span style="color:#f92672">,</span>457<span style="color:#f92672">,</span>2<span style="color:#f92672">,</span>3<span style="color:#f92672">,</span>5<span style="color:#f92672">,</span>7<span style="color:#f92672">,</span>8<span style="color:#f92672">,</span>9<span style="color:#f92672">};</span>
        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> ints <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>500<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> array<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            ints<span style="color:#f92672">[</span>array<span style="color:#f92672">[</span>i<span style="color:#f92672">]]+=</span>1<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> ints<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>ints<span style="color:#f92672">[</span>i<span style="color:#f92672">]!=</span>0<span style="color:#f92672">)</span>
                <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> ints<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
                    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>i<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;,&#34;</span><span style="color:#f92672">);</span>
                <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div></li>
</ul>
<h3 id="你能写出几个查找算法">你能写出几个查找算法</h3>
<h3 id="你能写出几个去重算法">你能写出几个去重算法</h3>
<h4 id="leetcode经典题目">LeetCode经典题目</h4>
<ul>
<li>
<p>回文串</p>
<p>用数据结构栈去解决</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">        <span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> target<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">[]{</span><span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#39;b&#39;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#39;b&#39;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#39;b&#39;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#39;c&#39;</span><span style="color:#f92672">};</span>

        <span style="color:#66d9ef">boolean</span> jishu<span style="color:#f92672">=</span>target<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">%</span>2<span style="color:#f92672">!=</span>0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> middle<span style="color:#f92672">=</span>jishu<span style="color:#f92672">?</span>target<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">/</span>2<span style="color:#f92672">-</span>1<span style="color:#f92672">:</span>target<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">/</span>2<span style="color:#f92672">;</span>

        <span style="color:#75715e">//前一半和后一半是否相同
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">,</span>j<span style="color:#f92672">=</span>target<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">-</span>1<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> middle<span style="color:#f92672">;</span> i<span style="color:#f92672">++,</span>j<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>target<span style="color:#f92672">[</span>i<span style="color:#f92672">]!=</span>target<span style="color:#f92672">[</span>j<span style="color:#f92672">]){</span>
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;不是&#34;</span><span style="color:#f92672">);</span>
                <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;是的&#34;</span><span style="color:#f92672">);</span>
</code></pre></div></li>
<li>
<p>滑动窗口</p>
</li>
</ul>
<h3 id="lru">LRU</h3>
<h1 id="操作系统">操作系统</h1>
<h3 id="零拷贝是什么">零拷贝是什么</h3>
<p>简单点说就是，传统的从磁盘读取文件，再从网卡发出去。都是通过CPU来完成的</p>
<p>因为用户进程是无法操作硬件的，必须切换到内核态。因此linux提供了read和write，2个函数。read，用户态切换到内核态，CPU发起IO请求，磁盘准备数据</p>
<p>，准备好了通知CPU，CPU将数据放到PageCache，再从PageCache拷贝到用户缓冲区。这个过程CPU，全程参与，这个时候CPU不能做其他事情。</p>
<!-- raw HTML omitted -->
<p>为了解决CPU在复制文件的时候，不能做事情。出现了DMA(<strong>Direct Memory Access</strong>)，将复制的过程交给DMA处理，CPU只需要等待结果就可以了，期间可以执行其他事情。</p>
<!-- raw HTML omitted -->
<p>早期的读取文件，并传送到网卡流程</p>
<!-- raw HTML omitted -->
<p>首先，期间共<strong>发生了 4 次用户态与内核态的上下文切换</strong>，因为发生了两次系统调用，一次是 <code>read()</code> ，一次是 <code>write()</code>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。</p>
<p>上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p>
<p>其次，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p>
<ul>
<li><em>第一次拷贝</em>，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</li>
<li><em>第二次拷贝</em>，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</li>
<li><em>第三次拷贝</em>，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</li>
<li><em>第四次拷贝</em>，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li>
</ul>
<p><strong>实现零拷贝的方式</strong></p>
<ul>
<li>
<p>mmap + write</p>
<p><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p>
<!-- raw HTML omitted -->
</li>
<li>
<p>sendfile</p>
<p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 <code>sendfile()</code>，函数形式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/socket.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>ssize_t <span style="color:#a6e22e">sendfile</span>(<span style="color:#66d9ef">int</span> out_fd, <span style="color:#66d9ef">int</span> in_fd, off_t <span style="color:#f92672">*</span>offset, size_t count);
</code></pre></div><p>它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</p>
<p>首先，它可以替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。</p>
<p>其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：</p>
<!-- raw HTML omitted -->
</li>
</ul>
<p><a href="https://www.cnblogs.com/xiaolincoding/p/13719610.html">参考</a></p>
<h3 id="顺序读写和随机读写">顺序读写和随机读写</h3>
<p>常见的解释在日志文件和innodb的索引文件。</p>
<p>我们每次操作数据的增删改查的日志，都是通过顺序读写。</p>
<p>因为索引是一种有序的数据结构B+树，每次有新数据来的时候，都会更新索引信息。通过计算找到索引应该在的地方。这个就是寻址。</p>
<p>顺序读写就是只第一次寻址，然后后续写的动作都是在第一次寻址完后的地址上继续工作，不需要再寻址了。</p>
<p>而随机读写是每次都要寻址的</p>
<p><a href="https://www.zhihu.com/question/370950509">参考</a></p>
<h1 id="其他问题">其他问题</h1>
<h3 id="olap和oltp有什么区别">OLAP和OLTP有什么区别</h3>
<p><a href="https://baijiahao.baidu.com/s?id=1611554859260686629&amp;wfr=spider&amp;for=pc">参考</a></p>
<h1 id="没有一线的流量并发工作经验你是怎么考虑你的系统的">没有一线的流量并发工作经验，你是怎么考虑你的系统的</h1>
<p>根据我的经验总结，只需要牢记一些常识就行：</p>
<ul>
<li>mysql 的 tps 你就按 5000 算，每秒超过 5000 请求，直接用 myql 肯定不行</li>
<li>单机 redis 的 qps 可以到 100k ，把一些数据 /缓存，存到 redis ，能有效提高并发</li>
<li>利用消息队列实现削峰，实现生产与消费的解耦</li>
<li>保证处理逻辑可以并行，可以扩展，谨慎使用锁</li>
<li>尽量将服务做成无状态可扩展的，把状态扔给 redis 或者其他高效的存储</li>
<li>对于频繁访问的数据一定要做缓存，然后去解决缓存的雪崩，穿透，失效等问题</li>
</ul>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="Frank Silva avatar" src="/img/avatar.png" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">About Frank Silva</span>
	</div>
	<div class="authorbox__description">
		Pursue Consummate Coding.
	</div>
</div>

<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/post/%E5%B9%B3%E6%97%B6%E7%96%91%E9%97%AE/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">平时疑问</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/post/spring/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring问题整理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 Frank Silva.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
<script src="/js/custom.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>
</body>
</html>