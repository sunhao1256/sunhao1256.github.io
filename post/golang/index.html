<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title> - Lulu</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="" />
<meta property="og:description" content="Golang   defer的执行顺序，能改变返回值吗
defer的执行顺序和栈类似，属于后进先出
defer在return之后执行，但是在函数退出之前，defer可以修改返回值。通过有名返回变量
func changeReturn() (i int) { i = 32 defer func() { fmt.Printf(&#34;defer \n&#34;) i&#43;&#43; }() return i }   go 的tag用处
 json序列化 gorm的表名映射 binding，validate 等gin web 框架需要的绑定和校验功能    Golang的和java的区别？
 golang是静态编译，编译完成后，即可在操作系统上运行。可以交叉编译打包不同os和arch的代码。java是动态编译，java中间存在一层jvm虚拟机， java不支持多继承，golang通过struct的成员变量实现多继承 golang的goroutine只有2kb左右，而java的thread对应着内核的一个线程会达到2mb左右，资源开销不是一个级别。    golang的反射说一下
golang类似java的reflect提供了也提供了reflect的包，内部有相关的接口和方法使用。
核心的两个type分别是 Type和Value
golang提供了
t := reflect.TypeOf(person) v := reflect.ValueOf(person) 通过反射获取field的相关信息以及tag等
func testReflect(person Person) { t := reflect.TypeOf(person) v := reflect.ValueOf(person) for i := 0; i &lt; t." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sunhao1256.github.io/post/golang/" /><meta property="article:section" content="post" />




		<meta itemprop="name" content="">
<meta itemprop="description" content="Golang   defer的执行顺序，能改变返回值吗
defer的执行顺序和栈类似，属于后进先出
defer在return之后执行，但是在函数退出之前，defer可以修改返回值。通过有名返回变量
func changeReturn() (i int) { i = 32 defer func() { fmt.Printf(&#34;defer \n&#34;) i&#43;&#43; }() return i }   go 的tag用处
 json序列化 gorm的表名映射 binding，validate 等gin web 框架需要的绑定和校验功能    Golang的和java的区别？
 golang是静态编译，编译完成后，即可在操作系统上运行。可以交叉编译打包不同os和arch的代码。java是动态编译，java中间存在一层jvm虚拟机， java不支持多继承，golang通过struct的成员变量实现多继承 golang的goroutine只有2kb左右，而java的thread对应着内核的一个线程会达到2mb左右，资源开销不是一个级别。    golang的反射说一下
golang类似java的reflect提供了也提供了reflect的包，内部有相关的接口和方法使用。
核心的两个type分别是 Type和Value
golang提供了
t := reflect.TypeOf(person) v := reflect.ValueOf(person) 通过反射获取field的相关信息以及tag等
func testReflect(person Person) { t := reflect.TypeOf(person) v := reflect.ValueOf(person) for i := 0; i &lt; t.">

<meta itemprop="wordCount" content="115">
<meta itemprop="keywords" content="" />
		<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="Golang   defer的执行顺序，能改变返回值吗
defer的执行顺序和栈类似，属于后进先出
defer在return之后执行，但是在函数退出之前，defer可以修改返回值。通过有名返回变量
func changeReturn() (i int) { i = 32 defer func() { fmt.Printf(&#34;defer \n&#34;) i&#43;&#43; }() return i }   go 的tag用处
 json序列化 gorm的表名映射 binding，validate 等gin web 框架需要的绑定和校验功能    Golang的和java的区别？
 golang是静态编译，编译完成后，即可在操作系统上运行。可以交叉编译打包不同os和arch的代码。java是动态编译，java中间存在一层jvm虚拟机， java不支持多继承，golang通过struct的成员变量实现多继承 golang的goroutine只有2kb左右，而java的thread对应着内核的一个线程会达到2mb左右，资源开销不是一个级别。    golang的反射说一下
golang类似java的reflect提供了也提供了reflect的包，内部有相关的接口和方法使用。
核心的两个type分别是 Type和Value
golang提供了
t := reflect.TypeOf(person) v := reflect.ValueOf(person) 通过反射获取field的相关信息以及tag等
func testReflect(person Person) { t := reflect.TypeOf(person) v := reflect.ValueOf(person) for i := 0; i &lt; t."/>

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/custom.css">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="/" title="Lulu" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="/img/placeholder.png">
				</div><div class="logo__item logo__text">
					<div class="logo__title">Lulu</div>
					<div class="logo__tagline">Lulu is arrongant cat</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">About</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/post/k8s-client-informer%E6%9C%BA%E5%88%B6/">
				
				<span class="menu__text">K8s Client Informer mechanism</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title"></h1>
			<div class="post__meta meta"><div class="meta__item-author meta__item">
	<svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2 0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class="meta__text">Frank Silva</span>
</div></div>
		</header>
		<div class="content post__content clearfix">
			<h1 id="golang">Golang</h1>
<ul>
<li>
<p>defer的执行顺序，能改变返回值吗</p>
<p>defer的执行顺序和栈类似，属于后进先出</p>
<p>defer在return之后执行，但是在函数退出之前，defer可以修改返回值。通过有名返回变量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">changeReturn</span>() (<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">i</span> = <span style="color:#ae81ff">32</span>

	<span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;defer \n&#34;</span>)
		<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>
	}()

	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span>
}

</code></pre></div></li>
<li>
<p>go 的tag用处</p>
<ul>
<li>json序列化</li>
<li>gorm的表名映射</li>
<li>binding，validate 等gin web 框架需要的绑定和校验功能</li>
</ul>
</li>
<li>
<p>Golang的和java的区别？</p>
<ul>
<li>golang是静态编译，编译完成后，即可在操作系统上运行。可以交叉编译打包不同os和arch的代码。java是动态编译，java中间存在一层jvm虚拟机，</li>
<li>java不支持多继承，golang通过struct的成员变量实现多继承</li>
<li>golang的goroutine只有2kb左右，而java的thread对应着内核的一个线程会达到2mb左右，资源开销不是一个级别。</li>
</ul>
</li>
<li>
<p>golang的反射说一下</p>
<p>golang类似java的reflect提供了也提供了reflect的包，内部有相关的接口和方法使用。</p>
<p>核心的两个type分别是 Type和Value</p>
<p>golang提供了</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">	<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">TypeOf</span>(<span style="color:#a6e22e">person</span>)
	<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#a6e22e">person</span>)
</code></pre></div><p>通过反射获取field的相关信息以及tag等</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">testReflect</span>(<span style="color:#a6e22e">person</span> <span style="color:#a6e22e">Person</span>) {
	<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">TypeOf</span>(<span style="color:#a6e22e">person</span>)
	<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#a6e22e">person</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">NumField</span>(); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">field</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Field</span>(<span style="color:#a6e22e">i</span>)
		<span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Field</span>(<span style="color:#a6e22e">i</span>).<span style="color:#a6e22e">Interface</span>().(<span style="color:#66d9ef">string</span>)
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;field %s tag %s value %s \n&#34;</span>, <span style="color:#a6e22e">field</span>.<span style="color:#a6e22e">Name</span>, <span style="color:#a6e22e">field</span>.<span style="color:#a6e22e">Tag</span>, <span style="color:#a6e22e">value</span>)
	}
}
</code></pre></div></li>
<li>
<p>golang的垃圾回收机制</p>
</li>
<li>
<p>go slice是怎么扩容的？</p>
<p>Go &lt;= 1.17</p>
<p>如果当前容量小于1024，则判断所需容量是否大于原来容量2倍，如果大于，当前容量加上所需容量；否则当前容量乘2。</p>
<p>如果当前容量大于1024，则每次按照1.25倍速度递增容量，也就是每次加上cap/4。</p>
</li>
<li>
<p>有缓冲和无缓冲的channel区别</p>
</li>
<li>
<p>make和new区别</p>
<ul>
<li>make和new作用的变量类型不一样，make是在创建channel ，slice，map的时候使用的，new是string，int，以及自定义的struct使用</li>
<li>make返回的是引用类型，我对slice进行修改是直接修改这个引用的值，不会产生值的拷贝。new返回的是指针。相当于&amp;struct{}</li>
</ul>
</li>
<li>
<p>channel死锁的场景</p>
<ul>
<li>当一个channel没有数据直接读取的时候会死锁，解决方案是通过select读取，设置default默认值</li>
</ul>
</li>
<li>
<p>说说Context</p>
<p>Context主要用在goroutine之前传参。</p>
<p>Context有withValue等方法，可以将参数放在context中，进行传递</p>
</li>
<li>
<p>go怎么排查内存泄露</p>
<p>使用pprof</p>
</li>
<li>
<p>map是安全的吗</p>
<p>怎么保证线程安全</p>
<p>使用mutex锁，通过channel进行交互。</p>
</li>
<li>
<p>channel实现java里的coutdownlatch</p>
<p>可以使用sync.WaitGroup</p>
</li>
<li>
<p>如何控制并发</p>
<p>协程池，有相关的开源工具，类似ants</p>
</li>
<li>
<p>golang的指针你说一下</p>
<p>指针是一种数据类型，用于存储值的内存地址，通常在基本类型之前加*来表明是一个指针，new方法返回的就是指针。</p>
<p>用法可以修改传值参数，因为在golang里只有值传递，所以默认情况下传的是值的副本。在函数中修改的话是无效的。</p>
<p>出了map，slice，channel，这些属于引用。可以直接修改。</p>
<p>所以如果要修改传参的值，则需要指针来处理。</p>
</li>
</ul>

		</div>
	</article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="Frank Silva avatar" src="/img/avatar.png" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">About Frank Silva</span>
	</div>
	<div class="authorbox__description">
		Pursue Consummate Coding.
	</div>
</div>

<nav class="pager flex">
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/post/linux/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 Frank Silva.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
<script src="/js/custom.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>
</body>
</html>