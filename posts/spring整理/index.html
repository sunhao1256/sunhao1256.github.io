<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Hao Sun</title>
<meta name=keywords content>
<meta name=description content="@Override@Nullablepublic Object invoke(MethodInvocation mi) throws Throwable {if (!(mi instanceof ProxyMethodInvocation)) {throw new IllegalStateException(&#34;MethodInvocation is not a Spring ProxyMethodInvocation: &#34; + mi);}ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);JoinPointMatch jpm = getJoinPointMatch(pmi);return invokeAdviceMethod(pjp, jpm, null, null);}当在Sping中配置的Bean存在相互依赖，Spring是怎么处理的 针对原型Bean直接抛出异常，不支持。
单例Bean，Spring使用3个Map做缓存，来处理。
分别是：一级缓存Spring最终保存的单例对象Map，二级缓存建造Spring单例对象的匿名工厂对象返回的就是三级缓存需要的，三级缓存是允许提前被依赖的单例对象。
阐述一个Bean获取的流程  尝试获取单例Bean 检查一级缓存是否有，没有的话，检查当前获取的Bean是否正在创建，如果正在创建即出现了Bean互相依赖情况，检查三级缓存是否已经有提前可被依赖的对象，如果没有的话，检查二级缓存是否有其工厂，有的话，使用工厂，实例化这个Bean，放入三级缓存里。供其他Bean依赖使用 没获取到，可能是原型Bean，也可能是单例Bean没有实例化 检查如果是原型Bean，而且正在创建中，即出现了原型Bean被依赖的情况，直接抛出异常 准备BeanDefinition，如果档期工厂没有相应的BD，而且父工厂又存在BD，使用父工厂的getBean方法去获取Bean 标记Bean创建过了 从当前工厂读取BD,并且转为RootBeanDefinition，获取期间，还要检查父工厂是否也有该Bean的BD，有的话，以父工厂得BD为基础，子工厂得BD覆盖掉其属性 检查BD是不是抽象的，无法实例化的类，抛出异常 检查BD中得DependsOn属性，针对所有Depend，循环实例化，如果检查到有Depend得Bean又依赖于当前目标Bean，抛出异常，互相提前依赖了。并且建立相关关系，所以DependOn意义是，依赖于一个完全实例化完成后的Bean 如果是单例的话，开始创建单例Bean，创建匿名工厂对象 标记单例Bean正在被创建 使用工厂对象去调用getObject方法 实际上执行了createBean方法 根据之前的RootBD，解析出需要实例化的Class对象 检查MethodOverrides目标方法是否存在Class对象中 在实例化对象之前，给InstantiationAwareBeanPostProcessor机会去改变实例，调用其postProcessBeforeInstantiation，AOP就是在这里实现的，此外，如果返回了，还会调用BPP的postProcessAfterInitialization，但不会调用postProcessBeforeInitialization了 如果没有被InstantiationAwareBeanPostProcessor改变了的话，开始进入真正的实例化方法 实例化一个BeanWrapperImpl去封装实例 解析Class对象，确定Class对象有Public修饰符 如果有FactoryMethod的话，直接调用FactoryMethod返回实例，封装在BeanWrapperImpl，这里面也会初始化initBeanWrapper，将属性编辑器注入到BeanWrapperImpl身上，用于后续的属性注入 开始解析构造函数或者是FactoryMethod，如果解析过了，直接去实例化 否则进入构造函数解析 解析之前，看BPP有没有提供了构造函数，即SmartInstantiationAwareBeanPostProcessor的determineCandidateConstructors方法执行，如果返回了构造函数，就用BPP的了。 没有的话，进入默认的解析，依赖先看缓存里有没有解析过的参数，因为构造方法注入的话，很消耗性能，没有缓存的话，先看用户获取bean时有没有传入args，即构造函数的参数。没有的话，而且只有一个候选的构造函数，就直接用使用无参的了，没有的话，先去解析参数，construct-arg，既可以时Index，也可以是name。根据用户传入的arg长度，去解析。 最后解析完成后，使用实例化策略去实例化即可，这里也可使用cglib去处理，然后封装在BeanWrapperImpl中 至此，BeanWapper里已经包含了我们的目标对象的实例了 然后创建二级缓存，将上一步BeanWapper里的实例，作为二级缓存返回的对象，加载缓存里 至此，二级缓存的工厂加入 了。当在一开始获bean，一级获取不到，获取二级有工厂的时候，就会把BeanWapper的实例暴露出去，供后续使用 然后开始初始化实例 将上面暴露出来的示例进行属性注入 给InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation在属性注入之前最后一次机会，去改变Bean，并且阻止Bean的属性注入 判断属性注入的是byName还是byType，针对所有的非简单的属性，还有排除所有的ignoredDependencyInterfaces中的接口。进行getBean操作，保存到PropertyValues中 使用InstantiationAwareBeanPostProcessor的postProcessProperties，可以进行修改属性。继续使用postProcessPropertyValues，继续可以更该属性 得到所有属性后，应用属性到Bean实例身上，在应用属性的时候，会找到前工厂里的所有的TypeConverter去将属性变为需要的属性，如果变不成会报错 至此，属性赋值完毕 复制完毕后，开始初始化Bean，先激活所有的aware方法， 调用BPP的postProcessBeforeInitialization初始化之前方法，记住，这里的初始化，是Bean已经实例化之后的事情了，是执行其他事情的初始化 执行afterPropertiesSet方法，在执行init-methods方法 调用BPP的postProcessAfterInitialization初始化以后方法 至此返回暴露的bean，即getBean结束 最后处理销毁的方法，即出发destory-method的方法  Spring是如何处理掉循环依赖的  针对非单例Bean出现循环依赖直接抛出异常 单例Bean Spring存在3个缓存Map  Spring完全生成好的BeanMap，key是Bean的name，Value是实例对象 Spring生成Bean的工厂Map，key是Bean的name，value是实现了ObjectFactory接口的实例对象 Spring尚未初始化，即赋予属性或者其他初始化动作的Bean实例Map，key是Bean的name，value是工厂map的工厂的返回值，即ObjectFactory的getObject方法结果   假设存在对象A依赖于对象B，对象Bean依赖于对象A  Spring根据A的name，首先取BeanMap里找是否有A的实例，没有的话，检查A是否正在创建，如果正在创建，则说明出现了循环依赖。（需要获取A，发现A又在创建，表名有其他bean需要A），尝试从可提前依赖的BeanMap获取EarlyBeanReference，如果没有，则尝试从工厂Map里找A对应的工厂对象，如果有工厂对象，则调用工厂对象进行返回，并且将工厂返回的Bean实例作为EarlyBeanReference，放入未完全实例化结束BeanMap里，删除工厂Map对应的value。此时工厂Map为空。 此时，A没有正在创建，继续 标记A正在创建，根绝BeanDefinition生成Bean实例对象，（此时对象实例已经生成完毕，但是还没有初始化），并且把A的创建工厂，放入工厂Map，而这个创建工厂getObject返回值就是刚才生成的实例对象，并且给SmartInstantiationAwareBeanPostProcessor接口机会取改变这个EarlyBeanReference对象。 得到实例化后的A对象，开始注入A的属性，发现A的属性b，需要B对象。 B对象开始获取（此时，A还没有结束，即一级缓存中没有A，二级缓存中有A的工厂Map） B的获取如上述一致， 直至B实例化结束，开始注入B的属性，发现B的属性a，需要A对象 又到了A对象开始获取 此时，进入第一个流程，发现一级缓存里没有A，而A又正在创建中，出现循环依赖，去二级缓存里找A的工厂Map，调用工厂Map方法去，得到了EarlyBeanReference，放入三级缓存里，返回回去 即此时，B注入属性成功，并且返回了一个EarlyBeanReference，即当前正在创建的A对象实例。 B注入成功属性后，B实例化完全结束，结束后，清除B的二三级缓存，加入一级缓存并返回 此时回到了A的注入B属性逻辑中，A得到了B实例。而这个实例里的A属性对象，和当前获取A的对象是一个 A继续完成初始化动作，最后A实例化完全结束，清楚A的二三级缓存，加入一级缓存并返回   只有2个缓存行吗？为什么一定要3个  BeanMap无用质疑是需要的 如果只有工厂Map而没有，可提前依赖的BeanMap的话，那么在一开始从缓存中获取Bean，一级缓存无法获取到，直接就有工厂Bean，一旦有工厂就调用工厂返回的值，这样是不行的，因为在工厂调用Bean的时候，有很多动作就会进行重复，比如工厂获取的时候，可以给SmartInstantiationAwareBeanPostProcessor机会去更改EarlyBeanReference对象，重复执行了。第二，与工厂模式的思想违背，工厂只需要制造一次，而不是每次都制造。 如果只有可提前依赖的BeanMap，而没有工厂Map。实际上是可以的，只不过没有工厂的话，会将大部分工作都抛给创建Bean的流程里，例如SmartInstantiationAwareBeanPostProcessor等工厂应该负责的工作    ApplicationContext的Refresh方法  Enviroment，环境参数，根据不同的环境，实现Environment不同的子类，例如Web环境会实现，StandardServletEnvironment，默认是实现StandardEnvironment，包含很多环境变量，系统变量，java环境变量，Servlet环境变量 创建beanFactory作为成员变量，ApplicationContext自身也实现了BeanFactory接口，只不过具体实现的方法是成员变量的beanFactory的方法、 填充工厂  增加SPEL表达式解析器 属性编辑器注入 增加一个ApplicationContextAwareProcessor的BPP，在Bean实例化之后，激活实现了aware接口的方法的一个BPP 配置忽略某些类型的属性自动注入，增加某些类型自动注入   postProcessBeanFactory：留给子类去实现 记录启动路径 激活BeanFactoryPostProcessor，invokeBeanFactoryPostProcessors 注册BeanPostProcessor 初始化国际化文件 初始化initApplicationEventMulticaster，事件传送器，用于发送事件 注册事件监听器 设置ConversionService 锁定所有BeanDefinitions，防止改变 实例化剩下所有的no-lazy实例 调用所有实现LifeCycle接口的bean 发送ContextRefreshedEvent事件  BeanFactoryPostProcessor和BeanPostProcessor区别   BeanFactoryPostProcessor是可以修改Bean的元数据，是控制BeanFactory的，而BeanPostProcessor是Bean实例的处理器，可以修改Bean的实例">
<meta name=author content="Hao Sun">
<link rel=canonical href=https://luluhome.site:8101/posts/spring%E6%95%B4%E7%90%86/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://luluhome.site:8101/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=https://luluhome.site:8101/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://luluhome.site:8101/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://luluhome.site:8101/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://luluhome.site:8101/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.89.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content>
<meta property="og:description" content="@Override@Nullablepublic Object invoke(MethodInvocation mi) throws Throwable {if (!(mi instanceof ProxyMethodInvocation)) {throw new IllegalStateException(&#34;MethodInvocation is not a Spring ProxyMethodInvocation: &#34; + mi);}ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);JoinPointMatch jpm = getJoinPointMatch(pmi);return invokeAdviceMethod(pjp, jpm, null, null);}当在Sping中配置的Bean存在相互依赖，Spring是怎么处理的 针对原型Bean直接抛出异常，不支持。
单例Bean，Spring使用3个Map做缓存，来处理。
分别是：一级缓存Spring最终保存的单例对象Map，二级缓存建造Spring单例对象的匿名工厂对象返回的就是三级缓存需要的，三级缓存是允许提前被依赖的单例对象。
阐述一个Bean获取的流程  尝试获取单例Bean 检查一级缓存是否有，没有的话，检查当前获取的Bean是否正在创建，如果正在创建即出现了Bean互相依赖情况，检查三级缓存是否已经有提前可被依赖的对象，如果没有的话，检查二级缓存是否有其工厂，有的话，使用工厂，实例化这个Bean，放入三级缓存里。供其他Bean依赖使用 没获取到，可能是原型Bean，也可能是单例Bean没有实例化 检查如果是原型Bean，而且正在创建中，即出现了原型Bean被依赖的情况，直接抛出异常 准备BeanDefinition，如果档期工厂没有相应的BD，而且父工厂又存在BD，使用父工厂的getBean方法去获取Bean 标记Bean创建过了 从当前工厂读取BD,并且转为RootBeanDefinition，获取期间，还要检查父工厂是否也有该Bean的BD，有的话，以父工厂得BD为基础，子工厂得BD覆盖掉其属性 检查BD是不是抽象的，无法实例化的类，抛出异常 检查BD中得DependsOn属性，针对所有Depend，循环实例化，如果检查到有Depend得Bean又依赖于当前目标Bean，抛出异常，互相提前依赖了。并且建立相关关系，所以DependOn意义是，依赖于一个完全实例化完成后的Bean 如果是单例的话，开始创建单例Bean，创建匿名工厂对象 标记单例Bean正在被创建 使用工厂对象去调用getObject方法 实际上执行了createBean方法 根据之前的RootBD，解析出需要实例化的Class对象 检查MethodOverrides目标方法是否存在Class对象中 在实例化对象之前，给InstantiationAwareBeanPostProcessor机会去改变实例，调用其postProcessBeforeInstantiation，AOP就是在这里实现的，此外，如果返回了，还会调用BPP的postProcessAfterInitialization，但不会调用postProcessBeforeInitialization了 如果没有被InstantiationAwareBeanPostProcessor改变了的话，开始进入真正的实例化方法 实例化一个BeanWrapperImpl去封装实例 解析Class对象，确定Class对象有Public修饰符 如果有FactoryMethod的话，直接调用FactoryMethod返回实例，封装在BeanWrapperImpl，这里面也会初始化initBeanWrapper，将属性编辑器注入到BeanWrapperImpl身上，用于后续的属性注入 开始解析构造函数或者是FactoryMethod，如果解析过了，直接去实例化 否则进入构造函数解析 解析之前，看BPP有没有提供了构造函数，即SmartInstantiationAwareBeanPostProcessor的determineCandidateConstructors方法执行，如果返回了构造函数，就用BPP的了。 没有的话，进入默认的解析，依赖先看缓存里有没有解析过的参数，因为构造方法注入的话，很消耗性能，没有缓存的话，先看用户获取bean时有没有传入args，即构造函数的参数。没有的话，而且只有一个候选的构造函数，就直接用使用无参的了，没有的话，先去解析参数，construct-arg，既可以时Index，也可以是name。根据用户传入的arg长度，去解析。 最后解析完成后，使用实例化策略去实例化即可，这里也可使用cglib去处理，然后封装在BeanWrapperImpl中 至此，BeanWapper里已经包含了我们的目标对象的实例了 然后创建二级缓存，将上一步BeanWapper里的实例，作为二级缓存返回的对象，加载缓存里 至此，二级缓存的工厂加入 了。当在一开始获bean，一级获取不到，获取二级有工厂的时候，就会把BeanWapper的实例暴露出去，供后续使用 然后开始初始化实例 将上面暴露出来的示例进行属性注入 给InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation在属性注入之前最后一次机会，去改变Bean，并且阻止Bean的属性注入 判断属性注入的是byName还是byType，针对所有的非简单的属性，还有排除所有的ignoredDependencyInterfaces中的接口。进行getBean操作，保存到PropertyValues中 使用InstantiationAwareBeanPostProcessor的postProcessProperties，可以进行修改属性。继续使用postProcessPropertyValues，继续可以更该属性 得到所有属性后，应用属性到Bean实例身上，在应用属性的时候，会找到前工厂里的所有的TypeConverter去将属性变为需要的属性，如果变不成会报错 至此，属性赋值完毕 复制完毕后，开始初始化Bean，先激活所有的aware方法， 调用BPP的postProcessBeforeInitialization初始化之前方法，记住，这里的初始化，是Bean已经实例化之后的事情了，是执行其他事情的初始化 执行afterPropertiesSet方法，在执行init-methods方法 调用BPP的postProcessAfterInitialization初始化以后方法 至此返回暴露的bean，即getBean结束 最后处理销毁的方法，即出发destory-method的方法  Spring是如何处理掉循环依赖的  针对非单例Bean出现循环依赖直接抛出异常 单例Bean Spring存在3个缓存Map  Spring完全生成好的BeanMap，key是Bean的name，Value是实例对象 Spring生成Bean的工厂Map，key是Bean的name，value是实现了ObjectFactory接口的实例对象 Spring尚未初始化，即赋予属性或者其他初始化动作的Bean实例Map，key是Bean的name，value是工厂map的工厂的返回值，即ObjectFactory的getObject方法结果   假设存在对象A依赖于对象B，对象Bean依赖于对象A  Spring根据A的name，首先取BeanMap里找是否有A的实例，没有的话，检查A是否正在创建，如果正在创建，则说明出现了循环依赖。（需要获取A，发现A又在创建，表名有其他bean需要A），尝试从可提前依赖的BeanMap获取EarlyBeanReference，如果没有，则尝试从工厂Map里找A对应的工厂对象，如果有工厂对象，则调用工厂对象进行返回，并且将工厂返回的Bean实例作为EarlyBeanReference，放入未完全实例化结束BeanMap里，删除工厂Map对应的value。此时工厂Map为空。 此时，A没有正在创建，继续 标记A正在创建，根绝BeanDefinition生成Bean实例对象，（此时对象实例已经生成完毕，但是还没有初始化），并且把A的创建工厂，放入工厂Map，而这个创建工厂getObject返回值就是刚才生成的实例对象，并且给SmartInstantiationAwareBeanPostProcessor接口机会取改变这个EarlyBeanReference对象。 得到实例化后的A对象，开始注入A的属性，发现A的属性b，需要B对象。 B对象开始获取（此时，A还没有结束，即一级缓存中没有A，二级缓存中有A的工厂Map） B的获取如上述一致， 直至B实例化结束，开始注入B的属性，发现B的属性a，需要A对象 又到了A对象开始获取 此时，进入第一个流程，发现一级缓存里没有A，而A又正在创建中，出现循环依赖，去二级缓存里找A的工厂Map，调用工厂Map方法去，得到了EarlyBeanReference，放入三级缓存里，返回回去 即此时，B注入属性成功，并且返回了一个EarlyBeanReference，即当前正在创建的A对象实例。 B注入成功属性后，B实例化完全结束，结束后，清除B的二三级缓存，加入一级缓存并返回 此时回到了A的注入B属性逻辑中，A得到了B实例。而这个实例里的A属性对象，和当前获取A的对象是一个 A继续完成初始化动作，最后A实例化完全结束，清楚A的二三级缓存，加入一级缓存并返回   只有2个缓存行吗？为什么一定要3个  BeanMap无用质疑是需要的 如果只有工厂Map而没有，可提前依赖的BeanMap的话，那么在一开始从缓存中获取Bean，一级缓存无法获取到，直接就有工厂Bean，一旦有工厂就调用工厂返回的值，这样是不行的，因为在工厂调用Bean的时候，有很多动作就会进行重复，比如工厂获取的时候，可以给SmartInstantiationAwareBeanPostProcessor机会去更改EarlyBeanReference对象，重复执行了。第二，与工厂模式的思想违背，工厂只需要制造一次，而不是每次都制造。 如果只有可提前依赖的BeanMap，而没有工厂Map。实际上是可以的，只不过没有工厂的话，会将大部分工作都抛给创建Bean的流程里，例如SmartInstantiationAwareBeanPostProcessor等工厂应该负责的工作    ApplicationContext的Refresh方法  Enviroment，环境参数，根据不同的环境，实现Environment不同的子类，例如Web环境会实现，StandardServletEnvironment，默认是实现StandardEnvironment，包含很多环境变量，系统变量，java环境变量，Servlet环境变量 创建beanFactory作为成员变量，ApplicationContext自身也实现了BeanFactory接口，只不过具体实现的方法是成员变量的beanFactory的方法、 填充工厂  增加SPEL表达式解析器 属性编辑器注入 增加一个ApplicationContextAwareProcessor的BPP，在Bean实例化之后，激活实现了aware接口的方法的一个BPP 配置忽略某些类型的属性自动注入，增加某些类型自动注入   postProcessBeanFactory：留给子类去实现 记录启动路径 激活BeanFactoryPostProcessor，invokeBeanFactoryPostProcessors 注册BeanPostProcessor 初始化国际化文件 初始化initApplicationEventMulticaster，事件传送器，用于发送事件 注册事件监听器 设置ConversionService 锁定所有BeanDefinitions，防止改变 实例化剩下所有的no-lazy实例 调用所有实现LifeCycle接口的bean 发送ContextRefreshedEvent事件  BeanFactoryPostProcessor和BeanPostProcessor区别   BeanFactoryPostProcessor是可以修改Bean的元数据，是控制BeanFactory的，而BeanPostProcessor是Bean实例的处理器，可以修改Bean的实例">
<meta property="og:type" content="article">
<meta property="og:url" content="https://luluhome.site:8101/posts/spring%E6%95%B4%E7%90%86/"><meta property="og:image" content="https://luluhome.site:8101/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts">
<meta property="og:site_name" content="Hao Sun">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://luluhome.site:8101/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name=twitter:title content>
<meta name=twitter:description content="@Override@Nullablepublic Object invoke(MethodInvocation mi) throws Throwable {if (!(mi instanceof ProxyMethodInvocation)) {throw new IllegalStateException(&#34;MethodInvocation is not a Spring ProxyMethodInvocation: &#34; + mi);}ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);JoinPointMatch jpm = getJoinPointMatch(pmi);return invokeAdviceMethod(pjp, jpm, null, null);}当在Sping中配置的Bean存在相互依赖，Spring是怎么处理的 针对原型Bean直接抛出异常，不支持。
单例Bean，Spring使用3个Map做缓存，来处理。
分别是：一级缓存Spring最终保存的单例对象Map，二级缓存建造Spring单例对象的匿名工厂对象返回的就是三级缓存需要的，三级缓存是允许提前被依赖的单例对象。
阐述一个Bean获取的流程  尝试获取单例Bean 检查一级缓存是否有，没有的话，检查当前获取的Bean是否正在创建，如果正在创建即出现了Bean互相依赖情况，检查三级缓存是否已经有提前可被依赖的对象，如果没有的话，检查二级缓存是否有其工厂，有的话，使用工厂，实例化这个Bean，放入三级缓存里。供其他Bean依赖使用 没获取到，可能是原型Bean，也可能是单例Bean没有实例化 检查如果是原型Bean，而且正在创建中，即出现了原型Bean被依赖的情况，直接抛出异常 准备BeanDefinition，如果档期工厂没有相应的BD，而且父工厂又存在BD，使用父工厂的getBean方法去获取Bean 标记Bean创建过了 从当前工厂读取BD,并且转为RootBeanDefinition，获取期间，还要检查父工厂是否也有该Bean的BD，有的话，以父工厂得BD为基础，子工厂得BD覆盖掉其属性 检查BD是不是抽象的，无法实例化的类，抛出异常 检查BD中得DependsOn属性，针对所有Depend，循环实例化，如果检查到有Depend得Bean又依赖于当前目标Bean，抛出异常，互相提前依赖了。并且建立相关关系，所以DependOn意义是，依赖于一个完全实例化完成后的Bean 如果是单例的话，开始创建单例Bean，创建匿名工厂对象 标记单例Bean正在被创建 使用工厂对象去调用getObject方法 实际上执行了createBean方法 根据之前的RootBD，解析出需要实例化的Class对象 检查MethodOverrides目标方法是否存在Class对象中 在实例化对象之前，给InstantiationAwareBeanPostProcessor机会去改变实例，调用其postProcessBeforeInstantiation，AOP就是在这里实现的，此外，如果返回了，还会调用BPP的postProcessAfterInitialization，但不会调用postProcessBeforeInitialization了 如果没有被InstantiationAwareBeanPostProcessor改变了的话，开始进入真正的实例化方法 实例化一个BeanWrapperImpl去封装实例 解析Class对象，确定Class对象有Public修饰符 如果有FactoryMethod的话，直接调用FactoryMethod返回实例，封装在BeanWrapperImpl，这里面也会初始化initBeanWrapper，将属性编辑器注入到BeanWrapperImpl身上，用于后续的属性注入 开始解析构造函数或者是FactoryMethod，如果解析过了，直接去实例化 否则进入构造函数解析 解析之前，看BPP有没有提供了构造函数，即SmartInstantiationAwareBeanPostProcessor的determineCandidateConstructors方法执行，如果返回了构造函数，就用BPP的了。 没有的话，进入默认的解析，依赖先看缓存里有没有解析过的参数，因为构造方法注入的话，很消耗性能，没有缓存的话，先看用户获取bean时有没有传入args，即构造函数的参数。没有的话，而且只有一个候选的构造函数，就直接用使用无参的了，没有的话，先去解析参数，construct-arg，既可以时Index，也可以是name。根据用户传入的arg长度，去解析。 最后解析完成后，使用实例化策略去实例化即可，这里也可使用cglib去处理，然后封装在BeanWrapperImpl中 至此，BeanWapper里已经包含了我们的目标对象的实例了 然后创建二级缓存，将上一步BeanWapper里的实例，作为二级缓存返回的对象，加载缓存里 至此，二级缓存的工厂加入 了。当在一开始获bean，一级获取不到，获取二级有工厂的时候，就会把BeanWapper的实例暴露出去，供后续使用 然后开始初始化实例 将上面暴露出来的示例进行属性注入 给InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation在属性注入之前最后一次机会，去改变Bean，并且阻止Bean的属性注入 判断属性注入的是byName还是byType，针对所有的非简单的属性，还有排除所有的ignoredDependencyInterfaces中的接口。进行getBean操作，保存到PropertyValues中 使用InstantiationAwareBeanPostProcessor的postProcessProperties，可以进行修改属性。继续使用postProcessPropertyValues，继续可以更该属性 得到所有属性后，应用属性到Bean实例身上，在应用属性的时候，会找到前工厂里的所有的TypeConverter去将属性变为需要的属性，如果变不成会报错 至此，属性赋值完毕 复制完毕后，开始初始化Bean，先激活所有的aware方法， 调用BPP的postProcessBeforeInitialization初始化之前方法，记住，这里的初始化，是Bean已经实例化之后的事情了，是执行其他事情的初始化 执行afterPropertiesSet方法，在执行init-methods方法 调用BPP的postProcessAfterInitialization初始化以后方法 至此返回暴露的bean，即getBean结束 最后处理销毁的方法，即出发destory-method的方法  Spring是如何处理掉循环依赖的  针对非单例Bean出现循环依赖直接抛出异常 单例Bean Spring存在3个缓存Map  Spring完全生成好的BeanMap，key是Bean的name，Value是实例对象 Spring生成Bean的工厂Map，key是Bean的name，value是实现了ObjectFactory接口的实例对象 Spring尚未初始化，即赋予属性或者其他初始化动作的Bean实例Map，key是Bean的name，value是工厂map的工厂的返回值，即ObjectFactory的getObject方法结果   假设存在对象A依赖于对象B，对象Bean依赖于对象A  Spring根据A的name，首先取BeanMap里找是否有A的实例，没有的话，检查A是否正在创建，如果正在创建，则说明出现了循环依赖。（需要获取A，发现A又在创建，表名有其他bean需要A），尝试从可提前依赖的BeanMap获取EarlyBeanReference，如果没有，则尝试从工厂Map里找A对应的工厂对象，如果有工厂对象，则调用工厂对象进行返回，并且将工厂返回的Bean实例作为EarlyBeanReference，放入未完全实例化结束BeanMap里，删除工厂Map对应的value。此时工厂Map为空。 此时，A没有正在创建，继续 标记A正在创建，根绝BeanDefinition生成Bean实例对象，（此时对象实例已经生成完毕，但是还没有初始化），并且把A的创建工厂，放入工厂Map，而这个创建工厂getObject返回值就是刚才生成的实例对象，并且给SmartInstantiationAwareBeanPostProcessor接口机会取改变这个EarlyBeanReference对象。 得到实例化后的A对象，开始注入A的属性，发现A的属性b，需要B对象。 B对象开始获取（此时，A还没有结束，即一级缓存中没有A，二级缓存中有A的工厂Map） B的获取如上述一致， 直至B实例化结束，开始注入B的属性，发现B的属性a，需要A对象 又到了A对象开始获取 此时，进入第一个流程，发现一级缓存里没有A，而A又正在创建中，出现循环依赖，去二级缓存里找A的工厂Map，调用工厂Map方法去，得到了EarlyBeanReference，放入三级缓存里，返回回去 即此时，B注入属性成功，并且返回了一个EarlyBeanReference，即当前正在创建的A对象实例。 B注入成功属性后，B实例化完全结束，结束后，清除B的二三级缓存，加入一级缓存并返回 此时回到了A的注入B属性逻辑中，A得到了B实例。而这个实例里的A属性对象，和当前获取A的对象是一个 A继续完成初始化动作，最后A实例化完全结束，清楚A的二三级缓存，加入一级缓存并返回   只有2个缓存行吗？为什么一定要3个  BeanMap无用质疑是需要的 如果只有工厂Map而没有，可提前依赖的BeanMap的话，那么在一开始从缓存中获取Bean，一级缓存无法获取到，直接就有工厂Bean，一旦有工厂就调用工厂返回的值，这样是不行的，因为在工厂调用Bean的时候，有很多动作就会进行重复，比如工厂获取的时候，可以给SmartInstantiationAwareBeanPostProcessor机会去更改EarlyBeanReference对象，重复执行了。第二，与工厂模式的思想违背，工厂只需要制造一次，而不是每次都制造。 如果只有可提前依赖的BeanMap，而没有工厂Map。实际上是可以的，只不过没有工厂的话，会将大部分工作都抛给创建Bean的流程里，例如SmartInstantiationAwareBeanPostProcessor等工厂应该负责的工作    ApplicationContext的Refresh方法  Enviroment，环境参数，根据不同的环境，实现Environment不同的子类，例如Web环境会实现，StandardServletEnvironment，默认是实现StandardEnvironment，包含很多环境变量，系统变量，java环境变量，Servlet环境变量 创建beanFactory作为成员变量，ApplicationContext自身也实现了BeanFactory接口，只不过具体实现的方法是成员变量的beanFactory的方法、 填充工厂  增加SPEL表达式解析器 属性编辑器注入 增加一个ApplicationContextAwareProcessor的BPP，在Bean实例化之后，激活实现了aware接口的方法的一个BPP 配置忽略某些类型的属性自动注入，增加某些类型自动注入   postProcessBeanFactory：留给子类去实现 记录启动路径 激活BeanFactoryPostProcessor，invokeBeanFactoryPostProcessors 注册BeanPostProcessor 初始化国际化文件 初始化initApplicationEventMulticaster，事件传送器，用于发送事件 注册事件监听器 设置ConversionService 锁定所有BeanDefinitions，防止改变 实例化剩下所有的no-lazy实例 调用所有实现LifeCycle接口的bean 发送ContextRefreshedEvent事件  BeanFactoryPostProcessor和BeanPostProcessor区别   BeanFactoryPostProcessor是可以修改Bean的元数据，是控制BeanFactory的，而BeanPostProcessor是Bean实例的处理器，可以修改Bean的实例">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://luluhome.site:8101/posts/"},{"@type":"ListItem","position":2,"name":"","item":"https://luluhome.site:8101/posts/spring%E6%95%B4%E7%90%86/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"@Override\r@Nullable\rpublic Object invoke(MethodInvocation mi) throws Throwable {\rif (!(mi instanceof ProxyMethodInvocation)) {\rthrow new IllegalStateException(\u0026quot;MethodInvocation is not a Spring ProxyMethodInvocation: \u0026quot; + mi);\r}\rProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;\rProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);\rJoinPointMatch jpm = getJoinPointMatch(pmi);\rreturn invokeAdviceMethod(pjp, jpm, null, null);\r}\r当在Sping中配置的Bean存在相互依赖，Spring是怎么处理的 针对原型Bean直接抛出异常，不支持。\n单例Bean，Spring使用3个Map做缓存，来处理。\n分别是：一级缓存Spring最终保存的单例对象Map，二级缓存建造Spring单例对象的匿名工厂对象返回的就是三级缓存需要的，三级缓存是允许提前被依赖的单例对象。\n阐述一个Bean获取的流程  尝试获取单例Bean 检查一级缓存是否有，没有的话，检查当前获取的Bean是否正在创建，如果正在创建即出现了Bean互相依赖情况，检查三级缓存是否已经有提前可被依赖的对象，如果没有的话，检查二级缓存是否有其工厂，有的话，使用工厂，实例化这个Bean，放入三级缓存里。供其他Bean依赖使用 没获取到，可能是原型Bean，也可能是单例Bean没有实例化 检查如果是原型Bean，而且正在创建中，即出现了原型Bean被依赖的情况，直接抛出异常 准备BeanDefinition，如果档期工厂没有相应的BD，而且父工厂又存在BD，使用父工厂的getBean方法去获取Bean 标记Bean创建过了 从当前工厂读取BD,并且转为RootBeanDefinition，获取期间，还要检查父工厂是否也有该Bean的BD，有的话，以父工厂得BD为基础，子工厂得BD覆盖掉其属性 检查BD是不是抽象的，无法实例化的类，抛出异常 检查BD中得DependsOn属性，针对所有Depend，循环实例化，如果检查到有Depend得Bean又依赖于当前目标Bean，抛出异常，互相提前依赖了。并且建立相关关系，所以DependOn意义是，依赖于一个完全实例化完成后的Bean 如果是单例的话，开始创建单例Bean，创建匿名工厂对象 标记单例Bean正在被创建 使用工厂对象去调用getObject方法 实际上执行了createBean方法 根据之前的RootBD，解析出需要实例化的Class对象 检查MethodOverrides目标方法是否存在Class对象中 在实例化对象之前，给InstantiationAwareBeanPostProcessor机会去改变实例，调用其postProcessBeforeInstantiation，AOP就是在这里实现的，此外，如果返回了，还会调用BPP的postProcessAfterInitialization，但不会调用postProcessBeforeInitialization了 如果没有被InstantiationAwareBeanPostProcessor改变了的话，开始进入真正的实例化方法 实例化一个BeanWrapperImpl去封装实例 解析Class对象，确定Class对象有Public修饰符 如果有FactoryMethod的话，直接调用FactoryMethod返回实例，封装在BeanWrapperImpl，这里面也会初始化initBeanWrapper，将属性编辑器注入到BeanWrapperImpl身上，用于后续的属性注入 开始解析构造函数或者是FactoryMethod，如果解析过了，直接去实例化 否则进入构造函数解析 解析之前，看BPP有没有提供了构造函数，即SmartInstantiationAwareBeanPostProcessor的determineCandidateConstructors方法执行，如果返回了构造函数，就用BPP的了。 没有的话，进入默认的解析，依赖先看缓存里有没有解析过的参数，因为构造方法注入的话，很消耗性能，没有缓存的话，先看用户获取bean时有没有传入args，即构造函数的参数。没有的话，而且只有一个候选的构造函数，就直接用使用无参的了，没有的话，先去解析参数，construct-arg，既可以时Index，也可以是name。根据用户传入的arg长度，去解析。 最后解析完成后，使用实例化策略去实例化即可，这里也可使用cglib去处理，然后封装在BeanWrapperImpl中 至此，BeanWapper里已经包含了我们的目标对象的实例了 然后创建二级缓存，将上一步BeanWapper里的实例，作为二级缓存返回的对象，加载缓存里 至此，二级缓存的工厂加入 了。当在一开始获bean，一级获取不到，获取二级有工厂的时候，就会把BeanWapper的实例暴露出去，供后续使用 然后开始初始化实例 将上面暴露出来的示例进行属性注入 给InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation在属性注入之前最后一次机会，去改变Bean，并且阻止Bean的属性注入 判断属性注入的是byName还是byType，针对所有的非简单的属性，还有排除所有的ignoredDependencyInterfaces中的接口。进行getBean操作，保存到PropertyValues中 使用InstantiationAwareBeanPostProcessor的postProcessProperties，可以进行修改属性。继续使用postProcessPropertyValues，继续可以更该属性 得到所有属性后，应用属性到Bean实例身上，在应用属性的时候，会找到前工厂里的所有的TypeConverter去将属性变为需要的属性，如果变不成会报错 至此，属性赋值完毕 复制完毕后，开始初始化Bean，先激活所有的aware方法， 调用BPP的postProcessBeforeInitialization初始化之前方法，记住，这里的初始化，是Bean已经实例化之后的事情了，是执行其他事情的初始化 执行afterPropertiesSet方法，在执行init-methods方法 调用BPP的postProcessAfterInitialization初始化以后方法 至此返回暴露的bean，即getBean结束 最后处理销毁的方法，即出发destory-method的方法  Spring是如何处理掉循环依赖的  针对非单例Bean出现循环依赖直接抛出异常 单例Bean Spring存在3个缓存Map  Spring完全生成好的BeanMap，key是Bean的name，Value是实例对象 Spring生成Bean的工厂Map，key是Bean的name，value是实现了ObjectFactory接口的实例对象 Spring尚未初始化，即赋予属性或者其他初始化动作的Bean实例Map，key是Bean的name，value是工厂map的工厂的返回值，即ObjectFactory的getObject方法结果   假设存在对象A依赖于对象B，对象Bean依赖于对象A  Spring根据A的name，首先取BeanMap里找是否有A的实例，没有的话，检查A是否正在创建，如果正在创建，则说明出现了循环依赖。（需要获取A，发现A又在创建，表名有其他bean需要A），尝试从可提前依赖的BeanMap获取EarlyBeanReference，如果没有，则尝试从工厂Map里找A对应的工厂对象，如果有工厂对象，则调用工厂对象进行返回，并且将工厂返回的Bean实例作为EarlyBeanReference，放入未完全实例化结束BeanMap里，删除工厂Map对应的value。此时工厂Map为空。 此时，A没有正在创建，继续 标记A正在创建，根绝BeanDefinition生成Bean实例对象，（此时对象实例已经生成完毕，但是还没有初始化），并且把A的创建工厂，放入工厂Map，而这个创建工厂getObject返回值就是刚才生成的实例对象，并且给SmartInstantiationAwareBeanPostProcessor接口机会取改变这个EarlyBeanReference对象。 得到实例化后的A对象，开始注入A的属性，发现A的属性b，需要B对象。 B对象开始获取（此时，A还没有结束，即一级缓存中没有A，二级缓存中有A的工厂Map） B的获取如上述一致， 直至B实例化结束，开始注入B的属性，发现B的属性a，需要A对象 又到了A对象开始获取 此时，进入第一个流程，发现一级缓存里没有A，而A又正在创建中，出现循环依赖，去二级缓存里找A的工厂Map，调用工厂Map方法去，得到了EarlyBeanReference，放入三级缓存里，返回回去 即此时，B注入属性成功，并且返回了一个EarlyBeanReference，即当前正在创建的A对象实例。 B注入成功属性后，B实例化完全结束，结束后，清除B的二三级缓存，加入一级缓存并返回 此时回到了A的注入B属性逻辑中，A得到了B实例。而这个实例里的A属性对象，和当前获取A的对象是一个 A继续完成初始化动作，最后A实例化完全结束，清楚A的二三级缓存，加入一级缓存并返回   只有2个缓存行吗？为什么一定要3个  BeanMap无用质疑是需要的 如果只有工厂Map而没有，可提前依赖的BeanMap的话，那么在一开始从缓存中获取Bean，一级缓存无法获取到，直接就有工厂Bean，一旦有工厂就调用工厂返回的值，这样是不行的，因为在工厂调用Bean的时候，有很多动作就会进行重复，比如工厂获取的时候，可以给SmartInstantiationAwareBeanPostProcessor机会去更改EarlyBeanReference对象，重复执行了。第二，与工厂模式的思想违背，工厂只需要制造一次，而不是每次都制造。 如果只有可提前依赖的BeanMap，而没有工厂Map。实际上是可以的，只不过没有工厂的话，会将大部分工作都抛给创建Bean的流程里，例如SmartInstantiationAwareBeanPostProcessor等工厂应该负责的工作    ApplicationContext的Refresh方法  Enviroment，环境参数，根据不同的环境，实现Environment不同的子类，例如Web环境会实现，StandardServletEnvironment，默认是实现StandardEnvironment，包含很多环境变量，系统变量，java环境变量，Servlet环境变量 创建beanFactory作为成员变量，ApplicationContext自身也实现了BeanFactory接口，只不过具体实现的方法是成员变量的beanFactory的方法、 填充工厂  增加SPEL表达式解析器 属性编辑器注入 增加一个ApplicationContextAwareProcessor的BPP，在Bean实例化之后，激活实现了aware接口的方法的一个BPP 配置忽略某些类型的属性自动注入，增加某些类型自动注入   postProcessBeanFactory：留给子类去实现 记录启动路径 激活BeanFactoryPostProcessor，invokeBeanFactoryPostProcessors 注册BeanPostProcessor 初始化国际化文件 初始化initApplicationEventMulticaster，事件传送器，用于发送事件 注册事件监听器 设置ConversionService 锁定所有BeanDefinitions，防止改变 实例化剩下所有的no-lazy实例 调用所有实现LifeCycle接口的bean 发送ContextRefreshedEvent事件  BeanFactoryPostProcessor和BeanPostProcessor区别   BeanFactoryPostProcessor是可以修改Bean的元数据，是控制BeanFactory的，而BeanPostProcessor是Bean实例的处理器，可以修改Bean的实例","keywords":[],"articleBody":"@Override\r@Nullable\rpublic Object invoke(MethodInvocation mi) throws Throwable {\rif (!(mi instanceof ProxyMethodInvocation)) {\rthrow new IllegalStateException(\"MethodInvocation is not a Spring ProxyMethodInvocation: \" + mi);\r}\rProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;\rProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);\rJoinPointMatch jpm = getJoinPointMatch(pmi);\rreturn invokeAdviceMethod(pjp, jpm, null, null);\r}\r当在Sping中配置的Bean存在相互依赖，Spring是怎么处理的 针对原型Bean直接抛出异常，不支持。\n单例Bean，Spring使用3个Map做缓存，来处理。\n分别是：一级缓存Spring最终保存的单例对象Map，二级缓存建造Spring单例对象的匿名工厂对象返回的就是三级缓存需要的，三级缓存是允许提前被依赖的单例对象。\n阐述一个Bean获取的流程  尝试获取单例Bean 检查一级缓存是否有，没有的话，检查当前获取的Bean是否正在创建，如果正在创建即出现了Bean互相依赖情况，检查三级缓存是否已经有提前可被依赖的对象，如果没有的话，检查二级缓存是否有其工厂，有的话，使用工厂，实例化这个Bean，放入三级缓存里。供其他Bean依赖使用 没获取到，可能是原型Bean，也可能是单例Bean没有实例化 检查如果是原型Bean，而且正在创建中，即出现了原型Bean被依赖的情况，直接抛出异常 准备BeanDefinition，如果档期工厂没有相应的BD，而且父工厂又存在BD，使用父工厂的getBean方法去获取Bean 标记Bean创建过了 从当前工厂读取BD,并且转为RootBeanDefinition，获取期间，还要检查父工厂是否也有该Bean的BD，有的话，以父工厂得BD为基础，子工厂得BD覆盖掉其属性 检查BD是不是抽象的，无法实例化的类，抛出异常 检查BD中得DependsOn属性，针对所有Depend，循环实例化，如果检查到有Depend得Bean又依赖于当前目标Bean，抛出异常，互相提前依赖了。并且建立相关关系，所以DependOn意义是，依赖于一个完全实例化完成后的Bean 如果是单例的话，开始创建单例Bean，创建匿名工厂对象 标记单例Bean正在被创建 使用工厂对象去调用getObject方法 实际上执行了createBean方法 根据之前的RootBD，解析出需要实例化的Class对象 检查MethodOverrides目标方法是否存在Class对象中 在实例化对象之前，给InstantiationAwareBeanPostProcessor机会去改变实例，调用其postProcessBeforeInstantiation，AOP就是在这里实现的，此外，如果返回了，还会调用BPP的postProcessAfterInitialization，但不会调用postProcessBeforeInitialization了 如果没有被InstantiationAwareBeanPostProcessor改变了的话，开始进入真正的实例化方法 实例化一个BeanWrapperImpl去封装实例 解析Class对象，确定Class对象有Public修饰符 如果有FactoryMethod的话，直接调用FactoryMethod返回实例，封装在BeanWrapperImpl，这里面也会初始化initBeanWrapper，将属性编辑器注入到BeanWrapperImpl身上，用于后续的属性注入 开始解析构造函数或者是FactoryMethod，如果解析过了，直接去实例化 否则进入构造函数解析 解析之前，看BPP有没有提供了构造函数，即SmartInstantiationAwareBeanPostProcessor的determineCandidateConstructors方法执行，如果返回了构造函数，就用BPP的了。 没有的话，进入默认的解析，依赖先看缓存里有没有解析过的参数，因为构造方法注入的话，很消耗性能，没有缓存的话，先看用户获取bean时有没有传入args，即构造函数的参数。没有的话，而且只有一个候选的构造函数，就直接用使用无参的了，没有的话，先去解析参数，construct-arg，既可以时Index，也可以是name。根据用户传入的arg长度，去解析。 最后解析完成后，使用实例化策略去实例化即可，这里也可使用cglib去处理，然后封装在BeanWrapperImpl中 至此，BeanWapper里已经包含了我们的目标对象的实例了 然后创建二级缓存，将上一步BeanWapper里的实例，作为二级缓存返回的对象，加载缓存里 至此，二级缓存的工厂加入 了。当在一开始获bean，一级获取不到，获取二级有工厂的时候，就会把BeanWapper的实例暴露出去，供后续使用 然后开始初始化实例 将上面暴露出来的示例进行属性注入 给InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation在属性注入之前最后一次机会，去改变Bean，并且阻止Bean的属性注入 判断属性注入的是byName还是byType，针对所有的非简单的属性，还有排除所有的ignoredDependencyInterfaces中的接口。进行getBean操作，保存到PropertyValues中 使用InstantiationAwareBeanPostProcessor的postProcessProperties，可以进行修改属性。继续使用postProcessPropertyValues，继续可以更该属性 得到所有属性后，应用属性到Bean实例身上，在应用属性的时候，会找到前工厂里的所有的TypeConverter去将属性变为需要的属性，如果变不成会报错 至此，属性赋值完毕 复制完毕后，开始初始化Bean，先激活所有的aware方法， 调用BPP的postProcessBeforeInitialization初始化之前方法，记住，这里的初始化，是Bean已经实例化之后的事情了，是执行其他事情的初始化 执行afterPropertiesSet方法，在执行init-methods方法 调用BPP的postProcessAfterInitialization初始化以后方法 至此返回暴露的bean，即getBean结束 最后处理销毁的方法，即出发destory-method的方法  Spring是如何处理掉循环依赖的  针对非单例Bean出现循环依赖直接抛出异常 单例Bean Spring存在3个缓存Map  Spring完全生成好的BeanMap，key是Bean的name，Value是实例对象 Spring生成Bean的工厂Map，key是Bean的name，value是实现了ObjectFactory接口的实例对象 Spring尚未初始化，即赋予属性或者其他初始化动作的Bean实例Map，key是Bean的name，value是工厂map的工厂的返回值，即ObjectFactory的getObject方法结果   假设存在对象A依赖于对象B，对象Bean依赖于对象A  Spring根据A的name，首先取BeanMap里找是否有A的实例，没有的话，检查A是否正在创建，如果正在创建，则说明出现了循环依赖。（需要获取A，发现A又在创建，表名有其他bean需要A），尝试从可提前依赖的BeanMap获取EarlyBeanReference，如果没有，则尝试从工厂Map里找A对应的工厂对象，如果有工厂对象，则调用工厂对象进行返回，并且将工厂返回的Bean实例作为EarlyBeanReference，放入未完全实例化结束BeanMap里，删除工厂Map对应的value。此时工厂Map为空。 此时，A没有正在创建，继续 标记A正在创建，根绝BeanDefinition生成Bean实例对象，（此时对象实例已经生成完毕，但是还没有初始化），并且把A的创建工厂，放入工厂Map，而这个创建工厂getObject返回值就是刚才生成的实例对象，并且给SmartInstantiationAwareBeanPostProcessor接口机会取改变这个EarlyBeanReference对象。 得到实例化后的A对象，开始注入A的属性，发现A的属性b，需要B对象。 B对象开始获取（此时，A还没有结束，即一级缓存中没有A，二级缓存中有A的工厂Map） B的获取如上述一致， 直至B实例化结束，开始注入B的属性，发现B的属性a，需要A对象 又到了A对象开始获取 此时，进入第一个流程，发现一级缓存里没有A，而A又正在创建中，出现循环依赖，去二级缓存里找A的工厂Map，调用工厂Map方法去，得到了EarlyBeanReference，放入三级缓存里，返回回去 即此时，B注入属性成功，并且返回了一个EarlyBeanReference，即当前正在创建的A对象实例。 B注入成功属性后，B实例化完全结束，结束后，清除B的二三级缓存，加入一级缓存并返回 此时回到了A的注入B属性逻辑中，A得到了B实例。而这个实例里的A属性对象，和当前获取A的对象是一个 A继续完成初始化动作，最后A实例化完全结束，清楚A的二三级缓存，加入一级缓存并返回   只有2个缓存行吗？为什么一定要3个  BeanMap无用质疑是需要的 如果只有工厂Map而没有，可提前依赖的BeanMap的话，那么在一开始从缓存中获取Bean，一级缓存无法获取到，直接就有工厂Bean，一旦有工厂就调用工厂返回的值，这样是不行的，因为在工厂调用Bean的时候，有很多动作就会进行重复，比如工厂获取的时候，可以给SmartInstantiationAwareBeanPostProcessor机会去更改EarlyBeanReference对象，重复执行了。第二，与工厂模式的思想违背，工厂只需要制造一次，而不是每次都制造。 如果只有可提前依赖的BeanMap，而没有工厂Map。实际上是可以的，只不过没有工厂的话，会将大部分工作都抛给创建Bean的流程里，例如SmartInstantiationAwareBeanPostProcessor等工厂应该负责的工作    ApplicationContext的Refresh方法  Enviroment，环境参数，根据不同的环境，实现Environment不同的子类，例如Web环境会实现，StandardServletEnvironment，默认是实现StandardEnvironment，包含很多环境变量，系统变量，java环境变量，Servlet环境变量 创建beanFactory作为成员变量，ApplicationContext自身也实现了BeanFactory接口，只不过具体实现的方法是成员变量的beanFactory的方法、 填充工厂  增加SPEL表达式解析器 属性编辑器注入 增加一个ApplicationContextAwareProcessor的BPP，在Bean实例化之后，激活实现了aware接口的方法的一个BPP 配置忽略某些类型的属性自动注入，增加某些类型自动注入   postProcessBeanFactory：留给子类去实现 记录启动路径 激活BeanFactoryPostProcessor，invokeBeanFactoryPostProcessors 注册BeanPostProcessor 初始化国际化文件 初始化initApplicationEventMulticaster，事件传送器，用于发送事件 注册事件监听器 设置ConversionService 锁定所有BeanDefinitions，防止改变 实例化剩下所有的no-lazy实例 调用所有实现LifeCycle接口的bean 发送ContextRefreshedEvent事件  BeanFactoryPostProcessor和BeanPostProcessor区别   BeanFactoryPostProcessor是可以修改Bean的元数据，是控制BeanFactory的，而BeanPostProcessor是Bean实例的处理器，可以修改Bean的实例\n  以PropertySourcesPlaceholderConfigurer为例\n很明显，作用就是对于Beanfactory的所有Beandefintion进行处理，即在xml里中配置的${}属性\n@Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { try { Properties mergedProps = mergeProperties(); // Convert the merged properties, if necessary. \tconvertProperties(mergedProps); // Let the subclass process the properties. \tprocessProperties(beanFactory, mergedProps); } catch (IOException ex) { throw new BeanInitializationException(\"Could not load properties\", ex); } } @Override protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess, Properties props) throws BeansException { StringValueResolver valueResolver = new PlaceholderResolvingStringValueResolver(props); doProcessProperties(beanFactoryToProcess, valueResolver); } protected void doProcessProperties(ConfigurableListableBeanFactory beanFactoryToProcess, StringValueResolver valueResolver) { BeanDefinitionVisitor visitor = new BeanDefinitionVisitor(valueResolver); String[] beanNames = beanFactoryToProcess.getBeanDefinitionNames(); for (String curName : beanNames) { // Check that we're not parsing our own bean definition, \t// to avoid failing on unresolvable placeholders in properties file locations. \tif (!(curName.equals(this.beanName) \u0026\u0026 beanFactoryToProcess.equals(this.beanFactory))) { BeanDefinition bd = beanFactoryToProcess.getBeanDefinition(curName); try { visitor.visitBeanDefinition(bd); } catch (Exception ex) { throw new BeanDefinitionStoreException(bd.getResourceDescription(), curName, ex.getMessage(), ex); } } } // New in Spring 2.5: resolve placeholders in alias target names and aliases as well. \tbeanFactoryToProcess.resolveAliases(valueResolver); // New in Spring 3.0: resolve placeholders in embedded values such as annotation attributes. \tbeanFactoryToProcess.addEmbeddedValueResolver(valueResolver); } public void visitBeanDefinition(BeanDefinition beanDefinition) { visitParentName(beanDefinition); visitBeanClassName(beanDefinition); visitFactoryBeanName(beanDefinition); visitFactoryMethodName(beanDefinition); visitScope(beanDefinition); if (beanDefinition.hasPropertyValues()) { visitPropertyValues(beanDefinition.getPropertyValues()); } if (beanDefinition.hasConstructorArgumentValues()) { ConstructorArgumentValues cas = beanDefinition.getConstructorArgumentValues(); visitIndexedArgumentValues(cas.getIndexedArgumentValues()); visitGenericArgumentValues(cas.getGenericArgumentValues()); } }   上面的例子即可以看出BeanFactoryPostProcessor是对BeanFactory进行操作，是Bean还没实例化之前的动作\n  原理Spring AOP   Xml方式中，aspectj-autoproxy，标签默认创建一个AnnotationAwareAspectJAutoProxyCreator的BeanDefinition，注册到BeanDefinitionRegistry中\n  通过事件发送，通知到注册了\n  在Application的refresh中的finishBeanFactoryInitialization，会实例化该bean\n  AnnotationAwareAspectJAutoProxyCreator实现了Spring的BPP接口\n  正常情况下，AOP会在postProcessAfterInitialization方法执行后，wrapIfNecessary，会去找当前容器里所有的增强器，一个增强器里包含了，切入点，切入方法\n  首先会找到容器里所有的增强器，做缓存处理，对于每一个要获取的Bean都会走这个方法。具体的寻找方法，包括Spring老式的配置，即在XML里配置Bean，使用aop:config里的aop:ref和aop:point_cut，配置出来的，以及现在十分方便的使用aspectJ注解的@Aspect配合@PointCut，@Around，@Before，@After，@Throw\n  然后根据Bean的属性。检查找到的增强其里面是否有满足条件的。即查看是否满足AOP，表达式的，方法\n  如果这个bean有满足的增强器\n  则取获取代理对象，Spring有2中实现代理的方式，JDK自带的Proxy类，以及CGlib\n  JDK和GClib区别\n JDK只能针对实现了接口的类，生成代理，实现同样的接口方法，但里面调用的还是目标对象的方法 CGLIB是针对类实现代理，通过修改字节码方式，对目标对象生成一个其子类，覆写父类的方法，从而达到代理，所以类不能声明为final    Spring可以强制使用cglib，配置proxyTargetClass属性为true即可\n  根据上述找到的增强器，Spring根据配置，创建对应的AopProxy，JdkDynamicAopProxy或者CglibAopProxy\n  调用AopProxy的getProxy方法\n  JdkDynamicAopProxy\n  使用JDK自带的Proxy.newProxyInstance方式创建代理对象\nProxy.newProxyInstance(classLoader, this.proxiedInterfaces, this);   最后一个参数this，说明JdkDynamicAopProxy肯定实现了InvocationHandler，最后执行的目标方法就是invoke方法\n  在这里面处理了expose-proxy属性\n//AopContext 自身无法获取代理对象的处理 exposeProxy if (this.advised.exposeProxy) { // Make invocation available if necessary.  oldProxy = AopContext.setCurrentProxy(proxy); setProxyContext = true; }   然后根据传入的增强器，使用ReflectiveMethodInvocation封装，方法链，逐个调用。不同的advistor使用不同的实现类去实现，例如\n  AspectJAroundAdvice\r@Override @Nullable public Object invoke(MethodInvocation mi) throws Throwable { if (!(mi instanceof ProxyMethodInvocation)) { throw new IllegalStateException(\"MethodInvocation is not a Spring ProxyMethodInvocation: \" + mi); } ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi; ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi); JoinPointMatch jpm = getJoinPointMatch(pmi); return invokeAdviceMethod(pjp, jpm, null, null); } 这也就是为什么@Around的方法，入参可以是ProceedingJoinPoint\ninvokeAdviceMethodWithGivenArgs(argBinding(jp, jpMatch, returnValue, t));     直至所有的方法链调用结束\n  最后执行目标方法\n  处理返回对象\n    SpringMVC流程 SpringMvc会使用DispatcherServlet作为请求的入口。\n作为一个Servlet，init方法，执行后，DispatcherServlet会创建自己的IOC容器，并且把ServletContext中的IOC作为父容器，所以MVC的相关内容，例如Controller可以放在MVC的IOC中，而其余的，dao，service可以放在SevletContext里的IOC，好处就是隔离开了M层，如果要还Struts，可以直接更换，而不用考虑dao和service了。\ninit方法，除了创建MVC自己的容器，还根据DispatchServlet.properties里的内容，进行一系列的初始化动作。\nDispatcherServlet继承于FrameworkServlet。集成HttpServlet，最后从Servlet会执行到DispatchServlet的processRequest方法。processRequest中，Spring会将当前的请求requestAttributes放在RequestContextHolder中用ThreadLocal保存，所以后续的Controller都可以使用。\n随后走到doDispatch中，做一些必要的检查，然后根据容器里的handerMapping找到对应的hanlder，使用HandlerExecutionChain将符合该请求的拦截器，封装在一起，跨域也是在这里增加另一个拦截器\n准备好HandlerExecutionChain之后，进入流程。先调用所有的拦截器preHandler方法\nHandler有很多种，最后使用适配器模式，创建handlerAdapter去调用不同handler的具体执行方法。从而得到modelAndView\n然后调用拦截器的postHandler方法\n得到modelAndView，之后会使用ViewRovler解析view，最后获取requestDispatcher，forward或者是重定向到新的路径，并且把model，放入request的attribute里，从而进入下一个请求了，可以是reward也可以是redirect\n为什么在Controller的方法参数里，写HttpServletRequest就可以获得到请求对象，以及@RequestBody和@RequestParam 不管是xml中配置mvc:annotation-driven/，还是使用注解@EnableWebMvc，本质上都是在容器中注入了RequestMappingHandlerMapping这样的实例。实例实现了initalizingBean接口，在容器中实例化的时候，会将容器中所有的Bean找出来，检查Class是否被@Controller或者@RequestMapping修饰，找到即作为一个handler。\n然后去找到Hanlder对应的adapter，RequestMappingHandlerAdapter，Adapter的handler方法。\nhanlder方法的核心是，invokeHandlerMethod，通过反射调用目标方法，并且通过一些列配置，将方法需要的配置传入进去，其中解析方法参数的就是一些列的argumentResolvers。\nSpring依然是在RequestMappingHandlerAdapter的afterPropertiesSet()方法之后，。初始化了argumentResolvers\n如下\nprivate ListHandlerMethodArgumentResolver getDefaultArgumentResolvers() { ListHandlerMethodArgumentResolver resolvers = new ArrayList(30); // Annotation-based argument resolution  resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), false)); resolvers.add(new RequestParamMapMethodArgumentResolver()); resolvers.add(new PathVariableMethodArgumentResolver()); resolvers.add(new PathVariableMapMethodArgumentResolver()); resolvers.add(new MatrixVariableMethodArgumentResolver()); resolvers.add(new MatrixVariableMapMethodArgumentResolver()); resolvers.add(new ServletModelAttributeMethodProcessor(false)); resolvers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new RequestPartMethodArgumentResolver(getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new RequestHeaderMethodArgumentResolver(getBeanFactory())); resolvers.add(new RequestHeaderMapMethodArgumentResolver()); resolvers.add(new ServletCookieValueMethodArgumentResolver(getBeanFactory())); resolvers.add(new ExpressionValueMethodArgumentResolver(getBeanFactory())); resolvers.add(new SessionAttributeMethodArgumentResolver()); resolvers.add(new RequestAttributeMethodArgumentResolver()); // Type-based argument resolution  resolvers.add(new ServletRequestMethodArgumentResolver()); resolvers.add(new ServletResponseMethodArgumentResolver()); resolvers.add(new HttpEntityMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new RedirectAttributesMethodArgumentResolver()); resolvers.add(new ModelMethodProcessor()); resolvers.add(new MapMethodProcessor()); resolvers.add(new ErrorsMethodArgumentResolver()); resolvers.add(new SessionStatusMethodArgumentResolver()); resolvers.add(new UriComponentsBuilderMethodArgumentResolver()); if (KotlinDetector.isKotlinPresent()) { resolvers.add(new ContinuationHandlerMethodArgumentResolver()); } // Custom arguments  if (getCustomArgumentResolvers() != null) { resolvers.addAll(getCustomArgumentResolvers()); } // Catch-all  resolvers.add(new PrincipalMethodArgumentResolver()); resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), true)); resolvers.add(new ServletModelAttributeMethodProcessor(true)); return resolvers; } 通过 HandlerMethodArgumentResolver的supportsParameter方法\n以RequestParam为例\n首先RequestParamMethodArgumentResolver的父类AbstractNamedValueMethodArgumentResolver，进行校验，校验Hanlder的参数是否是必填，会将@RequestParams的required进行校验，从HttpServletRequest里的parameter进行校验。校验成功，会通过反射执行handler，并将参数传入Handler中。\n@RequestBody也是一样，使用的RequestResponseBodyMethodProcessor去处理参数的\n在处理@RequestBody的时候，RequestMappingHandlerAdapter的所有messageConverters，找到符合的，我们常用的application/json就是MappingJackson2HttpMessageConverter，需要引入jackson的核心包\n至于其他的Httpservlet都是是同对应的argumentResolve处理的\nSpringBoot的工作原理 Spring在诞生之初，配置类一直是令开发者吐槽的模块，当java5推出注解后，可以使用java类进行配置了，但依然很繁琐。而SpringBoot的最大的一个特点，就是解决复杂的配置。\nSpringBoot推出了一系列注解，他们可以将各类Spring boot starter，无感的注入到容器中。\nSpringBoot在SpringBoot的run方法里，完成了一些列工作。\n首先是构造方法会根据当前类路径下是否包含webflux，或者servlet相关类，从而决定实例化的容器对象。\n以常见的servlet为例，SpringBoot会实例化AnnotationConfigServletWebServerApplicationContext\n而在SpringBoot构造函数触发时，会寻找类路径下META/Spring.factories文件，下所有的ApplicationContextInitializer实例，和ApplicationListener实例，并且放入当前对象的属性中\n  核心的run方法，里首先还是从spring.factories里找到所有的SpringApplicationRunListener，调用其starting方法，\n  然后封装main方法的arg参数，校验环境，即我们可以在外部指明spring的profile.active=prod就是在这里指明的\n  准备好main的arg以及sytem的相关属性后，会调用所有SpringApplicationRunListener的environmentPrepared，也就是在这里面进行了Spring配置文件，application.yml或者是application.properties的处理\n  打印Banner\n  根据上述得到的实例化Class，实例化IOC容器\n  从spring.factories里找到SpringBootExceptionReporter用于异常打印\n  准备名称生成器，资源加载器，类加载器等。\n  调用Spring.factories里的ApplicationContextInitializer的initialize方法\n  调用ApplicationContextInitializer的contextPrepared方法\n  打印启动类信息，打印profile信息\n  加载启动类的注解信息，即启动类也可以是一个组件，注入到容器中，默认情况下，@SpringBootApplication里的@SpringBootConfiguration里有@Component注解，Spring会通过注解方式将其注入到容器中，细节就不说了，核心是@SpringBootConfiguration身上有@Configuration，而且有@Import注解，引入的是AutoConfigurationImportSelector\nSpringBoot在启动的时候，注入了ConfigurationClassPostProcessor该类实现了BeanDefinitionRegistryPostProcessor会在容器的refresh里的invokeBeanFactoryPostProcesser，里触发\npostProcessBeanDefinitionRegistry方法，会找到容器里所有的@Configuration实例，这里此时容器里有的就是启动类本身，然后会处理，@Configuration上的@Import，并且执行@Import类的process方法，即，最后依然调用的是selectImports方法，得到的就是Spring.factories里配置的**org.springframework.boot.autoconfigure.EnableAutoConfiguration=**的值，然后逐步解析所有的类，这样容器里就有第三方调用的所有信息了\npublic void process(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector) { Assert.state( deferredImportSelector instanceof AutoConfigurationImportSelector, () - String.format(\"Only %s implementations are supported, got %s\", AutoConfigurationImportSelector.class.getSimpleName(), deferredImportSelector.getClass().getName())); AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector) .getAutoConfigurationEntry(getAutoConfigurationMetadata(), annotationMetadata); this.autoConfigurationEntries.add(autoConfigurationEntry); for (String importClassName : autoConfigurationEntry.getConfigurations()) { this.entries.putIfAbsent(importClassName, annotationMetadata); } } protected AutoConfigurationEntry getAutoConfigurationEntry( AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } AnnotationAttributes attributes = getAttributes(annotationMetadata); ListString configurations = getCandidateConfigurations(annotationMetadata,//获取到所有的/META-INF/spring-factories中的configuration  attributes); configurations = removeDuplicates(configurations);//删除重复的  SetString exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions);//根据上面的属性excclusion  configurations.removeAll(exclusions); configurations = filter(configurations, autoConfigurationMetadata); fireAutoConfigurationImportEvents(configurations, exclusions);//通知导入成功  return new AutoConfigurationEntry(configurations, exclusions); }   Spring事务   Spring使用注解@Transactional放在方法，或者类上\n  @Transactional属性有\n transactionManager指明事务管理器，在多数据源的时候，需要指明 propagation传播行为默认是Propagation.REQUIRED，即当前如果存在事务，则用同一个事务，否则开启一个新事务 isolation隔离级别，默认是数据库的隔离级别，mysql默认时可重复度，幻读是通过MVCC和间隙锁解决的 timeout超时时间 readOnly是否只读 rollbackFor发生什么异常才会会滚，默认是RuntimeException rollbackForClassName noRollbackFor noRollbackForClassName    原理，@Transactional注解是基于AOP原理，容器在获取相应bean的时候，会去使用wrapifNecessary包装bean，Spring的流程是，从容器里找到所有的adviser，而@Transactional会在容器里注入BeanFactoryTransactionAttributeSourceAdvisor，从而最后得到的是代理对象，而代理对象针对于满足切面条件的bean，会做处理，@Transactional就是切面条件，会在目标方法执行之前开启一个事务，执行之后提交或者回滚一个事务，操作事务的都是TransactionManager\n  提问\n  如果在一个方法里异常被try-catch了，还会会滚吗？不会了，因为Sping处理提交事务是在切面的AfterRunning之后提交的，在那之前会使用try-catch捕捉，而目标自己捕捉过的话，Spring就捕捉不到了，除非在catch里再抛出\n  如果自己使用TransactionManager重新在获取一个事务，手动提交之前，抛出异常的话，会会滚吗？不会，会被Spring捕捉到\n  如果在抛出异常之前，就手动提交了，Spring会回滚吗，可能会 也可能不会，这和Spring事务的传播行为有关，默认情况下传播行为是，如果当前有事务了，就用当前事务，否则开启一个新事务。\n如果有@Transactional注解了，意味着Spring已经开启了一个事务了，后续自己手动开启的事务，就是之前的事务了，并非一个新事务，Spring在提交事务之前，会判断是否为一个新事务，是的话，才会进行提交，否则不会有动作。所有如果传播行为不变的话，会回滚的，如果是强制开启新的事务的传播行为，则不会会滚\n    讲讲你会的设计模式，Spring里面用到了哪些设计模式 Java中的Date是线程安全的吗？你是如何保证线程安全的 讲讲ThreadLocal 和java的内存模型吧 WebAsyncTask WebAsyncTask，是基于Servlet3.0异步Servlet的特性，用于提高容器的吞吐量，客户端请求进来时，当前的容器分配的线程会直接返回，并会开启一个新线程用于处理客户端请求，当新线程结束时，客户端才会收到请求。而容器的线程就可以回收用于新的请求，提高了吞吐量\n拦截器和过滤器的区别 首先，拦截器与过滤器不是一起的，拦截器是Spring的，而过滤器filter是javax提供的，filter会在拦截器之前执行，拦截器可以达到更细粒控制请求。拦截器可以获得到具体执行的handler，可以对handler做个性化操作。过滤器可以做的，拦截器都可以做到，拦截器做的，过滤器做不了。\n聊一下mybatis 什么是mybatis的懒加载 mybatis的mapper是如何与数据库连接的 什么是索引，索引为什么可以加查询 Innodb索引实现 B树和B+树 Redis使用，部署，哨兵 TCP三次握手 乐观锁，悲观锁，举例 设计模式 Redis扩容 CAS概念，原子类的实现 Synchronize 底层原理 AQS 网络模型，你知道的网络协议 HTTPS的连接过程，SSL 单链表算法，反转，查找 jvm垃圾回收机制 工作流引擎 Spring MVC webFlux netty redis为什么这么快 Mysql的explain K8S 讲一讲反射，以及你工作中用到的地方 java反射，提供给我们方式去动态创建类，或者是动态执行方法，当我们因为某些条件，不知道目标应该执行什么方法的时候，就可以使用反射。\n例如，请假，如果超过2天，就执行某方法，否则执行另一个方法，我们就可以用反射\n反射也被大量应用于mybatis和spring之中，spring中aop，创建bean的动作都是反射，因为他们无论是执行方法还是构建实例都是未知的参数和条件\n","wordCount":"715","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Hao Sun"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://luluhome.site:8101/posts/spring%E6%95%B4%E7%90%86/"},"publisher":{"@type":"Organization","name":"Hao Sun","logo":{"@type":"ImageObject","url":"https://luluhome.site:8101/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://luluhome.site:8101/ accesskey=h title="Hao Sun (Alt + H)">Hao Sun</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://luluhome.site:8101/archives/ title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://luluhome.site:8101/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
<li>
<a href=https://luluhome.site:8101/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://luluhome.site:8101/>Home</a>&nbsp;»&nbsp;<a href=https://luluhome.site:8101/posts/>Posts</a></div>
<h1 class=post-title>
</h1>
<div class=post-meta>4 min&nbsp;·&nbsp;Hao Sun
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e5%bd%93%e5%9c%a8sping%e4%b8%ad%e9%85%8d%e7%bd%ae%e7%9a%84bean%e5%ad%98%e5%9c%a8%e7%9b%b8%e4%ba%92%e4%be%9d%e8%b5%96spring%e6%98%af%e6%80%8e%e4%b9%88%e5%a4%84%e7%90%86%e7%9a%84 aria-label=当在Sping中配置的Bean存在相互依赖，Spring是怎么处理的>当在Sping中配置的Bean存在相互依赖，Spring是怎么处理的</a></li>
<li>
<a href=#%e9%98%90%e8%bf%b0%e4%b8%80%e4%b8%aabean%e8%8e%b7%e5%8f%96%e7%9a%84%e6%b5%81%e7%a8%8b aria-label=阐述一个Bean获取的流程>阐述一个Bean获取的流程</a></li>
<li>
<a href=#spring%e6%98%af%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e6%8e%89%e5%be%aa%e7%8e%af%e4%be%9d%e8%b5%96%e7%9a%84 aria-label=Spring是如何处理掉循环依赖的>Spring是如何处理掉循环依赖的</a></li>
<li>
<a href=#applicationcontext%e7%9a%84refresh%e6%96%b9%e6%b3%95 aria-label=ApplicationContext的Refresh方法>ApplicationContext的Refresh方法</a></li>
<li>
<a href=#beanfactorypostprocessor%e5%92%8cbeanpostprocessor%e5%8c%ba%e5%88%ab aria-label=BeanFactoryPostProcessor和BeanPostProcessor区别>BeanFactoryPostProcessor和BeanPostProcessor区别</a></li>
<li>
<a href=#%e5%8e%9f%e7%90%86spring-aop aria-label="原理Spring AOP">原理Spring AOP</a></li>
<li>
<a href=#springmvc%e6%b5%81%e7%a8%8b aria-label=SpringMVC流程>SpringMVC流程</a><ul>
<li>
<a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e5%9c%a8controller%e7%9a%84%e6%96%b9%e6%b3%95%e5%8f%82%e6%95%b0%e9%87%8c%e5%86%99httpservletrequest%e5%b0%b1%e5%8f%af%e4%bb%a5%e8%8e%b7%e5%be%97%e5%88%b0%e8%af%b7%e6%b1%82%e5%af%b9%e8%b1%a1%e4%bb%a5%e5%8f%8arequestbody%e5%92%8crequestparam aria-label=为什么在Controller的方法参数里，写HttpServletRequest就可以获得到请求对象，以及@RequestBody和@RequestParam>为什么在Controller的方法参数里，写HttpServletRequest就可以获得到请求对象，以及@RequestBody和@RequestParam</a></li></ul>
</li>
<li>
<a href=#springboot%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86 aria-label=SpringBoot的工作原理>SpringBoot的工作原理</a></li>
<li>
<a href=#spring%e4%ba%8b%e5%8a%a1 aria-label=Spring事务>Spring事务</a></li>
<li>
<a href=#%e8%ae%b2%e8%ae%b2%e4%bd%a0%e4%bc%9a%e7%9a%84%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8fspring%e9%87%8c%e9%9d%a2%e7%94%a8%e5%88%b0%e4%ba%86%e5%93%aa%e4%ba%9b%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f aria-label=讲讲你会的设计模式，Spring里面用到了哪些设计模式>讲讲你会的设计模式，Spring里面用到了哪些设计模式</a></li>
<li>
<a href=#java%e4%b8%ad%e7%9a%84date%e6%98%af%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e5%90%97%e4%bd%a0%e6%98%af%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84 aria-label=Java中的Date是线程安全的吗？你是如何保证线程安全的>Java中的Date是线程安全的吗？你是如何保证线程安全的</a></li>
<li>
<a href=#%e8%ae%b2%e8%ae%b2threadlocal-%e5%92%8cjava%e7%9a%84%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%e5%90%a7 aria-label="讲讲ThreadLocal 和java的内存模型吧">讲讲ThreadLocal 和java的内存模型吧</a></li>
<li>
<a href=#webasynctask aria-label=WebAsyncTask>WebAsyncTask</a><ul>
<li>
<a href=#%e6%8b%a6%e6%88%aa%e5%99%a8%e5%92%8c%e8%bf%87%e6%bb%a4%e5%99%a8%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=拦截器和过滤器的区别>拦截器和过滤器的区别</a></li></ul>
</li>
<li>
<a href=#%e8%81%8a%e4%b8%80%e4%b8%8bmybatis aria-label=聊一下mybatis>聊一下mybatis</a><ul>
<li>
<a href=#%e4%bb%80%e4%b9%88%e6%98%afmybatis%e7%9a%84%e6%87%92%e5%8a%a0%e8%bd%bd aria-label=什么是mybatis的懒加载>什么是mybatis的懒加载</a></li>
<li>
<a href=#mybatis%e7%9a%84mapper%e6%98%af%e5%a6%82%e4%bd%95%e4%b8%8e%e6%95%b0%e6%8d%ae%e5%ba%93%e8%bf%9e%e6%8e%a5%e7%9a%84 aria-label=mybatis的mapper是如何与数据库连接的>mybatis的mapper是如何与数据库连接的</a></li></ul>
</li>
<li>
<a href=#%e4%bb%80%e4%b9%88%e6%98%af%e7%b4%a2%e5%bc%95%e7%b4%a2%e5%bc%95%e4%b8%ba%e4%bb%80%e4%b9%88%e5%8f%af%e4%bb%a5%e5%8a%a0%e6%9f%a5%e8%af%a2 aria-label=什么是索引，索引为什么可以加查询>什么是索引，索引为什么可以加查询</a></li>
<li>
<a href=#innodb%e7%b4%a2%e5%bc%95%e5%ae%9e%e7%8e%b0 aria-label=Innodb索引实现>Innodb索引实现</a></li>
<li>
<a href=#b%e6%a0%91%e5%92%8cb%e6%a0%91 aria-label=B树和B+树>B树和B+树</a></li>
<li>
<a href=#redis%e4%bd%bf%e7%94%a8%e9%83%a8%e7%bd%b2%e5%93%a8%e5%85%b5 aria-label=Redis使用，部署，哨兵>Redis使用，部署，哨兵</a></li>
<li>
<a href=#tcp%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b aria-label=TCP三次握手>TCP三次握手</a></li>
<li>
<a href=#%e4%b9%90%e8%a7%82%e9%94%81%e6%82%b2%e8%a7%82%e9%94%81%e4%b8%be%e4%be%8b aria-label=乐观锁，悲观锁，举例>乐观锁，悲观锁，举例</a></li>
<li>
<a href=#%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f aria-label=设计模式>设计模式</a></li>
<li>
<a href=#redis%e6%89%a9%e5%ae%b9 aria-label=Redis扩容>Redis扩容</a></li>
<li>
<a href=#cas%e6%a6%82%e5%bf%b5%e5%8e%9f%e5%ad%90%e7%b1%bb%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label=CAS概念，原子类的实现>CAS概念，原子类的实现</a></li>
<li>
<a href=#synchronize-%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86 aria-label="Synchronize 底层原理">Synchronize 底层原理</a></li>
<li>
<a href=#aqs aria-label=AQS>AQS</a></li>
<li>
<a href=#%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b%e4%bd%a0%e7%9f%a5%e9%81%93%e7%9a%84%e7%bd%91%e7%bb%9c%e5%8d%8f%e8%ae%ae aria-label=网络模型，你知道的网络协议>网络模型，你知道的网络协议</a></li>
<li>
<a href=#https%e7%9a%84%e8%bf%9e%e6%8e%a5%e8%bf%87%e7%a8%8bssl aria-label=HTTPS的连接过程，SSL>HTTPS的连接过程，SSL</a></li>
<li>
<a href=#%e5%8d%95%e9%93%be%e8%a1%a8%e7%ae%97%e6%b3%95%e5%8f%8d%e8%bd%ac%e6%9f%a5%e6%89%be aria-label=单链表算法，反转，查找>单链表算法，反转，查找</a></li>
<li>
<a href=#jvm%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e6%9c%ba%e5%88%b6 aria-label=jvm垃圾回收机制>jvm垃圾回收机制</a></li>
<li>
<a href=#%e5%b7%a5%e4%bd%9c%e6%b5%81%e5%bc%95%e6%93%8e aria-label=工作流引擎>工作流引擎</a></li>
<li>
<a href=#spring-mvc-webflux aria-label="Spring MVC webFlux">Spring MVC webFlux</a></li>
<li>
<a href=#netty aria-label=netty>netty</a></li>
<li>
<a href=#redis%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%99%e4%b9%88%e5%bf%ab aria-label=redis为什么这么快>redis为什么这么快</a></li>
<li>
<a href=#mysql%e7%9a%84explain aria-label=Mysql的explain>Mysql的explain</a></li>
<li>
<a href=#k8s aria-label=K8S>K8S</a></li>
<li>
<a href=#%e8%ae%b2%e4%b8%80%e8%ae%b2%e5%8f%8d%e5%b0%84%e4%bb%a5%e5%8f%8a%e4%bd%a0%e5%b7%a5%e4%bd%9c%e4%b8%ad%e7%94%a8%e5%88%b0%e7%9a%84%e5%9c%b0%e6%96%b9 aria-label=讲一讲反射，以及你工作中用到的地方>讲一讲反射，以及你工作中用到的地方</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><pre tabindex=0><code>@Override
@Nullable
public Object invoke(MethodInvocation mi) throws Throwable {
   if (!(mi instanceof ProxyMethodInvocation)) {
      throw new IllegalStateException(&quot;MethodInvocation is not a Spring ProxyMethodInvocation: &quot; + mi);
   }
   ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;
   ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);
   JoinPointMatch jpm = getJoinPointMatch(pmi);
   return invokeAdviceMethod(pjp, jpm, null, null);
}
</code></pre><h1 id=当在sping中配置的bean存在相互依赖spring是怎么处理的>当在Sping中配置的Bean存在相互依赖，Spring是怎么处理的<a hidden class=anchor aria-hidden=true href=#当在sping中配置的bean存在相互依赖spring是怎么处理的>#</a></h1>
<p>针对原型Bean直接抛出异常，不支持。</p>
<p>单例Bean，Spring使用3个Map做缓存，来处理。</p>
<p>分别是：一级缓存Spring最终保存的单例对象Map，二级缓存建造Spring单例对象的匿名工厂对象返回的就是三级缓存需要的，三级缓存是允许提前被依赖的单例对象。</p>
<h1 id=阐述一个bean获取的流程>阐述一个Bean获取的流程<a hidden class=anchor aria-hidden=true href=#阐述一个bean获取的流程>#</a></h1>
<ul>
<li>尝试获取单例Bean</li>
<li>检查一级缓存是否有，没有的话，检查当前获取的Bean是否正在创建，如果正在创建即出现了Bean互相依赖情况，检查三级缓存是否已经有提前可被依赖的对象，如果没有的话，检查二级缓存是否有其工厂，有的话，使用工厂，实例化这个Bean，放入三级缓存里。供其他Bean依赖使用</li>
<li>没获取到，可能是原型Bean，也可能是单例Bean没有实例化</li>
<li>检查如果是原型Bean，而且正在创建中，即出现了原型Bean被依赖的情况，直接抛出异常</li>
<li>准备BeanDefinition，如果档期工厂没有相应的BD，而且父工厂又存在BD，使用父工厂的getBean方法去获取Bean</li>
<li>标记Bean创建过了</li>
<li>从当前工厂读取BD,并且转为RootBeanDefinition，获取期间，还要检查父工厂是否也有该Bean的BD，有的话，以父工厂得BD为基础，子工厂得BD覆盖掉其属性</li>
<li>检查BD是不是抽象的，无法实例化的类，抛出异常</li>
<li>检查BD中得DependsOn属性，针对所有Depend，循环实例化，如果检查到有Depend得Bean又依赖于当前目标Bean，抛出异常，互相提前依赖了。并且建立相关关系，所以DependOn意义是，依赖于一个完全实例化完成后的Bean</li>
<li>如果是单例的话，开始创建单例Bean，创建匿名工厂对象</li>
<li>标记单例Bean正在被创建</li>
<li>使用工厂对象去调用getObject方法</li>
<li>实际上执行了createBean方法</li>
<li>根据之前的RootBD，解析出需要实例化的Class对象</li>
<li>检查MethodOverrides目标方法是否存在Class对象中</li>
<li><strong>在实例化对象之前，给InstantiationAwareBeanPostProcessor机会去改变实例，调用其postProcessBeforeInstantiation，AOP就是在这里实现的，此外，如果返回了，还会调用BPP的postProcessAfterInitialization，但不会调用postProcessBeforeInitialization了</strong></li>
<li>如果没有被InstantiationAwareBeanPostProcessor改变了的话，开始进入真正的实例化方法</li>
<li>实例化一个BeanWrapperImpl去封装实例</li>
<li>解析Class对象，确定Class对象有Public修饰符</li>
<li>如果有FactoryMethod的话，直接调用FactoryMethod返回实例，封装在BeanWrapperImpl，这里面也会初始化initBeanWrapper，将属性编辑器注入到BeanWrapperImpl身上，用于后续的属性注入</li>
<li>开始解析构造函数或者是FactoryMethod，如果解析过了，直接去实例化</li>
<li>否则进入构造函数解析</li>
<li>解析之前，看BPP有没有提供了构造函数，即SmartInstantiationAwareBeanPostProcessor的determineCandidateConstructors方法执行，如果返回了构造函数，就用BPP的了。</li>
<li>没有的话，进入默认的解析，依赖先看缓存里有没有解析过的参数，因为构造方法注入的话，很消耗性能，没有缓存的话，先看用户获取bean时有没有传入args，即构造函数的参数。没有的话，而且只有一个候选的构造函数，就直接用使用无参的了，没有的话，先去解析参数，construct-arg，既可以时Index，也可以是name。根据用户传入的arg长度，去解析。</li>
<li>最后解析完成后，使用实例化策略去实例化即可，这里也可使用cglib去处理，然后封装在BeanWrapperImpl中</li>
<li>至此，BeanWapper里已经包含了我们的目标对象的实例了</li>
<li>然后创建二级缓存，将上一步BeanWapper里的实例，作为二级缓存返回的对象，加载缓存里</li>
<li>至此，二级缓存的工厂加入 了。当在一开始获bean，一级获取不到，获取二级有工厂的时候，就会把BeanWapper的实例暴露出去，供后续使用</li>
<li>然后开始初始化实例</li>
<li>将上面暴露出来的示例进行属性注入</li>
<li>给InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation在属性注入之前最后一次机会，去改变Bean，并且阻止Bean的属性注入</li>
<li>判断属性注入的是byName还是byType，针对所有的非简单的属性，还有排除所有的ignoredDependencyInterfaces中的接口。进行getBean操作，保存到PropertyValues中</li>
<li>使用InstantiationAwareBeanPostProcessor的postProcessProperties，可以进行修改属性。继续使用postProcessPropertyValues，继续可以更该属性</li>
<li>得到所有属性后，应用属性到Bean实例身上，在应用属性的时候，会找到前工厂里的所有的TypeConverter去将属性变为需要的属性，如果变不成会报错</li>
<li>至此，属性赋值完毕</li>
<li>复制完毕后，开始初始化Bean，先激活所有的aware方法，</li>
<li>调用BPP的postProcessBeforeInitialization初始化之前方法，记住，这里的初始化，是Bean已经实例化之后的事情了，是执行其他事情的初始化</li>
<li>执行afterPropertiesSet方法，在执行init-methods方法</li>
<li>调用BPP的postProcessAfterInitialization初始化以后方法</li>
<li>至此返回暴露的bean，即getBean结束</li>
<li>最后处理销毁的方法，即出发destory-method的方法</li>
</ul>
<h1 id=spring是如何处理掉循环依赖的>Spring是如何处理掉循环依赖的<a hidden class=anchor aria-hidden=true href=#spring是如何处理掉循环依赖的>#</a></h1>
<ul>
<li>针对非单例Bean出现循环依赖直接抛出异常</li>
<li>单例Bean</li>
<li>Spring存在3个缓存Map
<ul>
<li>Spring完全生成好的BeanMap，key是Bean的name，Value是实例对象</li>
<li>Spring生成Bean的工厂Map，key是Bean的name，value是实现了ObjectFactory接口的实例对象</li>
<li>Spring尚未初始化，即赋予属性或者其他初始化动作的Bean实例Map，key是Bean的name，value是工厂map的工厂的返回值，即ObjectFactory的getObject方法结果</li>
</ul>
</li>
<li>假设存在对象A依赖于对象B，对象Bean依赖于对象A
<ul>
<li>Spring根据A的name，首先取BeanMap里找是否有A的实例，没有的话，检查A是否正在创建，如果正在创建，则说明出现了循环依赖。（需要获取A，发现A又在创建，表名有其他bean需要A），尝试从可提前依赖的BeanMap获取EarlyBeanReference，如果没有，则尝试从工厂Map里找A对应的工厂对象，如果有工厂对象，则调用工厂对象进行返回，并且将工厂返回的Bean实例作为EarlyBeanReference，放入未完全实例化结束BeanMap里，删除工厂Map对应的value。此时工厂Map为空。</li>
<li>此时，A没有正在创建，继续</li>
<li>标记A正在创建，根绝BeanDefinition生成Bean实例对象，（此时对象实例已经生成完毕，但是还没有初始化），并且把A的创建工厂，放入工厂Map，而这个创建工厂getObject返回值就是刚才生成的实例对象，并且给SmartInstantiationAwareBeanPostProcessor接口机会取改变这个EarlyBeanReference对象。</li>
<li>得到实例化后的A对象，开始注入A的属性，发现A的属性b，需要B对象。</li>
<li>B对象开始获取（此时，A还没有结束，即一级缓存中没有A，二级缓存中有A的工厂Map）</li>
<li>B的获取如上述一致，</li>
<li>直至B实例化结束，开始注入B的属性，发现B的属性a，需要A对象</li>
<li>又到了A对象开始获取</li>
<li>此时，进入第一个流程，发现一级缓存里没有A，而A又正在创建中，出现循环依赖，去二级缓存里找A的工厂Map，调用工厂Map方法去，得到了EarlyBeanReference，放入三级缓存里，返回回去</li>
<li>即此时，B注入属性成功，并且返回了一个EarlyBeanReference，即当前正在创建的A对象实例。</li>
<li>B注入成功属性后，B实例化完全结束，结束后，清除B的二三级缓存，加入一级缓存并返回</li>
<li>此时回到了A的注入B属性逻辑中，A得到了B实例。而这个实例里的A属性对象，和当前获取A的对象是一个</li>
<li>A继续完成初始化动作，最后A实例化完全结束，清楚A的二三级缓存，加入一级缓存并返回</li>
</ul>
</li>
<li>只有2个缓存行吗？为什么一定要3个
<ul>
<li>BeanMap无用质疑是需要的</li>
<li>如果只有工厂Map而没有，可提前依赖的BeanMap的话，那么在一开始从缓存中获取Bean，一级缓存无法获取到，直接就有工厂Bean，一旦有工厂就调用工厂返回的值，这样是不行的，因为在工厂调用Bean的时候，有很多动作就会进行重复，比如工厂获取的时候，可以给SmartInstantiationAwareBeanPostProcessor机会去更改EarlyBeanReference对象，重复执行了。第二，与工厂模式的思想违背，工厂只需要制造一次，而不是每次都制造。</li>
<li>如果只有可提前依赖的BeanMap，而没有工厂Map。实际上是可以的，只不过没有工厂的话，会将大部分工作都抛给创建Bean的流程里，例如SmartInstantiationAwareBeanPostProcessor等工厂应该负责的工作</li>
</ul>
</li>
</ul>
<h1 id=applicationcontext的refresh方法>ApplicationContext的Refresh方法<a hidden class=anchor aria-hidden=true href=#applicationcontext的refresh方法>#</a></h1>
<ul>
<li>Enviroment，环境参数，根据不同的环境，实现Environment不同的子类，例如Web环境会实现，StandardServletEnvironment，默认是实现StandardEnvironment，包含很多环境变量，系统变量，java环境变量，Servlet环境变量</li>
<li>创建beanFactory作为成员变量，ApplicationContext自身也实现了BeanFactory接口，只不过具体实现的方法是成员变量的beanFactory的方法、</li>
<li>填充工厂
<ul>
<li>增加SPEL表达式解析器</li>
<li>属性编辑器注入</li>
<li>增加一个ApplicationContextAwareProcessor的BPP，在Bean实例化之后，激活实现了aware接口的方法的一个BPP</li>
<li>配置忽略某些类型的属性自动注入，增加某些类型自动注入</li>
</ul>
</li>
<li>postProcessBeanFactory：留给子类去实现</li>
<li>记录启动路径</li>
<li>激活BeanFactoryPostProcessor，invokeBeanFactoryPostProcessors</li>
<li>注册BeanPostProcessor</li>
<li>初始化国际化文件</li>
<li>初始化initApplicationEventMulticaster，事件传送器，用于发送事件</li>
<li>注册事件监听器</li>
<li>设置ConversionService</li>
<li>锁定所有BeanDefinitions，防止改变</li>
<li>实例化剩下所有的no-lazy实例</li>
<li>调用所有实现LifeCycle接口的bean</li>
<li>发送ContextRefreshedEvent事件</li>
</ul>
<h1 id=beanfactorypostprocessor和beanpostprocessor区别>BeanFactoryPostProcessor和BeanPostProcessor区别<a hidden class=anchor aria-hidden=true href=#beanfactorypostprocessor和beanpostprocessor区别>#</a></h1>
<ul>
<li>
<p>BeanFactoryPostProcessor是可以修改Bean的元数据，是控制BeanFactory的，而BeanPostProcessor是Bean实例的处理器，可以修改Bean的实例</p>
</li>
<li>
<p>以PropertySourcesPlaceholderConfigurer为例</p>
<p>很明显，作用就是对于Beanfactory的所有Beandefintion进行处理，即在xml里中配置的${}属性</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>	<span style=color:#a6e22e>@Override</span>
	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>postProcessBeanFactory</span><span style=color:#f92672>(</span>ConfigurableListableBeanFactory beanFactory<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> BeansException <span style=color:#f92672>{</span>
		<span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
			Properties mergedProps <span style=color:#f92672>=</span> mergeProperties<span style=color:#f92672>();</span>

			<span style=color:#75715e>// Convert the merged properties, if necessary.
</span><span style=color:#75715e></span>			convertProperties<span style=color:#f92672>(</span>mergedProps<span style=color:#f92672>);</span>

			<span style=color:#75715e>// Let the subclass process the properties.
</span><span style=color:#75715e></span>			processProperties<span style=color:#f92672>(</span>beanFactory<span style=color:#f92672>,</span> mergedProps<span style=color:#f92672>);</span>
		<span style=color:#f92672>}</span>
		<span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>IOException ex<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
			<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> BeanInitializationException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Could not load properties&#34;</span><span style=color:#f92672>,</span> ex<span style=color:#f92672>);</span>
		<span style=color:#f92672>}</span>
	<span style=color:#f92672>}</span>


	<span style=color:#a6e22e>@Override</span>
	<span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>processProperties</span><span style=color:#f92672>(</span>ConfigurableListableBeanFactory beanFactoryToProcess<span style=color:#f92672>,</span> Properties props<span style=color:#f92672>)</span>
			<span style=color:#66d9ef>throws</span> BeansException <span style=color:#f92672>{</span>

		StringValueResolver valueResolver <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> PlaceholderResolvingStringValueResolver<span style=color:#f92672>(</span>props<span style=color:#f92672>);</span>
		doProcessProperties<span style=color:#f92672>(</span>beanFactoryToProcess<span style=color:#f92672>,</span> valueResolver<span style=color:#f92672>);</span>
	<span style=color:#f92672>}</span>

	<span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doProcessProperties</span><span style=color:#f92672>(</span>ConfigurableListableBeanFactory beanFactoryToProcess<span style=color:#f92672>,</span>
			StringValueResolver valueResolver<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>

		BeanDefinitionVisitor visitor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> BeanDefinitionVisitor<span style=color:#f92672>(</span>valueResolver<span style=color:#f92672>);</span>

		String<span style=color:#f92672>[]</span> beanNames <span style=color:#f92672>=</span> beanFactoryToProcess<span style=color:#f92672>.</span><span style=color:#a6e22e>getBeanDefinitionNames</span><span style=color:#f92672>();</span>
		<span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>String curName <span style=color:#f92672>:</span> beanNames<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
			<span style=color:#75715e>// Check that we&#39;re not parsing our own bean definition,
</span><span style=color:#75715e></span>			<span style=color:#75715e>// to avoid failing on unresolvable placeholders in properties file locations.
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#f92672>(!(</span>curName<span style=color:#f92672>.</span><span style=color:#a6e22e>equals</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>beanName</span><span style=color:#f92672>)</span> <span style=color:#f92672>&amp;&amp;</span> beanFactoryToProcess<span style=color:#f92672>.</span><span style=color:#a6e22e>equals</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>beanFactory</span><span style=color:#f92672>)))</span> <span style=color:#f92672>{</span>
				BeanDefinition bd <span style=color:#f92672>=</span> beanFactoryToProcess<span style=color:#f92672>.</span><span style=color:#a6e22e>getBeanDefinition</span><span style=color:#f92672>(</span>curName<span style=color:#f92672>);</span>
				<span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
					visitor<span style=color:#f92672>.</span><span style=color:#a6e22e>visitBeanDefinition</span><span style=color:#f92672>(</span>bd<span style=color:#f92672>);</span>
				<span style=color:#f92672>}</span>
				<span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Exception ex<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
					<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> BeanDefinitionStoreException<span style=color:#f92672>(</span>bd<span style=color:#f92672>.</span><span style=color:#a6e22e>getResourceDescription</span><span style=color:#f92672>(),</span> curName<span style=color:#f92672>,</span> ex<span style=color:#f92672>.</span><span style=color:#a6e22e>getMessage</span><span style=color:#f92672>(),</span> ex<span style=color:#f92672>);</span>
				<span style=color:#f92672>}</span>
			<span style=color:#f92672>}</span>
		<span style=color:#f92672>}</span>

		<span style=color:#75715e>// New in Spring 2.5: resolve placeholders in alias target names and aliases as well.
</span><span style=color:#75715e></span>		beanFactoryToProcess<span style=color:#f92672>.</span><span style=color:#a6e22e>resolveAliases</span><span style=color:#f92672>(</span>valueResolver<span style=color:#f92672>);</span>

		<span style=color:#75715e>// New in Spring 3.0: resolve placeholders in embedded values such as annotation attributes.
</span><span style=color:#75715e></span>		beanFactoryToProcess<span style=color:#f92672>.</span><span style=color:#a6e22e>addEmbeddedValueResolver</span><span style=color:#f92672>(</span>valueResolver<span style=color:#f92672>);</span>
	<span style=color:#f92672>}</span>


	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>visitBeanDefinition</span><span style=color:#f92672>(</span>BeanDefinition beanDefinition<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
		visitParentName<span style=color:#f92672>(</span>beanDefinition<span style=color:#f92672>);</span>
		visitBeanClassName<span style=color:#f92672>(</span>beanDefinition<span style=color:#f92672>);</span>
		visitFactoryBeanName<span style=color:#f92672>(</span>beanDefinition<span style=color:#f92672>);</span>
		visitFactoryMethodName<span style=color:#f92672>(</span>beanDefinition<span style=color:#f92672>);</span>
		visitScope<span style=color:#f92672>(</span>beanDefinition<span style=color:#f92672>);</span>
		<span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>beanDefinition<span style=color:#f92672>.</span><span style=color:#a6e22e>hasPropertyValues</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
			visitPropertyValues<span style=color:#f92672>(</span>beanDefinition<span style=color:#f92672>.</span><span style=color:#a6e22e>getPropertyValues</span><span style=color:#f92672>());</span>
		<span style=color:#f92672>}</span>
		<span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>beanDefinition<span style=color:#f92672>.</span><span style=color:#a6e22e>hasConstructorArgumentValues</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
			ConstructorArgumentValues cas <span style=color:#f92672>=</span> beanDefinition<span style=color:#f92672>.</span><span style=color:#a6e22e>getConstructorArgumentValues</span><span style=color:#f92672>();</span>
			visitIndexedArgumentValues<span style=color:#f92672>(</span>cas<span style=color:#f92672>.</span><span style=color:#a6e22e>getIndexedArgumentValues</span><span style=color:#f92672>());</span>
			visitGenericArgumentValues<span style=color:#f92672>(</span>cas<span style=color:#f92672>.</span><span style=color:#a6e22e>getGenericArgumentValues</span><span style=color:#f92672>());</span>
		<span style=color:#f92672>}</span>
	<span style=color:#f92672>}</span>

</code></pre></div></li>
<li>
<p>上面的例子即可以看出BeanFactoryPostProcessor是对BeanFactory进行操作，是Bean还没实例化之前的动作</p>
</li>
</ul>
<h1 id=原理spring-aop>原理Spring AOP<a hidden class=anchor aria-hidden=true href=#原理spring-aop>#</a></h1>
<ul>
<li>
<p>Xml方式中，aspectj-autoproxy，标签默认创建一个AnnotationAwareAspectJAutoProxyCreator的BeanDefinition，注册到BeanDefinitionRegistry中</p>
</li>
<li>
<p>通过事件发送，通知到注册了</p>
</li>
<li>
<p>在Application的refresh中的finishBeanFactoryInitialization，会实例化该bean</p>
</li>
<li>
<p>AnnotationAwareAspectJAutoProxyCreator实现了Spring的BPP接口</p>
</li>
<li>
<p>正常情况下，AOP会在postProcessAfterInitialization方法执行后，wrapIfNecessary，会去找当前容器里所有的增强器，一个增强器里包含了，切入点，切入方法</p>
</li>
<li>
<p>首先会找到容器里所有的增强器，做缓存处理，对于每一个要获取的Bean都会走这个方法。具体的寻找方法，包括Spring老式的配置，即在XML里配置Bean，使用aop:config里的aop:ref和aop:point_cut，配置出来的，以及现在十分方便的使用aspectJ注解的@Aspect配合@PointCut，@Around，@Before，@After，@Throw</p>
</li>
<li>
<p>然后根据Bean的属性。检查找到的增强其里面是否有满足条件的。即查看是否满足AOP，表达式的，方法</p>
</li>
<li>
<p>如果这个bean有满足的增强器</p>
</li>
<li>
<p>则取获取代理对象，Spring有2中实现代理的方式，JDK自带的Proxy类，以及CGlib</p>
</li>
<li>
<p>JDK和GClib区别</p>
<ul>
<li>JDK只能针对实现了接口的类，生成代理，实现同样的接口方法，但里面调用的还是目标对象的方法</li>
<li>CGLIB是针对类实现代理，通过修改字节码方式，对目标对象生成一个其子类，覆写父类的方法，从而达到代理，所以类不能声明为final</li>
</ul>
</li>
<li>
<p>Spring可以强制使用cglib，配置proxyTargetClass属性为true即可</p>
</li>
<li>
<p>根据上述找到的增强器，Spring根据配置，创建对应的AopProxy，JdkDynamicAopProxy或者CglibAopProxy</p>
</li>
<li>
<p>调用AopProxy的getProxy方法</p>
</li>
<li>
<p>JdkDynamicAopProxy</p>
<ul>
<li>
<p>使用JDK自带的Proxy.newProxyInstance方式创建代理对象</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Proxy<span style=color:#f92672>.</span><span style=color:#a6e22e>newProxyInstance</span><span style=color:#f92672>(</span>classLoader<span style=color:#f92672>,</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>proxiedInterfaces</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>);</span>
</code></pre></div></li>
<li>
<p>最后一个参数this，说明JdkDynamicAopProxy肯定实现了InvocationHandler，最后执行的目标方法就是invoke方法</p>
</li>
<li>
<p>在这里面处理了expose-proxy属性</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>//AopContext 自身无法获取代理对象的处理 exposeProxy
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>advised</span><span style=color:#f92672>.</span><span style=color:#a6e22e>exposeProxy</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
   <span style=color:#75715e>// Make invocation available if necessary.
</span><span style=color:#75715e></span>   oldProxy <span style=color:#f92672>=</span> AopContext<span style=color:#f92672>.</span><span style=color:#a6e22e>setCurrentProxy</span><span style=color:#f92672>(</span>proxy<span style=color:#f92672>);</span>
   setProxyContext <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>
</code></pre></div></li>
<li>
<p>然后根据传入的增强器，使用ReflectiveMethodInvocation封装，方法链，逐个调用。不同的advistor使用不同的实现类去实现，例如</p>
<ul>
<li>
<pre tabindex=0><code>AspectJAroundAdvice
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Override</span>
<span style=color:#a6e22e>@Nullable</span>
<span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>invoke</span><span style=color:#f92672>(</span>MethodInvocation mi<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> Throwable <span style=color:#f92672>{</span>
   <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!(</span>mi <span style=color:#66d9ef>instanceof</span> ProxyMethodInvocation<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
      <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalStateException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;MethodInvocation is not a Spring ProxyMethodInvocation: &#34;</span> <span style=color:#f92672>+</span> mi<span style=color:#f92672>);</span>
   <span style=color:#f92672>}</span>
   ProxyMethodInvocation pmi <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>ProxyMethodInvocation<span style=color:#f92672>)</span> mi<span style=color:#f92672>;</span>
   ProceedingJoinPoint pjp <span style=color:#f92672>=</span> lazyGetProceedingJoinPoint<span style=color:#f92672>(</span>pmi<span style=color:#f92672>);</span>
   JoinPointMatch jpm <span style=color:#f92672>=</span> getJoinPointMatch<span style=color:#f92672>(</span>pmi<span style=color:#f92672>);</span>
   <span style=color:#66d9ef>return</span> invokeAdviceMethod<span style=color:#f92672>(</span>pjp<span style=color:#f92672>,</span> jpm<span style=color:#f92672>,</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>这也就是为什么@Around的方法，入参可以是ProceedingJoinPoint</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>invokeAdviceMethodWithGivenArgs<span style=color:#f92672>(</span>argBinding<span style=color:#f92672>(</span>jp<span style=color:#f92672>,</span> jpMatch<span style=color:#f92672>,</span> returnValue<span style=color:#f92672>,</span> t<span style=color:#f92672>));</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>直至所有的方法链调用结束</p>
</li>
<li>
<p>最后执行目标方法</p>
</li>
<li>
<p>处理返回对象</p>
</li>
</ul>
</li>
</ul>
<h1 id=springmvc流程>SpringMVC流程<a hidden class=anchor aria-hidden=true href=#springmvc流程>#</a></h1>
<p>SpringMvc会使用DispatcherServlet作为请求的入口。</p>
<p>作为一个Servlet，init方法，执行后，DispatcherServlet会创建自己的IOC容器，并且把ServletContext中的IOC作为父容器，所以MVC的相关内容，例如Controller可以放在MVC的IOC中，而其余的，dao，service可以放在SevletContext里的IOC，好处就是隔离开了M层，如果要还Struts，可以直接更换，而不用考虑dao和service了。</p>
<p>init方法，除了创建MVC自己的容器，还根据DispatchServlet.properties里的内容，进行一系列的初始化动作。</p>
<p>DispatcherServlet继承于FrameworkServlet。集成HttpServlet，最后从Servlet会执行到DispatchServlet的processRequest方法。processRequest中，Spring会将当前的请求requestAttributes放在RequestContextHolder中用ThreadLocal保存，所以后续的Controller都可以使用。</p>
<p>随后走到doDispatch中，做一些必要的检查，然后根据容器里的handerMapping找到对应的hanlder，使用HandlerExecutionChain将符合该请求的拦截器，封装在一起，跨域也是在这里增加另一个拦截器</p>
<p>准备好HandlerExecutionChain之后，进入流程。先调用所有的拦截器preHandler方法</p>
<p>Handler有很多种，最后使用适配器模式，创建handlerAdapter去调用不同handler的具体执行方法。从而得到modelAndView</p>
<p>然后调用拦截器的postHandler方法</p>
<p>得到modelAndView，之后会使用ViewRovler解析view，最后获取requestDispatcher，forward或者是重定向到新的路径，并且把model，放入request的attribute里，从而进入下一个请求了，可以是reward也可以是redirect</p>
<h2 id=为什么在controller的方法参数里写httpservletrequest就可以获得到请求对象以及requestbody和requestparam>为什么在Controller的方法参数里，写HttpServletRequest就可以获得到请求对象，以及@RequestBody和@RequestParam<a hidden class=anchor aria-hidden=true href=#为什么在controller的方法参数里写httpservletrequest就可以获得到请求对象以及requestbody和requestparam>#</a></h2>
<p>不管是xml中配置<a href=mvc:annotation-driven/>mvc:annotation-driven/</a>，还是使用注解@EnableWebMvc，本质上都是在容器中注入了RequestMappingHandlerMapping这样的实例。实例实现了initalizingBean接口，在容器中实例化的时候，会将容器中所有的Bean找出来，检查Class是否被@Controller或者@RequestMapping修饰，找到即作为一个handler。</p>
<p>然后去找到Hanlder对应的adapter，RequestMappingHandlerAdapter，Adapter的handler方法。</p>
<p>hanlder方法的核心是，invokeHandlerMethod，通过反射调用目标方法，并且通过一些列配置，将方法需要的配置传入进去，其中解析方法参数的就是一些列的argumentResolvers。</p>
<p>Spring依然是在RequestMappingHandlerAdapter的afterPropertiesSet()方法之后，。初始化了argumentResolvers</p>
<p>如下</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>private</span> List<span style=color:#f92672>&lt;</span>HandlerMethodArgumentResolver<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getDefaultArgumentResolvers</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
   List<span style=color:#f92672>&lt;</span>HandlerMethodArgumentResolver<span style=color:#f92672>&gt;</span> resolvers <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;(</span>30<span style=color:#f92672>);</span>

   <span style=color:#75715e>// Annotation-based argument resolution
</span><span style=color:#75715e></span>   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> RequestParamMethodArgumentResolver<span style=color:#f92672>(</span>getBeanFactory<span style=color:#f92672>(),</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>));</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> RequestParamMapMethodArgumentResolver<span style=color:#f92672>());</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> PathVariableMethodArgumentResolver<span style=color:#f92672>());</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> PathVariableMapMethodArgumentResolver<span style=color:#f92672>());</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> MatrixVariableMethodArgumentResolver<span style=color:#f92672>());</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> MatrixVariableMapMethodArgumentResolver<span style=color:#f92672>());</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ServletModelAttributeMethodProcessor<span style=color:#f92672>(</span><span style=color:#66d9ef>false</span><span style=color:#f92672>));</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> RequestResponseBodyMethodProcessor<span style=color:#f92672>(</span>getMessageConverters<span style=color:#f92672>(),</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>requestResponseBodyAdvice</span><span style=color:#f92672>));</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> RequestPartMethodArgumentResolver<span style=color:#f92672>(</span>getMessageConverters<span style=color:#f92672>(),</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>requestResponseBodyAdvice</span><span style=color:#f92672>));</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> RequestHeaderMethodArgumentResolver<span style=color:#f92672>(</span>getBeanFactory<span style=color:#f92672>()));</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> RequestHeaderMapMethodArgumentResolver<span style=color:#f92672>());</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ServletCookieValueMethodArgumentResolver<span style=color:#f92672>(</span>getBeanFactory<span style=color:#f92672>()));</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ExpressionValueMethodArgumentResolver<span style=color:#f92672>(</span>getBeanFactory<span style=color:#f92672>()));</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> SessionAttributeMethodArgumentResolver<span style=color:#f92672>());</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> RequestAttributeMethodArgumentResolver<span style=color:#f92672>());</span>

   <span style=color:#75715e>// Type-based argument resolution
</span><span style=color:#75715e></span>   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ServletRequestMethodArgumentResolver<span style=color:#f92672>());</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ServletResponseMethodArgumentResolver<span style=color:#f92672>());</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> HttpEntityMethodProcessor<span style=color:#f92672>(</span>getMessageConverters<span style=color:#f92672>(),</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>requestResponseBodyAdvice</span><span style=color:#f92672>));</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> RedirectAttributesMethodArgumentResolver<span style=color:#f92672>());</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ModelMethodProcessor<span style=color:#f92672>());</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> MapMethodProcessor<span style=color:#f92672>());</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ErrorsMethodArgumentResolver<span style=color:#f92672>());</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> SessionStatusMethodArgumentResolver<span style=color:#f92672>());</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> UriComponentsBuilderMethodArgumentResolver<span style=color:#f92672>());</span>
   <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>KotlinDetector<span style=color:#f92672>.</span><span style=color:#a6e22e>isKotlinPresent</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
      resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ContinuationHandlerMethodArgumentResolver<span style=color:#f92672>());</span>
   <span style=color:#f92672>}</span>

   <span style=color:#75715e>// Custom arguments
</span><span style=color:#75715e></span>   <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>getCustomArgumentResolvers<span style=color:#f92672>()</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
      resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>addAll</span><span style=color:#f92672>(</span>getCustomArgumentResolvers<span style=color:#f92672>());</span>
   <span style=color:#f92672>}</span>

   <span style=color:#75715e>// Catch-all
</span><span style=color:#75715e></span>   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> PrincipalMethodArgumentResolver<span style=color:#f92672>());</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> RequestParamMethodArgumentResolver<span style=color:#f92672>(</span>getBeanFactory<span style=color:#f92672>(),</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>));</span>
   resolvers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ServletModelAttributeMethodProcessor<span style=color:#f92672>(</span><span style=color:#66d9ef>true</span><span style=color:#f92672>));</span>

   <span style=color:#66d9ef>return</span> resolvers<span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>通过 HandlerMethodArgumentResolver的supportsParameter方法</p>
<p>以RequestParam为例</p>
<p>首先RequestParamMethodArgumentResolver的父类AbstractNamedValueMethodArgumentResolver，进行校验，校验Hanlder的参数是否是必填，会将@RequestParams的required进行校验，从HttpServletRequest里的parameter进行校验。校验成功，会通过反射执行handler，并将参数传入Handler中。</p>
<p>@RequestBody也是一样，使用的RequestResponseBodyMethodProcessor去处理参数的</p>
<p>在处理@RequestBody的时候，RequestMappingHandlerAdapter的所有messageConverters，找到符合的，我们常用的application/json就是MappingJackson2HttpMessageConverter，需要引入jackson的核心包</p>
<p>至于其他的Httpservlet都是是同对应的argumentResolve处理的</p>
<h1 id=springboot的工作原理>SpringBoot的工作原理<a hidden class=anchor aria-hidden=true href=#springboot的工作原理>#</a></h1>
<p>Spring在诞生之初，配置类一直是令开发者吐槽的模块，当java5推出注解后，可以使用java类进行配置了，但依然很繁琐。而SpringBoot的最大的一个特点，就是解决复杂的配置。</p>
<p>SpringBoot推出了一系列注解，他们可以将各类Spring boot starter，无感的注入到容器中。</p>
<p>SpringBoot在SpringBoot的run方法里，完成了一些列工作。</p>
<p>首先是构造方法会根据当前类路径下是否包含webflux，或者servlet相关类，从而决定实例化的容器对象。</p>
<p>以常见的servlet为例，SpringBoot会实例化AnnotationConfigServletWebServerApplicationContext</p>
<p>而在SpringBoot构造函数触发时，会寻找类路径下META/Spring.factories文件，下所有的ApplicationContextInitializer实例，和ApplicationListener实例，并且放入当前对象的属性中</p>
<ul>
<li>
<p>核心的run方法，里首先还是从spring.factories里找到所有的SpringApplicationRunListener，调用其starting方法，</p>
</li>
<li>
<p>然后封装main方法的arg参数，校验环境，即我们可以在外部指明spring的profile.active=prod就是在这里指明的</p>
</li>
<li>
<p>准备好main的arg以及sytem的相关属性后，会调用所有SpringApplicationRunListener的environmentPrepared，也就是在这里面进行了Spring配置文件，application.yml或者是application.properties的处理</p>
</li>
<li>
<p>打印Banner</p>
</li>
<li>
<p>根据上述得到的实例化Class，实例化IOC容器</p>
</li>
<li>
<p>从spring.factories里找到SpringBootExceptionReporter用于异常打印</p>
</li>
<li>
<p>准备名称生成器，资源加载器，类加载器等。</p>
</li>
<li>
<p>调用Spring.factories里的ApplicationContextInitializer的initialize方法</p>
</li>
<li>
<p>调用ApplicationContextInitializer的contextPrepared方法</p>
</li>
<li>
<p>打印启动类信息，打印profile信息</p>
</li>
<li>
<p>加载启动类的注解信息，即启动类也可以是一个组件，<strong>注入到容器中</strong>，默认情况下，@SpringBootApplication里的@SpringBootConfiguration里有@Component注解，Spring会通过注解方式将其注入到容器中，细节就不说了，核心是@SpringBootConfiguration身上有@Configuration，而且有@Import注解，引入的是AutoConfigurationImportSelector</p>
<p>SpringBoot在启动的时候，注入了ConfigurationClassPostProcessor该类实现了BeanDefinitionRegistryPostProcessor会在容器的refresh里的invokeBeanFactoryPostProcesser，里触发</p>
<p>postProcessBeanDefinitionRegistry方法，会找到容器里所有的@Configuration实例，这里此时容器里有的就是启动类本身，然后会处理，@Configuration上的@Import，并且执行@Import类的process方法，即，最后依然调用的是selectImports方法，得到的就是Spring.factories里配置的**org.springframework.boot.autoconfigure.EnableAutoConfiguration=**的值，然后逐步解析所有的类，这样容器里就有第三方调用的所有信息了</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>process</span><span style=color:#f92672>(</span>AnnotationMetadata annotationMetadata<span style=color:#f92672>,</span>
      DeferredImportSelector deferredImportSelector<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
   Assert<span style=color:#f92672>.</span><span style=color:#a6e22e>state</span><span style=color:#f92672>(</span>
         deferredImportSelector <span style=color:#66d9ef>instanceof</span> AutoConfigurationImportSelector<span style=color:#f92672>,</span>
         <span style=color:#f92672>()</span> <span style=color:#f92672>-&gt;</span> String<span style=color:#f92672>.</span><span style=color:#a6e22e>format</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Only %s implementations are supported, got %s&#34;</span><span style=color:#f92672>,</span>
               AutoConfigurationImportSelector<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>.</span><span style=color:#a6e22e>getSimpleName</span><span style=color:#f92672>(),</span>
               deferredImportSelector<span style=color:#f92672>.</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>().</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>()));</span>
   AutoConfigurationEntry autoConfigurationEntry <span style=color:#f92672>=</span> <span style=color:#f92672>((</span>AutoConfigurationImportSelector<span style=color:#f92672>)</span> deferredImportSelector<span style=color:#f92672>)</span>
         <span style=color:#f92672>.</span><span style=color:#a6e22e>getAutoConfigurationEntry</span><span style=color:#f92672>(</span>getAutoConfigurationMetadata<span style=color:#f92672>(),</span>
               annotationMetadata<span style=color:#f92672>);</span>
   <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>autoConfigurationEntries</span><span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>autoConfigurationEntry<span style=color:#f92672>);</span>
   <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>String importClassName <span style=color:#f92672>:</span> autoConfigurationEntry<span style=color:#f92672>.</span><span style=color:#a6e22e>getConfigurations</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
      <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>entries</span><span style=color:#f92672>.</span><span style=color:#a6e22e>putIfAbsent</span><span style=color:#f92672>(</span>importClassName<span style=color:#f92672>,</span> annotationMetadata<span style=color:#f92672>);</span>
   <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>protected</span> AutoConfigurationEntry <span style=color:#a6e22e>getAutoConfigurationEntry</span><span style=color:#f92672>(</span>
      AutoConfigurationMetadata autoConfigurationMetadata<span style=color:#f92672>,</span>
      AnnotationMetadata annotationMetadata<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
   <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>isEnabled<span style=color:#f92672>(</span>annotationMetadata<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
      <span style=color:#66d9ef>return</span> EMPTY_ENTRY<span style=color:#f92672>;</span>
   <span style=color:#f92672>}</span>
   AnnotationAttributes attributes <span style=color:#f92672>=</span> getAttributes<span style=color:#f92672>(</span>annotationMetadata<span style=color:#f92672>);</span>
   List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> configurations <span style=color:#f92672>=</span> getCandidateConfigurations<span style=color:#f92672>(</span>annotationMetadata<span style=color:#f92672>,</span><span style=color:#75715e>//获取到所有的/META-INF/spring-factories中的configuration
</span><span style=color:#75715e></span>         attributes<span style=color:#f92672>);</span>
   configurations <span style=color:#f92672>=</span> removeDuplicates<span style=color:#f92672>(</span>configurations<span style=color:#f92672>);</span><span style=color:#75715e>//删除重复的
</span><span style=color:#75715e></span>   Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> exclusions <span style=color:#f92672>=</span> getExclusions<span style=color:#f92672>(</span>annotationMetadata<span style=color:#f92672>,</span> attributes<span style=color:#f92672>);</span>
   checkExcludedClasses<span style=color:#f92672>(</span>configurations<span style=color:#f92672>,</span> exclusions<span style=color:#f92672>);</span><span style=color:#75715e>//根据上面的属性excclusion
</span><span style=color:#75715e></span>   configurations<span style=color:#f92672>.</span><span style=color:#a6e22e>removeAll</span><span style=color:#f92672>(</span>exclusions<span style=color:#f92672>);</span>
   configurations <span style=color:#f92672>=</span> filter<span style=color:#f92672>(</span>configurations<span style=color:#f92672>,</span> autoConfigurationMetadata<span style=color:#f92672>);</span>
   fireAutoConfigurationImportEvents<span style=color:#f92672>(</span>configurations<span style=color:#f92672>,</span> exclusions<span style=color:#f92672>);</span><span style=color:#75715e>//通知导入成功
</span><span style=color:#75715e></span>   <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> AutoConfigurationEntry<span style=color:#f92672>(</span>configurations<span style=color:#f92672>,</span> exclusions<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>
</code></pre></div></li>
</ul>
<h1 id=spring事务>Spring事务<a hidden class=anchor aria-hidden=true href=#spring事务>#</a></h1>
<ul>
<li>
<p>Spring使用注解@Transactional放在方法，或者类上</p>
</li>
<li>
<p>@Transactional属性有</p>
<ul>
<li>transactionManager指明事务管理器，在多数据源的时候，需要指明</li>
<li>propagation传播行为默认是Propagation.REQUIRED，即当前如果存在事务，则用同一个事务，否则开启一个新事务</li>
<li>isolation隔离级别，默认是数据库的隔离级别，mysql默认时可重复度，幻读是通过MVCC和间隙锁解决的</li>
<li>timeout超时时间</li>
<li>readOnly是否只读</li>
<li>rollbackFor发生什么异常才会会滚，默认是RuntimeException</li>
<li>rollbackForClassName</li>
<li>noRollbackFor</li>
<li>noRollbackForClassName</li>
</ul>
</li>
<li>
<p>原理，@Transactional注解是基于AOP原理，容器在获取相应bean的时候，会去使用wrapifNecessary包装bean，Spring的流程是，从容器里找到所有的adviser，而@Transactional会在容器里注入BeanFactoryTransactionAttributeSourceAdvisor，从而最后得到的是代理对象，而代理对象针对于满足切面条件的bean，会做处理，@Transactional就是切面条件，会在目标方法执行之前开启一个事务，执行之后提交或者回滚一个事务，操作事务的都是TransactionManager</p>
</li>
<li>
<p>提问</p>
<ul>
<li>
<p>如果在一个方法里异常被try-catch了，还会会滚吗？不会了，因为Sping处理提交事务是在切面的AfterRunning之后提交的，在那之前会使用try-catch捕捉，而目标自己捕捉过的话，Spring就捕捉不到了，除非在catch里再抛出</p>
</li>
<li>
<p>如果自己使用TransactionManager重新在获取一个事务，手动提交之前，抛出异常的话，会会滚吗？不会，会被Spring捕捉到</p>
</li>
<li>
<p>如果在抛出异常之前，就手动提交了，Spring会回滚吗，可能会 也可能不会，这和Spring事务的传播行为有关，默认情况下传播行为是，如果当前有事务了，就用当前事务，否则开启一个新事务。</p>
<p>如果有@Transactional注解了，意味着Spring已经开启了一个事务了，后续自己手动开启的事务，就是之前的事务了，并非一个新事务，Spring在提交事务之前，会判断是否为一个新事务，是的话，才会进行提交，否则不会有动作。所有如果传播行为不变的话，会回滚的，如果是强制开启新的事务的传播行为，则不会会滚</p>
</li>
</ul>
</li>
</ul>
<h1 id=讲讲你会的设计模式spring里面用到了哪些设计模式>讲讲你会的设计模式，Spring里面用到了哪些设计模式<a hidden class=anchor aria-hidden=true href=#讲讲你会的设计模式spring里面用到了哪些设计模式>#</a></h1>
<h1 id=java中的date是线程安全的吗你是如何保证线程安全的>Java中的Date是线程安全的吗？你是如何保证线程安全的<a hidden class=anchor aria-hidden=true href=#java中的date是线程安全的吗你是如何保证线程安全的>#</a></h1>
<h1 id=讲讲threadlocal-和java的内存模型吧>讲讲ThreadLocal 和java的内存模型吧<a hidden class=anchor aria-hidden=true href=#讲讲threadlocal-和java的内存模型吧>#</a></h1>
<h1 id=webasynctask>WebAsyncTask<a hidden class=anchor aria-hidden=true href=#webasynctask>#</a></h1>
<p>WebAsyncTask，是基于Servlet3.0异步Servlet的特性，用于提高容器的吞吐量，客户端请求进来时，当前的容器分配的线程会直接返回，并会开启一个新线程用于处理客户端请求，当新线程结束时，客户端才会收到请求。而容器的线程就可以回收用于新的请求，提高了吞吐量</p>
<h2 id=拦截器和过滤器的区别>拦截器和过滤器的区别<a hidden class=anchor aria-hidden=true href=#拦截器和过滤器的区别>#</a></h2>
<p>首先，拦截器与过滤器不是一起的，拦截器是Spring的，而过滤器filter是javax提供的，filter会在拦截器之前执行，拦截器可以达到更细粒控制请求。拦截器可以获得到具体执行的handler，可以对handler做个性化操作。过滤器可以做的，拦截器都可以做到，拦截器做的，过滤器做不了。</p>
<h1 id=聊一下mybatis>聊一下mybatis<a hidden class=anchor aria-hidden=true href=#聊一下mybatis>#</a></h1>
<h2 id=什么是mybatis的懒加载>什么是mybatis的懒加载<a hidden class=anchor aria-hidden=true href=#什么是mybatis的懒加载>#</a></h2>
<h2 id=mybatis的mapper是如何与数据库连接的>mybatis的mapper是如何与数据库连接的<a hidden class=anchor aria-hidden=true href=#mybatis的mapper是如何与数据库连接的>#</a></h2>
<h1 id=什么是索引索引为什么可以加查询>什么是索引，索引为什么可以加查询<a hidden class=anchor aria-hidden=true href=#什么是索引索引为什么可以加查询>#</a></h1>
<h1 id=innodb索引实现>Innodb索引实现<a hidden class=anchor aria-hidden=true href=#innodb索引实现>#</a></h1>
<h1 id=b树和b树>B树和B+树<a hidden class=anchor aria-hidden=true href=#b树和b树>#</a></h1>
<h1 id=redis使用部署哨兵>Redis使用，部署，哨兵<a hidden class=anchor aria-hidden=true href=#redis使用部署哨兵>#</a></h1>
<h1 id=tcp三次握手>TCP三次握手<a hidden class=anchor aria-hidden=true href=#tcp三次握手>#</a></h1>
<h1 id=乐观锁悲观锁举例>乐观锁，悲观锁，举例<a hidden class=anchor aria-hidden=true href=#乐观锁悲观锁举例>#</a></h1>
<h1 id=设计模式>设计模式<a hidden class=anchor aria-hidden=true href=#设计模式>#</a></h1>
<h1 id=redis扩容>Redis扩容<a hidden class=anchor aria-hidden=true href=#redis扩容>#</a></h1>
<h1 id=cas概念原子类的实现>CAS概念，原子类的实现<a hidden class=anchor aria-hidden=true href=#cas概念原子类的实现>#</a></h1>
<h1 id=synchronize-底层原理>Synchronize 底层原理<a hidden class=anchor aria-hidden=true href=#synchronize-底层原理>#</a></h1>
<h1 id=aqs>AQS<a hidden class=anchor aria-hidden=true href=#aqs>#</a></h1>
<h1 id=网络模型你知道的网络协议>网络模型，你知道的网络协议<a hidden class=anchor aria-hidden=true href=#网络模型你知道的网络协议>#</a></h1>
<h1 id=https的连接过程ssl>HTTPS的连接过程，SSL<a hidden class=anchor aria-hidden=true href=#https的连接过程ssl>#</a></h1>
<h1 id=单链表算法反转查找>单链表算法，反转，查找<a hidden class=anchor aria-hidden=true href=#单链表算法反转查找>#</a></h1>
<h1 id=jvm垃圾回收机制>jvm垃圾回收机制<a hidden class=anchor aria-hidden=true href=#jvm垃圾回收机制>#</a></h1>
<h1 id=工作流引擎>工作流引擎<a hidden class=anchor aria-hidden=true href=#工作流引擎>#</a></h1>
<h1 id=spring-mvc-webflux>Spring MVC webFlux<a hidden class=anchor aria-hidden=true href=#spring-mvc-webflux>#</a></h1>
<h1 id=netty>netty<a hidden class=anchor aria-hidden=true href=#netty>#</a></h1>
<h1 id=redis为什么这么快>redis为什么这么快<a hidden class=anchor aria-hidden=true href=#redis为什么这么快>#</a></h1>
<h1 id=mysql的explain>Mysql的explain<a hidden class=anchor aria-hidden=true href=#mysql的explain>#</a></h1>
<h1 id=k8s>K8S<a hidden class=anchor aria-hidden=true href=#k8s>#</a></h1>
<h1 id=讲一讲反射以及你工作中用到的地方>讲一讲反射，以及你工作中用到的地方<a hidden class=anchor aria-hidden=true href=#讲一讲反射以及你工作中用到的地方>#</a></h1>
<p>java反射，提供给我们方式去动态创建类，或者是动态执行方法，当我们因为某些条件，不知道目标应该执行什么方法的时候，就可以使用反射。</p>
<p>例如，请假，如果超过2天，就执行某方法，否则执行另一个方法，我们就可以用反射</p>
<p>反射也被大量应用于mybatis和spring之中，spring中aop，创建bean的动作都是反射，因为他们无论是执行方法还是构建实例都是未知的参数和条件</p>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=prev href=https://luluhome.site:8101/posts/netty/>
<span class=title>« Prev Page</span>
<br>
<span></span>
</a>
<a class=next href=https://luluhome.site:8101/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B/>
<span class=title>Next Page »</span>
<br>
<span></span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://luluhome.site:8101/>Hao Sun</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>