<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>平时疑问 | Hao Sun</title>
<meta name=keywords content="自问自答">
<meta name=description content="平时疑问   浏览器输入一个地址，整个流程
  如果线上流量暴增，全都打到一个 upstream 上了，怎么排查
  如何在 nginx 的 access log 中查出请求前 10 的 ip
  台阶问题，假如对于上台阶，可以一次上一阶，也可以一次上两阶，写一个方法，实现输入台阶数，输出可以有多少种上法。
  广度优先和深度优先
  spring reactive，响应式聊下，什么时候适合用？背压是什么东西，backpress
  压缩算法，怎么就“压缩”了？如何减少体积的？
  实时一致性，最终一致性是什么？什么场景下用那种，如何实现的？
  实时一致性:
微服务中，场景用户使用积分兑换优惠券，积分service先扣除积分，优惠券service再进行发券动作，如果网络问题，积分扣成功了，但是优惠券发失败了。用户会投诉，必须要证优惠券和积分要在同一个分布式事务中.
解决方案：市面上的分布式事务，阿里的seata
  最终一致性:
微服务中，用户选择商品下单，商品service进行库存扣件，订单service生成订单，交易service生成交易订单。如果网络原因导致，交易service生成交易订单失败了。并没有影响，只需要通过措施重新弥补交易service去生成交易订单即可。
解决方法：mq，通过mq的重试机制以及持久化等特性，每一个微服务与下游微服务进行交互动作都是通过mq的消息。保证消息能够被消费，长时间未消费可以告警。
    消息堆积如何处理？以及产生的危害。
  怎么保证接口幂等
  如何评判一个服务的好坏？你是如何进行压测的？查看了哪些指标
  对象存储，文件存储，块存储。区别
  服务器卡了，字都快打不动了，咋回事，怎么排查
  用过mysql行锁吗
用过，在一些比较简单的微服务场景，或者无法使用其他中间件的前提下。如果需要部署多节点的话，最方便的分布式锁就是mysql，因为我们的db库基本都是单节点的mysql或者mariadb。使用起来其实很简单，就是一个update语句，更新version字段。也就是所谓的乐观锁。开启一个事务，先select锁，然后尝试更新锁，在没完成业务的之前是不提交锁的，所以，其他线程会在获取锁的时候就停下来。因为update，delete，insert默认都是带for update，即行锁的。当然select不会阻塞，除非主动的设置for update。这样就是最基础的一个分布式锁了。切记锁字段必须要有索引，否则锁整个表。就G了
  netty玩过吗，玩过哪些东西，能干啥">
<meta name=author content="Hao Sun">
<link rel=canonical href=https://sunhao1256.github.io/posts/%E5%B9%B3%E6%97%B6%E7%96%91%E9%97%AE/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://sunhao1256.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=https://sunhao1256.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://sunhao1256.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://sunhao1256.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://sunhao1256.github.io/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.89.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="平时疑问">
<meta property="og:description" content="平时疑问   浏览器输入一个地址，整个流程
  如果线上流量暴增，全都打到一个 upstream 上了，怎么排查
  如何在 nginx 的 access log 中查出请求前 10 的 ip
  台阶问题，假如对于上台阶，可以一次上一阶，也可以一次上两阶，写一个方法，实现输入台阶数，输出可以有多少种上法。
  广度优先和深度优先
  spring reactive，响应式聊下，什么时候适合用？背压是什么东西，backpress
  压缩算法，怎么就“压缩”了？如何减少体积的？
  实时一致性，最终一致性是什么？什么场景下用那种，如何实现的？
  实时一致性:
微服务中，场景用户使用积分兑换优惠券，积分service先扣除积分，优惠券service再进行发券动作，如果网络问题，积分扣成功了，但是优惠券发失败了。用户会投诉，必须要证优惠券和积分要在同一个分布式事务中.
解决方案：市面上的分布式事务，阿里的seata
  最终一致性:
微服务中，用户选择商品下单，商品service进行库存扣件，订单service生成订单，交易service生成交易订单。如果网络原因导致，交易service生成交易订单失败了。并没有影响，只需要通过措施重新弥补交易service去生成交易订单即可。
解决方法：mq，通过mq的重试机制以及持久化等特性，每一个微服务与下游微服务进行交互动作都是通过mq的消息。保证消息能够被消费，长时间未消费可以告警。
    消息堆积如何处理？以及产生的危害。
  怎么保证接口幂等
  如何评判一个服务的好坏？你是如何进行压测的？查看了哪些指标
  对象存储，文件存储，块存储。区别
  服务器卡了，字都快打不动了，咋回事，怎么排查
  用过mysql行锁吗
用过，在一些比较简单的微服务场景，或者无法使用其他中间件的前提下。如果需要部署多节点的话，最方便的分布式锁就是mysql，因为我们的db库基本都是单节点的mysql或者mariadb。使用起来其实很简单，就是一个update语句，更新version字段。也就是所谓的乐观锁。开启一个事务，先select锁，然后尝试更新锁，在没完成业务的之前是不提交锁的，所以，其他线程会在获取锁的时候就停下来。因为update，delete，insert默认都是带for update，即行锁的。当然select不会阻塞，除非主动的设置for update。这样就是最基础的一个分布式锁了。切记锁字段必须要有索引，否则锁整个表。就G了
  netty玩过吗，玩过哪些东西，能干啥">
<meta property="og:type" content="article">
<meta property="og:url" content="https://sunhao1256.github.io/posts/%E5%B9%B3%E6%97%B6%E7%96%91%E9%97%AE/"><meta property="og:image" content="https://sunhao1256.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-01-11T14:43:18+08:00">
<meta property="article:modified_time" content="2022-01-11T14:43:18+08:00"><meta property="og:site_name" content="Hao Sun">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://sunhao1256.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name=twitter:title content="平时疑问">
<meta name=twitter:description content="平时疑问   浏览器输入一个地址，整个流程
  如果线上流量暴增，全都打到一个 upstream 上了，怎么排查
  如何在 nginx 的 access log 中查出请求前 10 的 ip
  台阶问题，假如对于上台阶，可以一次上一阶，也可以一次上两阶，写一个方法，实现输入台阶数，输出可以有多少种上法。
  广度优先和深度优先
  spring reactive，响应式聊下，什么时候适合用？背压是什么东西，backpress
  压缩算法，怎么就“压缩”了？如何减少体积的？
  实时一致性，最终一致性是什么？什么场景下用那种，如何实现的？
  实时一致性:
微服务中，场景用户使用积分兑换优惠券，积分service先扣除积分，优惠券service再进行发券动作，如果网络问题，积分扣成功了，但是优惠券发失败了。用户会投诉，必须要证优惠券和积分要在同一个分布式事务中.
解决方案：市面上的分布式事务，阿里的seata
  最终一致性:
微服务中，用户选择商品下单，商品service进行库存扣件，订单service生成订单，交易service生成交易订单。如果网络原因导致，交易service生成交易订单失败了。并没有影响，只需要通过措施重新弥补交易service去生成交易订单即可。
解决方法：mq，通过mq的重试机制以及持久化等特性，每一个微服务与下游微服务进行交互动作都是通过mq的消息。保证消息能够被消费，长时间未消费可以告警。
    消息堆积如何处理？以及产生的危害。
  怎么保证接口幂等
  如何评判一个服务的好坏？你是如何进行压测的？查看了哪些指标
  对象存储，文件存储，块存储。区别
  服务器卡了，字都快打不动了，咋回事，怎么排查
  用过mysql行锁吗
用过，在一些比较简单的微服务场景，或者无法使用其他中间件的前提下。如果需要部署多节点的话，最方便的分布式锁就是mysql，因为我们的db库基本都是单节点的mysql或者mariadb。使用起来其实很简单，就是一个update语句，更新version字段。也就是所谓的乐观锁。开启一个事务，先select锁，然后尝试更新锁，在没完成业务的之前是不提交锁的，所以，其他线程会在获取锁的时候就停下来。因为update，delete，insert默认都是带for update，即行锁的。当然select不会阻塞，除非主动的设置for update。这样就是最基础的一个分布式锁了。切记锁字段必须要有索引，否则锁整个表。就G了
  netty玩过吗，玩过哪些东西，能干啥">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sunhao1256.github.io/posts/"},{"@type":"ListItem","position":2,"name":"平时疑问","item":"https://sunhao1256.github.io/posts/%E5%B9%B3%E6%97%B6%E7%96%91%E9%97%AE/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"平时疑问","name":"平时疑问","description":"平时疑问   浏览器输入一个地址，整个流程\n  如果线上流量暴增，全都打到一个 upstream 上了，怎么排查\n  如何在 nginx 的 access log 中查出请求前 10 的 ip\n  台阶问题，假如对于上台阶，可以一次上一阶，也可以一次上两阶，写一个方法，实现输入台阶数，输出可以有多少种上法。\n  广度优先和深度优先\n  spring reactive，响应式聊下，什么时候适合用？背压是什么东西，backpress\n  压缩算法，怎么就“压缩”了？如何减少体积的？\n  实时一致性，最终一致性是什么？什么场景下用那种，如何实现的？\n  实时一致性:\n微服务中，场景用户使用积分兑换优惠券，积分service先扣除积分，优惠券service再进行发券动作，如果网络问题，积分扣成功了，但是优惠券发失败了。用户会投诉，必须要证优惠券和积分要在同一个分布式事务中.\n解决方案：市面上的分布式事务，阿里的seata\n  最终一致性:\n微服务中，用户选择商品下单，商品service进行库存扣件，订单service生成订单，交易service生成交易订单。如果网络原因导致，交易service生成交易订单失败了。并没有影响，只需要通过措施重新弥补交易service去生成交易订单即可。\n解决方法：mq，通过mq的重试机制以及持久化等特性，每一个微服务与下游微服务进行交互动作都是通过mq的消息。保证消息能够被消费，长时间未消费可以告警。\n    消息堆积如何处理？以及产生的危害。\n  怎么保证接口幂等\n  如何评判一个服务的好坏？你是如何进行压测的？查看了哪些指标\n  对象存储，文件存储，块存储。区别\n  服务器卡了，字都快打不动了，咋回事，怎么排查\n  用过mysql行锁吗\n用过，在一些比较简单的微服务场景，或者无法使用其他中间件的前提下。如果需要部署多节点的话，最方便的分布式锁就是mysql，因为我们的db库基本都是单节点的mysql或者mariadb。使用起来其实很简单，就是一个update语句，更新version字段。也就是所谓的乐观锁。开启一个事务，先select锁，然后尝试更新锁，在没完成业务的之前是不提交锁的，所以，其他线程会在获取锁的时候就停下来。因为update，delete，insert默认都是带for update，即行锁的。当然select不会阻塞，除非主动的设置for update。这样就是最基础的一个分布式锁了。切记锁字段必须要有索引，否则锁整个表。就G了\n  netty玩过吗，玩过哪些东西，能干啥","keywords":["自问自答"],"articleBody":"平时疑问   浏览器输入一个地址，整个流程\n  如果线上流量暴增，全都打到一个 upstream 上了，怎么排查\n  如何在 nginx 的 access log 中查出请求前 10 的 ip\n  台阶问题，假如对于上台阶，可以一次上一阶，也可以一次上两阶，写一个方法，实现输入台阶数，输出可以有多少种上法。\n  广度优先和深度优先\n  spring reactive，响应式聊下，什么时候适合用？背压是什么东西，backpress\n  压缩算法，怎么就“压缩”了？如何减少体积的？\n  实时一致性，最终一致性是什么？什么场景下用那种，如何实现的？\n  实时一致性:\n微服务中，场景用户使用积分兑换优惠券，积分service先扣除积分，优惠券service再进行发券动作，如果网络问题，积分扣成功了，但是优惠券发失败了。用户会投诉，必须要证优惠券和积分要在同一个分布式事务中.\n解决方案：市面上的分布式事务，阿里的seata\n  最终一致性:\n微服务中，用户选择商品下单，商品service进行库存扣件，订单service生成订单，交易service生成交易订单。如果网络原因导致，交易service生成交易订单失败了。并没有影响，只需要通过措施重新弥补交易service去生成交易订单即可。\n解决方法：mq，通过mq的重试机制以及持久化等特性，每一个微服务与下游微服务进行交互动作都是通过mq的消息。保证消息能够被消费，长时间未消费可以告警。\n    消息堆积如何处理？以及产生的危害。\n  怎么保证接口幂等\n  如何评判一个服务的好坏？你是如何进行压测的？查看了哪些指标\n  对象存储，文件存储，块存储。区别\n  服务器卡了，字都快打不动了，咋回事，怎么排查\n  用过mysql行锁吗\n用过，在一些比较简单的微服务场景，或者无法使用其他中间件的前提下。如果需要部署多节点的话，最方便的分布式锁就是mysql，因为我们的db库基本都是单节点的mysql或者mariadb。使用起来其实很简单，就是一个update语句，更新version字段。也就是所谓的乐观锁。开启一个事务，先select锁，然后尝试更新锁，在没完成业务的之前是不提交锁的，所以，其他线程会在获取锁的时候就停下来。因为update，delete，insert默认都是带for update，即行锁的。当然select不会阻塞，除非主动的设置for update。这样就是最基础的一个分布式锁了。切记锁字段必须要有索引，否则锁整个表。就G了\n  netty玩过吗，玩过哪些东西，能干啥\n  你看过一个springboot的启动内存吗？大吗？为啥这么大，怎么瘦身呢，为什么一个go就只要几十M\n  activity7了解过吗\n  规则引擎了解了解？\n  git cherry-pick是啥\n  你们平时是如何开发的，用jira，说说jira的几个问题类型，epic，之类的。\n  大量sql都超过了200ms。怎么排查\n  你写了一个服务，怎么压测的？怎么得到qps,qps的计算公式\n  为什么main线程执行结束了，jvm虚拟机还不退出。\njvm退出的条件是，当前虚拟机中只存在守护线程了，只要存活非守护线程，则jvm不会退出直到线程执行完毕。所以，如果你用了一个有多线程功能的包，但是测试的时候，main线程结束的，整个jvm都退出了，原因就是这个包，创建线程的时候是守护线程。当然main线程是不可以设为守护线程的。\n  字典树有什么场景可以使用？\n  amd64,arm64,x86_64,aarch,都是啥\n  背压理解吗，微服务中下游服务扛不住并发会崩了。有实战过吗\n场景：A服务调用B服务某个接口。耗时，并且需要资源巨大的接口。B不一定是你自己的微服务，可能是别人提供的部署在公网环境的服务。客户端通过A接口调用B，现在要求B不能崩，而且A的接口需要全部请求下来，不能丢，可以异步。 方案：mq\n  GRPC是什么，用过吗\n  脑裂\n  rabbitmq怎么保证顺序消费\n  laas、paas、saas\nIaaS（Infrastructure as a Service，基础架构即服务）是基础层。\n在这一层，通过虚拟化、动态化将IT基础资源（计算、网络、存储）聚合形成资源池。\n资源池即计算能力的集合，终端用户（企业）可以通过网络获得自己需要的计算资源，运行自己的业务系统。\n这种方式使用户不必自己建设这些基础设施，而是通过付费即可使用这些资源。\n在IaaS层之上的是PaaS（Platform as a Service，平台即服务）层。\n这一层除了提供基础计算能力，还具备了业务的开发运行环境，提供包括应用代码、SDK、操作系统以及API在内的IT组件，供个人开发者和企业将相应功能模块嵌入软件或硬件，以提高开发效率。\n对于企业或终端用户而言，这一层的服务可以为业务创新提供快速、低成本的环境。\n最上层是SaaS（Software as a Service，软件即服务）。\n实际上，SaaS在云计算概念出现之前就已经存在，并随着云计算技术的发展得到了更好的发展。\nSaaS的软件是**“拿来即用”**的，不需要用户安装，软件升级与维护也无须终端用户参与。\n同时，它还是按需使用的软件，与传统软件购买后就无法退货相较具有无可比拟的优势。\n  k8s为什么要有pod这一层概念\n  tcp协议和upd协议的区别，各自的特性，怎么实现的，例如tcp的顺序是如何保证的\n  redis是如何做高可用的\n  什么是ACID，redis的事务怎么保证\n  mysql是怎么实现可重复度的，又是怎么解决幻读的\n  什么是xss攻击，如何避免\n  ddos怎么避免\n  redis的数据结构，你用过哪些\n  怎么限流\n  hashmap的实现，红黑树变链表，等操作具体\n  jvm你能说出多少，生产上遇到过什么问题吗？怎么排查的\n  http1.0，http1.1，http2.0的区别，https的交互流程\n  什么是长链接，http的keepAlive和tcp的keepAlive区别？\n  rpc是什么，你用过什么rpc框架，他们有什么区别。thrift，gprc？\n  聊聊设计模式。\n  new一个对象，jvm里面做了哪些事情\n  voliate关键字\n  java锁相关知识\n  class是如何加载的；\n  对jvm的了解，参数的相关设置，如何调优；\n  内存突然达到100%，再脱离查看日志的情况下，如何定位系统的问题，快速找到相应代码问题；\n  线程的执行过程，线程是如何判定死亡的，如何回收的；\n  线程池的种类有多少种，相关参数的了解；\n  mysql索引的实现原理，建立索引的原则，对排序的认识；\n  动态sql的了解，对#和$的了解，有什么区别，为什么#会防止sql注入，是如何实现的；\n  mybatis的实现原理，sql如何执行的，执行器有多少种；\n  对集合的了解，如何考虑线程安全问题；\n  谈谈对设计模式的了解；\n  过滤器采用了什么设计模式；\n  数据消费如何保证数据顺序，非rabbitmq，kafka如何保证顺序；\n  接口设计如何确保安全，谈谈对api安全设计；\n  redis不采用集群模式下，如何考虑单点问题；\n  redis乐观锁的实现，调用什么方法；\n  redis的数据格式有多少种，常用方法有\n  如何处理依赖冲突\n  nginx权重策略有多少种，分配权重使用什么模块\n  多台服务下如何指定相应请求只会请求到固定服务\n  nginx限流如何实现的\n  springboot如何如何控制加载不同环境的配置的\n  常用依赖注入用什么注解；\n  spring容器有多少种；\n  工厂模式产出物是什么；\n  mysql有哪些情况是不走索引的；\n  msql为什么通配符不走索引？怎么使用才走索引？\n通配符即%，\n正确用法是WHERE Title LIKE ‘cake%';不能是WHERE Title LIKE ‘%cake%';\n如果我非要%cake%查询呢，怎么做？\n  分散性大的数据建索引还是小的？\n大的，如果是小的，你想一下索引的数据结构。B+tree，\n  graphql知道是啥吗\n  一个类是怎么加载进jvm的\n同样的问题，.java文件是怎么加载进jvm的？\n.java文件通过4个步骤\n  编译\n将.java源文件,编译成JVM可以解释的class文件, 编译过程包括语法分析,语义分析,注解处理. 然后才生成字节码文件(.class文件). 我们常用的lombok就是在这个环节生成字节码文件的.\n  加载\n  解释\n  执行\n    gc的回收过程\n  jvm的各个区作用\n  你平时用@Autowired还是构造方法注入bean，有什么区别\n都可以使用, 但是构造方法比属性注入来说又一下几个好处,而官方也更推荐用构造函数注入\n 使用构造函数能够清晰表明,当前这个bean的依赖关系,更好的排查. 当在config类下注入bean的时候,是没有办法丢是构造参数的 所有的依赖可以写成final, 这提高了程序的健壮性并且线程安全.  提问final修饰有什么不一样的? 在多线程的情况下如果不通过其他例如Synchronized或者Volatile的方式, 一个线程创建的对象,另一个线程来看的话可能是不可用,或者看不到的, 主要原因是语意重排了.   你不需要反射去创建这些依赖了,可以直接通过构造函数创建.    为什么spring还要prototype?\n 首先使用prototype的常用方式是注解@scope, value是”prototype“. 我们用spring 的目的是什么? 使用spring 提供的AOP和IOC功能, 那这个前提就必须是你的bean得是spring托管的, 因此当我们使用多例的时候,如果直接new关键字, 那就不能走spring了, 那你的@autowired注解就都实效了 我们一个java项目不可能全部都是单例的bean, 我之前做过需要动态创建task任务, 内部需要引用到redistemplate或者其他Spring容器里的bean, 我如果用new关键字, 我得一个一个传, 那不就是手写了. 所以spring提供了prototype就是为了让我们需要创建多例bean的时候,依然可以使用到spring的整个功能.    讲一下java的注解\n注解实际上是对代码的一种标记. 我们最常用的Spring框架里就包含很多注解,例如@Autowired,@Controller等. 而Java原生的注解有@Overried,@Deprecated,@FunctionalInterface. 这些原生注解多用于检查和标记.\nJava还提供给了元注解.@Retention,@Target,@Retention注解可以简单理解为设置注解的生命周期，而**@Target**表示这个注解可以修饰哪些地方（比如方法、还是成员变量、还是包等等）\n@Retention可以有SOURCE,CLASS和RUNNTIME3的枚举可选,而我们常用的lombok提供的各种注解,都是SOURCE\n SOURCE代表注解仅保留在源码级别,并由编译器忽略. CLASS代表着注解在编译时保留,但是在JVM中会忽略, 而 RUNNTIME就是标记注解由JVM保留,所以我们能在运行时通过反射获取到它,如果我们想要在编译期间处理相关逻辑的话,就得继承AbstractProcessor,而Lombok就是实现了他自己的AnnotationProcessor,这里可以看到内部的逻辑\n 这也就是为什么我们写一个@Data就能够有set/get方法了.而平时我们,用的最多的就是RUNNTIME的注解,配合上SpringAOP,可以做很多事情,例如日志的采集,异常的处理等等\n  说一下HashMap吧\n首先HashMap采用的是key/value的结构,通过一个key获取一个value的时候,时间复杂度可以达到O(1),赋值的时候也是一样快,但是它是不安全的,且是无序的.\n 为什么是无序呢?\nHashMap中元素的遍历是按照从数组起始位置开始,首先将当前bucket下的所有元素遍历完成,然后到下一个bucket,bucket与bucket之间如果为空就跳到下一个bucket,直到将所有的元素遍历出来.显而易见,元素插入的位置并不是这样的顺序,因此才说HashMap是无序的\n HashMap中,采用的的数据结构是数组+链表+红黑树,插入的一个逻辑是,算出Key的hash值,在数组中找到hash值对应的位置,这个位置称为桶,如果这个位置有数据了,则通过链表的方式链接在这个数据之后.当单个桶链表的长度大于等于8个并且桶的数量大于64的时候,会进化成红黑树.当红黑树的个数小于等于6的时候,则退化为链表.\n 数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数，所以当元素数量非常多的时候，转化为红黑树能极大地提高效率。\n 至于为什么6退化,而8进化,我也不是很清楚….\n  说一下java的泛型\n泛型其实就是在创建对象或者调用方法的时候,才会具体明确具体的类型,具体到代码里就是不需要强制转换,代码更加简洁. 程序会更加健壮,在编译器没有警告,运行的时候就不会出现ClassCastException的异常了\n平时也有用过,最常见的Spring的JPA,或者Mybatis Plus里也有BaseMapper. 平时自己写的时候,用到泛型离不开反射(能在运行时获取信息),一般都会通过反射去判断类型,获取属性值,再进行业务逻辑操作的\n  不和你多逼逼,先说说各种IO吧\n  gc说说吧,CMS是什么\n首先说下CMS,CMS是一种GC算法,全称是Concurrent-Mark-Sweep.是我们最常用的垃圾回收算法\n CMS 是一种基于并发、使用标记清除算法的垃圾回收器。CMS 会尽可能让 GC 线程与用户线程并发执行，可以消除长时间的 GC 停顿（STW）。\n   你能写出多少种排序算法?二分写下吧\n 冒泡    TCP和UDP?\n  UDP\n  UDP首先他不是面向连接的, 因此他不需要像TCP一样需要通过三次握手建立连接, 想发数据就直接发了, 并不关心对方是否收到, 也不关心是否完整.UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。\n   首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。\n并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。\n再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。\n   UDP是面向报文的, 发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文\n  UDP 头部包含了以下几个数据：\n 两个十六位的端口号，分别为源端口（可选字段）和目标端口 整个数据报文的长度 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误  因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的\n    TCP\n  面向连接\n面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。\n  仅支持单播传输\n  每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。\n 面向字节流  TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。\n  可靠传输\n对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。\n  提供拥塞控制\n  当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞\n TCP提供全双工通信  TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）\n    再说一次三次握手吧\n3次握手\n client向server发送报文,tcp的报文头固定20字节中的, 标识位会设置为SYN, 发送完毕后client会进入 SYN-SENT状态, 等待一个ACK的报文, 这是第一次握手 server收到SYN后, 发送SYN+ACK给client, server进入SYN-RECEIVED状态, 这是第二次握手 client接收到server发送的SYN+ACK的时候,发送ACK确认收到, 进入ESTABLISHED状态, 这是第三次握手 server接收到ACK, 进入 ESTABLSHED状态. 三次握手结束  为什么一定是3次,不能2次吗,如果是2次,没有第三次client发给server的话,也许第二次握手完,server就进入established状态,但是此时客户端可能连接失效了,是为了防止失效的报文也被server接收导致错误.\n4次挥手\n client向server发送报文,标识位为FIN, 表示要关闭连接, 这是第一次挥手 server收到FIN, 进入CLOSE_AWAIT状态, 不再接受client的数据, 但此时client依然可以继续发送, 并且发送ACK给Client.这是第二次挥手 如果server还有没发送完的数据,会继续发送,最后发送FIN给client, 进入 last_ack状态这是第三次挥手 client收到FIN后, 会进入time-wait状态, 等待2MSL, 如果这个时间内 server没有再发送请求, 就进入close状态,并且发送ACK到server, server接收到ack也进入close, 这是第四次挥手    NIO是什么,JavaNIO又有什么区别,写点demo吧\n  map与flatMap的区别\nmap会作用于整个stream的序列上, flatMap会避免出现嵌套式的stream, 扁平化处理, 相当于不破坏最外层的结构, 给内部的每个元素再一次 stream的机会. 达到avoid nested stream structure\n  java1.8 11 区别，你平时了解java新版本的特性吗？协程知道么\n  mysql为什么一定要有聚簇索引呢\n  ","wordCount":"313","inLanguage":"en","datePublished":"2022-01-11T14:43:18+08:00","dateModified":"2022-01-11T14:43:18+08:00","author":{"@type":"Person","name":"Hao Sun"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sunhao1256.github.io/posts/%E5%B9%B3%E6%97%B6%E7%96%91%E9%97%AE/"},"publisher":{"@type":"Organization","name":"Hao Sun","logo":{"@type":"ImageObject","url":"https://sunhao1256.github.io/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://sunhao1256.github.io/ accesskey=h title="Hao Sun (Alt + H)">Hao Sun</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://sunhao1256.github.io/archives/ title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://sunhao1256.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
<li>
<a href=https://sunhao1256.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://sunhao1256.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://sunhao1256.github.io/posts/>Posts</a></div>
<h1 class=post-title>
平时疑问
</h1>
<div class=post-meta><span title="2022-01-11 14:43:18 +0800 CST">January 11, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Hao Sun
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e5%b9%b3%e6%97%b6%e7%96%91%e9%97%ae aria-label=平时疑问>平时疑问</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=平时疑问>平时疑问<a hidden class=anchor aria-hidden=true href=#平时疑问>#</a></h1>
<ul>
<li>
<p>浏览器输入一个地址，整个流程</p>
</li>
<li>
<p>如果线上流量暴增，全都打到一个 upstream 上了，怎么排查</p>
</li>
<li>
<p>如何在 nginx 的 access log 中查出请求前 10 的 ip</p>
</li>
<li>
<p>台阶问题，假如对于上台阶，可以一次上一阶，也可以一次上两阶，写一个方法，实现输入台阶数，输出可以有多少种上法。</p>
</li>
<li>
<p>广度优先和深度优先</p>
</li>
<li>
<p>spring reactive，响应式聊下，什么时候适合用？背压是什么东西，backpress</p>
</li>
<li>
<p>压缩算法，怎么就“压缩”了？如何减少体积的？</p>
</li>
<li>
<p>实时一致性，最终一致性是什么？什么场景下用那种，如何实现的？</p>
<ul>
<li>
<p>实时一致性:</p>
<p>微服务中，场景用户使用积分兑换优惠券，积分service先扣除积分，优惠券service再进行发券动作，如果网络问题，积分扣成功了，但是优惠券发失败了。用户会投诉，必须要证优惠券和积分要在同一个分布式事务中.</p>
<p>解决方案：市面上的分布式事务，阿里的seata</p>
</li>
<li>
<p>最终一致性:</p>
<p>微服务中，用户选择商品下单，商品service进行库存扣件，订单service生成订单，交易service生成交易订单。如果网络原因导致，交易service生成交易订单失败了。并没有影响，只需要通过措施重新弥补交易service去生成交易订单即可。</p>
<p>解决方法：mq，通过mq的重试机制以及持久化等特性，每一个微服务与下游微服务进行交互动作都是通过mq的消息。保证消息能够被消费，长时间未消费可以告警。</p>
</li>
</ul>
</li>
<li>
<p>消息堆积如何处理？以及产生的危害。</p>
</li>
<li>
<p>怎么保证接口幂等</p>
</li>
<li>
<p>如何评判一个服务的好坏？你是如何进行压测的？查看了哪些指标</p>
</li>
<li>
<p>对象存储，文件存储，块存储。区别</p>
</li>
<li>
<p>服务器卡了，字都快打不动了，咋回事，怎么排查</p>
</li>
<li>
<p>用过mysql行锁吗</p>
<p>用过，在一些比较简单的微服务场景，或者无法使用其他中间件的前提下。如果需要部署多节点的话，最方便的分布式锁就是mysql，因为我们的db库基本都是单节点的mysql或者mariadb。使用起来其实很简单，就是一个update语句，更新version字段。也就是所谓的乐观锁。开启一个事务，先select锁，然后尝试更新锁，在没完成业务的之前是不提交锁的，所以，其他线程会在获取锁的时候就停下来。因为update，delete，insert默认都是带for update，即行锁的。当然select不会阻塞，除非主动的设置for update。这样就是最基础的一个分布式锁了。切记锁字段必须要有索引，否则锁整个表。就G了</p>
</li>
<li>
<p>netty玩过吗，玩过哪些东西，能干啥</p>
</li>
<li>
<p>你看过一个springboot的启动内存吗？大吗？为啥这么大，怎么瘦身呢，为什么一个go就只要几十M</p>
</li>
<li>
<p>activity7了解过吗</p>
</li>
<li>
<p>规则引擎了解了解？</p>
</li>
<li>
<p>git cherry-pick是啥</p>
</li>
<li>
<p>你们平时是如何开发的，用jira，说说jira的几个问题类型，epic，之类的。</p>
</li>
<li>
<p>大量sql都超过了200ms。怎么排查</p>
</li>
<li>
<p>你写了一个服务，怎么压测的？怎么得到qps,qps的计算公式</p>
</li>
<li>
<p>为什么main线程执行结束了，jvm虚拟机还不退出。</p>
<p>jvm退出的条件是，当前虚拟机中只存在守护线程了，只要存活非守护线程，则jvm不会退出直到线程执行完毕。所以，如果你用了一个有多线程功能的包，但是测试的时候，main线程结束的，整个jvm都退出了，原因就是这个包，创建线程的时候是守护线程。当然main线程是不可以设为守护线程的。</p>
</li>
<li>
<p>字典树有什么场景可以使用？</p>
</li>
<li>
<p>amd64,arm64,x86_64,aarch,都是啥</p>
</li>
<li>
<p>背压理解吗，微服务中下游服务扛不住并发会崩了。有实战过吗</p>
<p>场景：A服务调用B服务某个接口。耗时，并且需要资源巨大的接口。B不一定是你自己的微服务，可能是别人提供的部署在公网环境的服务。客户端通过A接口调用B，现在要求B不能崩，而且A的接口需要全部请求下来，不能丢，可以异步。
方案：mq</p>
</li>
<li>
<p>GRPC是什么，用过吗</p>
</li>
<li>
<p>脑裂</p>
</li>
<li>
<p>rabbitmq怎么保证顺序消费</p>
</li>
<li>
<p>laas、paas、saas</p>
<p><strong>IaaS（Infrastructure as a Service，基础架构即服务）是基础层。</strong></p>
<p>在这一层，通过虚拟化、动态化将IT基础资源（计算、网络、存储）聚合形成资源池。</p>
<p>资源池即计算能力的集合，终端用户（企业）可以通过网络获得自己需要的计算资源，运行自己的业务系统。</p>
<p>这种方式使用户不必自己建设这些基础设施，而是通过付费即可使用这些资源。</p>
<p><strong>在IaaS层之上的是PaaS（Platform as a Service，平台即服务）层。</strong></p>
<p>这一层除了提供基础计算能力，还具备了业务的开发运行环境，提供包括应用代码、SDK、操作系统以及API在内的IT组件，供个人开发者和企业将相应功能模块嵌入软件或硬件，以提高开发效率。</p>
<p>对于企业或终端用户而言，这一层的服务可以为业务创新提供快速、低成本的环境。</p>
<p><strong>最上层是SaaS（Software as a Service，软件即服务）。</strong></p>
<p>实际上，SaaS在云计算概念出现之前就已经存在，并随着云计算技术的发展得到了更好的发展。</p>
<p>SaaS的软件是**“拿来即用”**的，不需要用户安装，软件升级与维护也无须终端用户参与。</p>
<p>同时，它还是按需使用的软件，与传统软件购买后就无法退货相较具有无可比拟的优势。</p>
</li>
<li>
<p>k8s为什么要有pod这一层概念</p>
</li>
<li>
<p>tcp协议和upd协议的区别，各自的特性，怎么实现的，例如tcp的顺序是如何保证的</p>
</li>
<li>
<p>redis是如何做高可用的</p>
</li>
<li>
<p>什么是ACID，redis的事务怎么保证</p>
</li>
<li>
<p>mysql是怎么实现可重复度的，又是怎么解决幻读的</p>
</li>
<li>
<p>什么是xss攻击，如何避免</p>
</li>
<li>
<p>ddos怎么避免</p>
</li>
<li>
<p>redis的数据结构，你用过哪些</p>
</li>
<li>
<p>怎么限流</p>
</li>
<li>
<p>hashmap的实现，红黑树变链表，等操作具体</p>
</li>
<li>
<p>jvm你能说出多少，生产上遇到过什么问题吗？怎么排查的</p>
</li>
<li>
<p>http1.0，http1.1，http2.0的区别，https的交互流程</p>
</li>
<li>
<p>什么是长链接，http的keepAlive和tcp的keepAlive区别？</p>
</li>
<li>
<p>rpc是什么，你用过什么rpc框架，他们有什么区别。thrift，gprc？</p>
</li>
<li>
<p>聊聊设计模式。</p>
</li>
<li>
<p>new一个对象，jvm里面做了哪些事情</p>
</li>
<li>
<p>voliate关键字</p>
</li>
<li>
<p>java锁相关知识</p>
</li>
<li>
<p>class是如何加载的；</p>
</li>
<li>
<p>对jvm的了解，参数的相关设置，如何调优；</p>
</li>
<li>
<p>内存突然达到100%，再脱离查看日志的情况下，如何定位系统的问题，快速找到相应代码问题；</p>
</li>
<li>
<p>线程的执行过程，线程是如何判定死亡的，如何回收的；</p>
</li>
<li>
<p>线程池的种类有多少种，相关参数的了解；</p>
</li>
<li>
<p>mysql索引的实现原理，建立索引的原则，对排序的认识；</p>
</li>
<li>
<p>动态sql的了解，对#和$的了解，有什么区别，为什么#会防止sql注入，是如何实现的；</p>
</li>
<li>
<p>mybatis的实现原理，sql如何执行的，执行器有多少种；</p>
</li>
<li>
<p>对集合的了解，如何考虑线程安全问题；</p>
</li>
<li>
<p>谈谈对设计模式的了解；</p>
</li>
<li>
<p>过滤器采用了什么设计模式；</p>
</li>
<li>
<p>数据消费如何保证数据顺序，非rabbitmq，kafka如何保证顺序；</p>
</li>
<li>
<p>接口设计如何确保安全，谈谈对api安全设计；</p>
</li>
<li>
<p>redis不采用集群模式下，如何考虑单点问题；</p>
</li>
<li>
<p>redis乐观锁的实现，调用什么方法；</p>
</li>
<li>
<p>redis的数据格式有多少种，常用方法有</p>
</li>
<li>
<p>如何处理依赖冲突</p>
</li>
<li>
<p>nginx权重策略有多少种，分配权重使用什么模块</p>
</li>
<li>
<p>多台服务下如何指定相应请求只会请求到固定服务</p>
</li>
<li>
<p>nginx限流如何实现的</p>
</li>
<li>
<p>springboot如何如何控制加载不同环境的配置的</p>
</li>
<li>
<p>常用依赖注入用什么注解；</p>
</li>
<li>
<p>spring容器有多少种；</p>
</li>
<li>
<p>工厂模式产出物是什么；</p>
</li>
<li>
<p>mysql有哪些情况是不走索引的；</p>
</li>
<li>
<p>msql为什么通配符不走索引？怎么使用才走索引？</p>
<p>通配符即%，</p>
<p>正确用法是WHERE Title LIKE &lsquo;cake%';不能是WHERE Title LIKE &lsquo;%cake%';</p>
<p>如果我非要%cake%查询呢，怎么做？</p>
</li>
<li>
<p>分散性大的数据建索引还是小的？</p>
<p>大的，如果是小的，你想一下索引的数据结构。B+tree，</p>
</li>
<li>
<p>graphql知道是啥吗</p>
</li>
<li>
<p>一个类是怎么加载进jvm的</p>
<p>同样的问题，.java文件是怎么加载进jvm的？</p>
<p>.java文件通过4个步骤</p>
<ol>
<li>
<p>编译</p>
<p>将.java源文件,编译成JVM可以解释的class文件, 编译过程包括语法分析,语义分析,注解处理. 然后才生成字节码文件(.class文件). 我们常用的lombok就是在这个环节生成字节码文件的.</p>
</li>
<li>
<p>加载</p>
</li>
<li>
<p>解释</p>
</li>
<li>
<p>执行</p>
</li>
</ol>
</li>
<li>
<p>gc的回收过程</p>
</li>
<li>
<p>jvm的各个区作用</p>
</li>
<li>
<p>你平时用@Autowired还是构造方法注入bean，有什么区别</p>
<p>都可以使用, 但是构造方法比属性注入来说又一下几个好处,而官方也更推荐用构造函数注入</p>
<ul>
<li>使用构造函数能够清晰表明,当前这个bean的依赖关系,更好的排查. 当在config类下注入bean的时候,是没有办法丢是构造参数的</li>
<li>所有的依赖可以写成final, 这提高了程序的健壮性并且线程安全.
<ul>
<li>提问final修饰有什么不一样的? 在多线程的情况下如果不通过其他例如Synchronized或者Volatile的方式, 一个线程创建的对象,另一个线程来看的话可能是不可用,或者看不到的, 主要原因是语意重排了.</li>
</ul>
</li>
<li>你不需要反射去创建这些依赖了,可以直接通过构造函数创建.</li>
</ul>
</li>
<li>
<p>为什么spring还要prototype?</p>
<ol>
<li>首先使用prototype的常用方式是注解@scope, value是”prototype“.</li>
<li>我们用spring 的目的是什么? 使用spring 提供的AOP和IOC功能, 那这个前提就必须是你的bean得是spring托管的, 因此当我们使用多例的时候,如果直接new关键字, 那就不能走spring了, 那你的@autowired注解就都实效了</li>
<li>我们一个java项目不可能全部都是单例的bean, 我之前做过需要动态创建task任务, 内部需要引用到redistemplate或者其他Spring容器里的bean, 我如果用new关键字, 我得一个一个传, 那不就是手写了. 所以spring提供了prototype就是为了让我们需要创建多例bean的时候,依然可以使用到spring的整个功能.</li>
</ol>
</li>
<li>
<p>讲一下java的注解</p>
<p>注解实际上是对代码的一种标记. 我们最常用的Spring框架里就包含很多注解,例如@Autowired,@Controller等. 而Java原生的注解有@Overried,@Deprecated,@FunctionalInterface. 这些原生注解多用于检查和标记.</p>
<p>Java还提供给了元注解.@Retention,@Target,<strong>@Retention</strong>注解可以简单理解为设置注解的生命周期，而**@Target**表示这个注解可以修饰哪些地方（比如方法、还是成员变量、还是包等等）</p>
<p>@Retention可以有SOURCE,CLASS和RUNNTIME3的枚举可选,而我们常用的lombok提供的各种注解,都是SOURCE</p>
<blockquote>
<p>SOURCE代表注解仅保留在源码级别,并由编译器忽略. CLASS代表着注解在编译时保留,但是在JVM中会忽略, 而 RUNNTIME就是标记注解由JVM保留,所以我们能在运行时通过反射获取到它,如果我们想要在编译期间处理相关逻辑的话,就得继承AbstractProcessor,而Lombok就是实现了他自己的AnnotationProcessor,这里可以看到内部的逻辑</p>
</blockquote>
<p>这也就是为什么我们写一个@Data就能够有set/get方法了.而平时我们,用的最多的就是RUNNTIME的注解,配合上SpringAOP,可以做很多事情,例如日志的采集,异常的处理等等</p>
</li>
<li>
<p>说一下HashMap吧</p>
<p>首先HashMap采用的是key/value的结构,通过一个key获取一个value的时候,时间复杂度可以达到O(1),赋值的时候也是一样快,但是它是不安全的,且是无序的.</p>
<blockquote>
<p>为什么是无序呢?</p>
<p>HashMap中元素的遍历是按照从数组起始位置开始,首先将当前bucket下的所有元素遍历完成,然后到下一个bucket,bucket与bucket之间如果为空就跳到下一个bucket,直到将所有的元素遍历出来.显而易见,元素插入的位置并不是这样的顺序,因此才说HashMap是无序的</p>
</blockquote>
<p>HashMap中,采用的的数据结构是<strong>数组+链表+红黑树</strong>,插入的一个逻辑是,算出Key的hash值,在数组中找到hash值对应的位置,这个位置称为桶,如果这个位置有数据了,则通过链表的方式链接在这个数据之后.当单个桶链表的长度大于等于8个并且桶的数量大于64的时候,会进化成红黑树.当红黑树的个数小于等于6的时候,则退化为链表.</p>
<blockquote>
<p>数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数，所以当元素数量非常多的时候，转化为红黑树能极大地提高效率。</p>
</blockquote>
<p>至于为什么6退化,而8进化,我也不是很清楚&mldr;.</p>
</li>
<li>
<p>说一下java的泛型</p>
<p>泛型其实就是在创建对象或者调用方法的时候,才会具体明确具体的类型,具体到代码里就是不需要强制转换,代码更加简洁. 程序会更加健壮,在编译器没有警告,运行的时候就不会出现ClassCastException的异常了</p>
<p>平时也有用过,最常见的Spring的JPA,或者Mybatis Plus里也有BaseMapper. 平时自己写的时候,用到泛型离不开反射(能在运行时获取信息),一般都会通过反射去判断类型,获取属性值,再进行业务逻辑操作的</p>
</li>
<li>
<p>不和你多逼逼,先说说各种IO吧</p>
</li>
<li>
<p>gc说说吧,CMS是什么</p>
<p>首先说下CMS,CMS是一种GC算法,全称是Concurrent-Mark-Sweep.是我们最常用的垃圾回收算法</p>
<blockquote>
<p>CMS 是一种基于并发、使用标记清除算法的垃圾回收器。CMS 会尽可能让 GC 线程与用户线程并发执行，可以消除长时间的 GC 停顿（STW）。</p>
</blockquote>
</li>
<li>
<p>你能写出多少种排序算法?二分写下吧</p>
<ul>
<li>冒泡</li>
</ul>
</li>
<li>
<p>TCP和UDP?</p>
<ul>
<li>
<p>UDP</p>
<ol>
<li>
<p>UDP首先他不是面向连接的, 因此他不需要像TCP一样需要通过三次握手建立连接, 想发数据就直接发了, 并不关心对方是否收到, 也不关心是否完整.UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>
</li>
<li>
<blockquote>
<p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p>
<p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p>
<p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>
</blockquote>
</li>
<li>
<p>UDP是面向报文的, 发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p>
</li>
<li>
<p><img loading=lazy src=https://image.fundebug.com/2019-03-21-03.png alt>
</p>
<p>UDP 头部包含了以下几个数据：</p>
<ul>
<li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li>
<li>整个数据报文的长度</li>
<li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li>
</ul>
<p>因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的</p>
</li>
</ol>
</li>
<li>
<p>TCP</p>
<ul>
<li>
<p>面向连接</p>
<p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p>
</li>
<li>
<p>仅支持单播传输</p>
</li>
</ul>
<p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p>
<ul>
<li>面向字节流</li>
</ul>
<p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p>
<ul>
<li>
<p>可靠传输</p>
<p>对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p>
</li>
<li>
<p>提供拥塞控制</p>
</li>
</ul>
<p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</p>
<ul>
<li>TCP提供全双工通信</li>
</ul>
<p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p>
</li>
</ul>
</li>
<li>
<p>再说一次三次握手吧</p>
<p><img loading=lazy src=https://image.fundebug.com/2019-03-21-04.png alt>
</p>
<p>3次握手</p>
<ol>
<li>client向server发送报文,tcp的报文头固定20字节中的, 标识位会设置为SYN, 发送完毕后client会进入 SYN-SENT状态, 等待一个ACK的报文, 这是第一次握手</li>
<li>server收到SYN后, 发送SYN+ACK给client, server进入SYN-RECEIVED状态, 这是第二次握手</li>
<li>client接收到server发送的SYN+ACK的时候,发送ACK确认收到, 进入ESTABLISHED状态, 这是第三次握手</li>
<li>server接收到ACK, 进入 ESTABLSHED状态. 三次握手结束</li>
</ol>
<p><strong>为什么一定是3次,不能2次吗</strong>,如果是2次,没有第三次client发给server的话,也许第二次握手完,server就进入established状态,但是此时客户端可能连接失效了,是为了防止失效的报文也被server接收导致错误.</p>
<p>4次挥手</p>
<ol>
<li>client向server发送报文,标识位为FIN, 表示要关闭连接, 这是第一次挥手</li>
<li>server收到FIN, 进入CLOSE_AWAIT状态, 不再接受client的数据, 但此时client依然可以继续发送, 并且发送ACK给Client.这是第二次挥手</li>
<li>如果server还有没发送完的数据,会继续发送,最后发送FIN给client, 进入 last_ack状态这是第三次挥手</li>
<li>client收到FIN后, 会进入time-wait状态, 等待2MSL, 如果这个时间内 server没有再发送请求, 就进入close状态,并且发送ACK到server, server接收到ack也进入close, 这是第四次挥手</li>
</ol>
</li>
<li>
<p>NIO是什么,JavaNIO又有什么区别,写点demo吧</p>
</li>
<li>
<p>map与flatMap的区别</p>
<p>map会作用于整个stream的序列上, flatMap会避免出现嵌套式的stream&lt;stream>, 扁平化处理, 相当于不破坏最外层的结构, 给内部的每个元素再一次 stream的机会. 达到avoid nested stream structure</p>
</li>
<li>
<p>java1.8 11 区别，你平时了解java新版本的特性吗？协程知道么</p>
</li>
<li>
<p>mysql为什么一定要有聚簇索引呢</p>
</li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://sunhao1256.github.io/tags/%E8%87%AA%E9%97%AE%E8%87%AA%E7%AD%94/>自问自答</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://sunhao1256.github.io/posts/%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/>
<span class=title>« Prev Page</span>
<br>
<span>八股文</span>
</a>
<a class=next href=https://sunhao1256.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>
<span class=title>Next Page »</span>
<br>
<span>数据结构</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://sunhao1256.github.io/>Hao Sun</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>