<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Reactor响应式编程 | Hao Sun</title>
<meta name=keywords content="乱七八糟">
<meta name=description content="Reactive Programming 响应式编程 为什么要响应式编程 传统的编程模式应对如今高并发，高响应的需求有很多限制。现在的web应用，越来越需要更高的并发，更快的响应。
每个请求都需要一个线程 传统的web请求，每个请求都是使用单个线程贯穿整个流程。如果我们用Spring的生态，对于的就是SpringMvc框架。基于servlet容器，例如tomcat。而tomcat内部会维护一个线程池去，每当请求来的时候，便会从池中分配一个thread来处理请求。这意味着，这个web程序的并发能力只能达到线程池的大小。当然为了提高并发能力，可以增加线程池的大小。但是在Java中一个线程的开销是昂贵的，通常是1MB的内存消耗。更大的线程池大小，则意味着更大的内存。
阻塞IO操作 IO操作，如果不做任何处理，势必会阻塞，例如查询数据库、RPC调用其他服务等。一旦发起了一个IO请求，持续等待，直到IO结束，这就是最基础的阻塞IO
响应时间 在实际的场景中，一次请求中可能有不止一个服务调用链。例如A服务除了要调用B、C服务，还需要操作一次数据库。如果什么都不做的话，意味着这次请求花费的时间是下面花费时间之和
 B服务的响应时间（网络延迟+B服务的处理时间） C服务的响应时间（网络延迟+C服务的处理时间） 数据的处理时间（网络延迟+处理时间）  如果没有业务逻辑上的顺序，如果我们在代码中并发操作的话，那么消耗的时间肯定有所减少。虽然Java提供很多方便的异步回调方法，例如CompletableFutures，但是这极大的增加了代码的复杂性。没人愿意每次都这么复杂，并且并不是每个人都会想到用异步的。
压倒客户端 微服务中可能会出现这样的场景，A服务需要调用B一些信息，例如查一个月的订单，但是这个数据非常庞大，对于A服务来说，一次性无法处理，甚至可能出现OOM导致服务A直接挂了。
小结 总结上面的一些问题能发现响应式编程能带来的好处：
 不使用一个线程处理一个请求的模式，可以使用需要更少的线程处理更多的请求 防止线程在进行IO操作的时候被阻塞 能有简洁的并发操作API 提供背压机制，backpress，防止客户端直接被压垮  什么是响应式编程  “In plain terms reactive programming is about non-blocking applications that are asynchronous and event-driven and require a small number of threads to scale. A key aspect of that definition is the concept of backpressure which is a mechanism to ensure producers don’t overwhelm consumers.">
<meta name=author content="Hao Sun">
<link rel=canonical href=https://sunhao1256.github.io/posts/reactor/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://sunhao1256.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=https://sunhao1256.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://sunhao1256.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://sunhao1256.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://sunhao1256.github.io/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.89.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="Reactor响应式编程">
<meta property="og:description" content="Reactive Programming 响应式编程 为什么要响应式编程 传统的编程模式应对如今高并发，高响应的需求有很多限制。现在的web应用，越来越需要更高的并发，更快的响应。
每个请求都需要一个线程 传统的web请求，每个请求都是使用单个线程贯穿整个流程。如果我们用Spring的生态，对于的就是SpringMvc框架。基于servlet容器，例如tomcat。而tomcat内部会维护一个线程池去，每当请求来的时候，便会从池中分配一个thread来处理请求。这意味着，这个web程序的并发能力只能达到线程池的大小。当然为了提高并发能力，可以增加线程池的大小。但是在Java中一个线程的开销是昂贵的，通常是1MB的内存消耗。更大的线程池大小，则意味着更大的内存。
阻塞IO操作 IO操作，如果不做任何处理，势必会阻塞，例如查询数据库、RPC调用其他服务等。一旦发起了一个IO请求，持续等待，直到IO结束，这就是最基础的阻塞IO
响应时间 在实际的场景中，一次请求中可能有不止一个服务调用链。例如A服务除了要调用B、C服务，还需要操作一次数据库。如果什么都不做的话，意味着这次请求花费的时间是下面花费时间之和
 B服务的响应时间（网络延迟+B服务的处理时间） C服务的响应时间（网络延迟+C服务的处理时间） 数据的处理时间（网络延迟+处理时间）  如果没有业务逻辑上的顺序，如果我们在代码中并发操作的话，那么消耗的时间肯定有所减少。虽然Java提供很多方便的异步回调方法，例如CompletableFutures，但是这极大的增加了代码的复杂性。没人愿意每次都这么复杂，并且并不是每个人都会想到用异步的。
压倒客户端 微服务中可能会出现这样的场景，A服务需要调用B一些信息，例如查一个月的订单，但是这个数据非常庞大，对于A服务来说，一次性无法处理，甚至可能出现OOM导致服务A直接挂了。
小结 总结上面的一些问题能发现响应式编程能带来的好处：
 不使用一个线程处理一个请求的模式，可以使用需要更少的线程处理更多的请求 防止线程在进行IO操作的时候被阻塞 能有简洁的并发操作API 提供背压机制，backpress，防止客户端直接被压垮  什么是响应式编程  “In plain terms reactive programming is about non-blocking applications that are asynchronous and event-driven and require a small number of threads to scale. A key aspect of that definition is the concept of backpressure which is a mechanism to ensure producers don’t overwhelm consumers.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://sunhao1256.github.io/posts/reactor/"><meta property="og:image" content="https://sunhao1256.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-01-11T14:43:18+08:00">
<meta property="article:modified_time" content="2022-01-11T14:43:18+08:00"><meta property="og:site_name" content="Hao Sun">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://sunhao1256.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name=twitter:title content="Reactor响应式编程">
<meta name=twitter:description content="Reactive Programming 响应式编程 为什么要响应式编程 传统的编程模式应对如今高并发，高响应的需求有很多限制。现在的web应用，越来越需要更高的并发，更快的响应。
每个请求都需要一个线程 传统的web请求，每个请求都是使用单个线程贯穿整个流程。如果我们用Spring的生态，对于的就是SpringMvc框架。基于servlet容器，例如tomcat。而tomcat内部会维护一个线程池去，每当请求来的时候，便会从池中分配一个thread来处理请求。这意味着，这个web程序的并发能力只能达到线程池的大小。当然为了提高并发能力，可以增加线程池的大小。但是在Java中一个线程的开销是昂贵的，通常是1MB的内存消耗。更大的线程池大小，则意味着更大的内存。
阻塞IO操作 IO操作，如果不做任何处理，势必会阻塞，例如查询数据库、RPC调用其他服务等。一旦发起了一个IO请求，持续等待，直到IO结束，这就是最基础的阻塞IO
响应时间 在实际的场景中，一次请求中可能有不止一个服务调用链。例如A服务除了要调用B、C服务，还需要操作一次数据库。如果什么都不做的话，意味着这次请求花费的时间是下面花费时间之和
 B服务的响应时间（网络延迟+B服务的处理时间） C服务的响应时间（网络延迟+C服务的处理时间） 数据的处理时间（网络延迟+处理时间）  如果没有业务逻辑上的顺序，如果我们在代码中并发操作的话，那么消耗的时间肯定有所减少。虽然Java提供很多方便的异步回调方法，例如CompletableFutures，但是这极大的增加了代码的复杂性。没人愿意每次都这么复杂，并且并不是每个人都会想到用异步的。
压倒客户端 微服务中可能会出现这样的场景，A服务需要调用B一些信息，例如查一个月的订单，但是这个数据非常庞大，对于A服务来说，一次性无法处理，甚至可能出现OOM导致服务A直接挂了。
小结 总结上面的一些问题能发现响应式编程能带来的好处：
 不使用一个线程处理一个请求的模式，可以使用需要更少的线程处理更多的请求 防止线程在进行IO操作的时候被阻塞 能有简洁的并发操作API 提供背压机制，backpress，防止客户端直接被压垮  什么是响应式编程  “In plain terms reactive programming is about non-blocking applications that are asynchronous and event-driven and require a small number of threads to scale. A key aspect of that definition is the concept of backpressure which is a mechanism to ensure producers don’t overwhelm consumers.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sunhao1256.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Reactor响应式编程","item":"https://sunhao1256.github.io/posts/reactor/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Reactor响应式编程","name":"Reactor响应式编程","description":"Reactive Programming 响应式编程 为什么要响应式编程 传统的编程模式应对如今高并发，高响应的需求有很多限制。现在的web应用，越来越需要更高的并发，更快的响应。\n每个请求都需要一个线程 传统的web请求，每个请求都是使用单个线程贯穿整个流程。如果我们用Spring的生态，对于的就是SpringMvc框架。基于servlet容器，例如tomcat。而tomcat内部会维护一个线程池去，每当请求来的时候，便会从池中分配一个thread来处理请求。这意味着，这个web程序的并发能力只能达到线程池的大小。当然为了提高并发能力，可以增加线程池的大小。但是在Java中一个线程的开销是昂贵的，通常是1MB的内存消耗。更大的线程池大小，则意味着更大的内存。\n阻塞IO操作 IO操作，如果不做任何处理，势必会阻塞，例如查询数据库、RPC调用其他服务等。一旦发起了一个IO请求，持续等待，直到IO结束，这就是最基础的阻塞IO\n响应时间 在实际的场景中，一次请求中可能有不止一个服务调用链。例如A服务除了要调用B、C服务，还需要操作一次数据库。如果什么都不做的话，意味着这次请求花费的时间是下面花费时间之和\n B服务的响应时间（网络延迟+B服务的处理时间） C服务的响应时间（网络延迟+C服务的处理时间） 数据的处理时间（网络延迟+处理时间）  如果没有业务逻辑上的顺序，如果我们在代码中并发操作的话，那么消耗的时间肯定有所减少。虽然Java提供很多方便的异步回调方法，例如CompletableFutures，但是这极大的增加了代码的复杂性。没人愿意每次都这么复杂，并且并不是每个人都会想到用异步的。\n压倒客户端 微服务中可能会出现这样的场景，A服务需要调用B一些信息，例如查一个月的订单，但是这个数据非常庞大，对于A服务来说，一次性无法处理，甚至可能出现OOM导致服务A直接挂了。\n小结 总结上面的一些问题能发现响应式编程能带来的好处：\n 不使用一个线程处理一个请求的模式，可以使用需要更少的线程处理更多的请求 防止线程在进行IO操作的时候被阻塞 能有简洁的并发操作API 提供背压机制，backpress，防止客户端直接被压垮  什么是响应式编程  “In plain terms reactive programming is about non-blocking applications that are asynchronous and event-driven and require a small number of threads to scale. A key aspect of that definition is the concept of backpressure which is a mechanism to ensure producers don’t overwhelm consumers.","keywords":["乱七八糟"],"articleBody":"Reactive Programming 响应式编程 为什么要响应式编程 传统的编程模式应对如今高并发，高响应的需求有很多限制。现在的web应用，越来越需要更高的并发，更快的响应。\n每个请求都需要一个线程 传统的web请求，每个请求都是使用单个线程贯穿整个流程。如果我们用Spring的生态，对于的就是SpringMvc框架。基于servlet容器，例如tomcat。而tomcat内部会维护一个线程池去，每当请求来的时候，便会从池中分配一个thread来处理请求。这意味着，这个web程序的并发能力只能达到线程池的大小。当然为了提高并发能力，可以增加线程池的大小。但是在Java中一个线程的开销是昂贵的，通常是1MB的内存消耗。更大的线程池大小，则意味着更大的内存。\n阻塞IO操作 IO操作，如果不做任何处理，势必会阻塞，例如查询数据库、RPC调用其他服务等。一旦发起了一个IO请求，持续等待，直到IO结束，这就是最基础的阻塞IO\n响应时间 在实际的场景中，一次请求中可能有不止一个服务调用链。例如A服务除了要调用B、C服务，还需要操作一次数据库。如果什么都不做的话，意味着这次请求花费的时间是下面花费时间之和\n B服务的响应时间（网络延迟+B服务的处理时间） C服务的响应时间（网络延迟+C服务的处理时间） 数据的处理时间（网络延迟+处理时间）  如果没有业务逻辑上的顺序，如果我们在代码中并发操作的话，那么消耗的时间肯定有所减少。虽然Java提供很多方便的异步回调方法，例如CompletableFutures，但是这极大的增加了代码的复杂性。没人愿意每次都这么复杂，并且并不是每个人都会想到用异步的。\n压倒客户端 微服务中可能会出现这样的场景，A服务需要调用B一些信息，例如查一个月的订单，但是这个数据非常庞大，对于A服务来说，一次性无法处理，甚至可能出现OOM导致服务A直接挂了。\n小结 总结上面的一些问题能发现响应式编程能带来的好处：\n 不使用一个线程处理一个请求的模式，可以使用需要更少的线程处理更多的请求 防止线程在进行IO操作的时候被阻塞 能有简洁的并发操作API 提供背压机制，backpress，防止客户端直接被压垮  什么是响应式编程  “In plain terms reactive programming is about non-blocking applications that are asynchronous and event-driven and require a small number of threads to scale. A key aspect of that definition is the concept of backpressure which is a mechanism to ensure producers don’t overwhelm consumers.”\n “响应式\"是指响应围绕着变化的一种编程模型——例如网络组件随着IO事件变化、UI显示随着用户的鼠标点击而变化。从这一点上看，非阻塞就是响应式。因为不同于阻塞式，我们可以在数据准备好之后对通知进行响应，而非等待。\n如何实现 简单点说就是，通过使用异步数据进行编程。还是A服务想要从B服务获取数据，用响应式编程的方式，服务A发请求到B后，立刻返回（即非阻塞和异步）。而请求的数据将作为A的异步数据流提供给A，B服务为每个数据都发送onNext 事件。当所有的数据都发送完毕的时候，则发送一个Completed事件。一旦有错误发生，则发送一个error事件，并且不会再继续发送数据了\n响应式编程使用函数式编程的格式，就行StreamAPI，这种方式可以在数据传输的过程中就行修改，一个数据流可以作为另一个的输入，数据流可以被合并、修改、和过滤。\n响应式系统 一个响应式系统的基础就是响应式编程，基于响应式编程的特性，响应式系统得具备以下特点\n 及时响应 在失败的场景依然可以响应 在不同的负载下，依然保持响应 依赖异步消息传递  背景 ReactiveX  2011年微软为.Net开发了Reactive Extension library。提供了一个可以创建异步、事件驱动的编程。很快Reactive Extension在其他语言平台也都完成了实现。Java、JavaScript、Python、C++、Go。而Java的实现，是由Nefix在2014年的时候发布的1.0版本，这个实现被称为ReactiveX\n 响应式数据流的定义 随着响应式的影响，Java团队提出了响应式的规范。规范定义了带有背压功能的组件之间如何交互的。Java9通过Flow API.采用了响应式数据流，FlowAPi的目的是提供Java的实现标准，而不是像RxJava这样，完全自己实现。\n其中定义了2个接口\n发布者Publisher：\n数据的源头提供一个方法供订阅者去注册。\npublic interface PublisherT { public void subscribe(Subscriber super T s); } 订阅者Subcriber：\npublic interface SubscriberT { public void onSubscribe(Subscription s); public void onNext(T t); public void onError(Throwable t); public void onComplete(); }  onSubscribe表示，Publisher会将订阅Subcription传给Subcriber onNext表示数据流中有一个新数据传过来了 onError表示Publisher出异常了，并且不会再继续发送数据 onComplete意味着数据全部发完了  订阅Subscription：\n订阅提供了方法可以控制Publisher传数据，（即提供了背压功能）\npublic interface Subscription { public void request(long n); public void cancel(); }  request允许subscriber控制有多少数据将要被发送 cancel允许subcriber取消publisher继续发送的数据  过程Processor：\n如果一个实体，把数据接收了，再传给另一个实体。那么这实体既是subcriber也是Publisher\npublic interface ProcessorT, R extends SubscriberT, PublisherR { } Project Reactor Spring在5.0发布后，集成了Project Reactor了。\nProject Reactor是一个基于Java定义的响应数据流的非阻塞程序。他是Spring响应式生态的基础。Webflux便是基于他而实现的。\nProject Reactor包含了一系列的module，最核心的module Reactor Core里提供了Flux和Mono，分别实现了之前说的JVM定义响应式数据流中的Publisher接口。\nFlux和Mono Flux和Mono都是Publisher，Flux定义了一个会发送0或N个数据的Publisher，而Mono定义了会发送0或1个数据的Publisher。他们都会被complete和error终止，并且他们都会调用下游的订阅者的onNext、onComplete、onError方法，除了实现JVM定义个数据流规范，他们还提供了一组可以修改数据的操作符，例如filter、map。\n简单使用\n@Test public void test(){ FluxString fluxNumber = Flux.just(\"1\", \"2\", \"3\"); fluxNumber.subscribe(System.out::println); } just方法创建了一个Flux会发送数据1，2，3 直到有人订阅了他，我们触发了subscribe方法，然后才会打印每一个被发送的数据。Mono也是一样，区别是Mono的just方法只允许传一个参数\n操作符\n查看一下 Flux API ，发现几乎所有的方法返回值都是Flux或者Mono，这意味着操作符是可以链式调用的。每个操作符都是向flux或者mono中新建一个operate，并将上一个Publisher作为参数从而生成的新实例。数据从最原始的Publisher不断的往下传送，逐步经过每个operate，最终一个subscirber结束了整个流程。如果没有订阅者订阅，则不会发生任何事情。\npublic void log(){ FluxString fluxNumber = Flux.just(\"1\", \"2\", \"3\"); fluxNumber.log().subscribe(System.out::println); } log操作符，会打印响应式数据流背后的操作细节\n15:59:42.580 [main] INFO reactor.Flux.Array.1 - | onSubscribe([Synchronous Fuseable] FluxArray.ArraySubscription) 15:59:42.581 [main] INFO reactor.Flux.Array.1 - | request(unbounded) 15:59:42.582 [main] INFO reactor.Flux.Array.1 - | onNext(1) 1 15:59:42.582 [main] INFO reactor.Flux.Array.1 - | onNext(2) 2 15:59:42.582 [main] INFO reactor.Flux.Array.1 - | onNext(3) 3 15:59:42.582 [main] INFO reactor.Flux.Array.1 - | onComplete()   常见的操作符\n   OPERATOR CATEGORY EXAMPLES     Creating a new sequence just, fromArray, fromIterable, fromStream   Transforming an existing sequence map, flatMap, startWith, concatWith   Peeking into a sequence doOnNext, doOnComplete, doOnError, doOnCancel   Filtering a sequence filter, ignoreElements, distinct, elementAt, takeLast   Handling errors onErrorReturn, onErrorResume, retry   Working with time elapsed, interval, timestamp, timeout   Splitting a Flux buffer, groupBy, window   Going back to the synchronous world block, blockFirst, blockLast, toIterable, toStream   Multicasting a Flux to several Subscribers publish, cache, replay      map\n@Test void mapExample() { FluxString fluxColors = Flux.just(\"red\", \"green\", \"blue\"); fluxColors.map(color - color.charAt(0)).subscribe(System.out::println); }   zip\n@Test void zipExample() { FluxString fluxFruits = Flux.just(\"apple\", \"pear\", \"plum\"); FluxString fluxColors = Flux.just(\"red\", \"green\", \"blue\"); FluxInteger fluxAmounts = Flux.just(10, 20, 30); Flux.zip(fluxFruits, fluxColors, fluxAmounts).subscribe(System.out::println); }   error处理\n@Test public void onErrorExample() { FluxString fluxCalc = Flux.just(-1, 0, 1) .map(i - \"10 / \" + i + \" = \" + (10 / i)); fluxCalc.subscribe(value - System.out.println(\"Next: \" + value), error - System.err.println(\"Error: \" + error)); } Next: 10 / -1 = -10 Error: java.lang.ArithmeticException: / by zero   onErrorReturn可以用来处理，operate中间发生的异常\n@Test public void onErrorReturnExample() { FluxString fluxCalc = Flux.just(-1, 0, 1) .map(i - \"10 / \" + i + \" = \" + (10 / i)) .onErrorReturn(ArithmeticException.class, \"Division by 0 not allowed\"); fluxCalc.subscribe(value - System.out.println(\"Next: \" + value), error - System.err.println(\"Error: \" + error)); } 通常可以使用onErrorReturn来处理异常，但是如果你想再发生异常时，再发送其他的数据而非是默认的数据。则可以使用onErrorResume方法\n@Test public void onErrorResumeExample() { FluxString fluxCalc = Flux.just(-1, 0, 1) .map(i - \"10 / \" + i + \" = \" + (10 / i)) .onErrorResume((err-{ if (err instanceof ArithmeticException){ return Flux.just(\"110\",\"112\"); } return Mono.just(\"119\"); })); fluxCalc.subscribe(value - System.out.println(\"Next: \" + value), error - System.err.println(\"Error: \" + error)); } Next: 10 / -1 = -10 Next: 110 Next: 112   测试\nProject Reactor提供了test的module\n@Test public void stepVerifierTest() { FluxString fluxCalc = Flux.just(-1, 0, 1) .map(i - \"10 / \" + i + \" = \" + (10 / i)); StepVerifier.create(fluxCalc) .expectNextCount(1) .expectError(ArithmeticException.class) .verify(); }   ","wordCount":"553","inLanguage":"en","datePublished":"2022-01-11T14:43:18+08:00","dateModified":"2022-01-11T14:43:18+08:00","author":{"@type":"Person","name":"Hao Sun"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sunhao1256.github.io/posts/reactor/"},"publisher":{"@type":"Organization","name":"Hao Sun","logo":{"@type":"ImageObject","url":"https://sunhao1256.github.io/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://sunhao1256.github.io/ accesskey=h title="Hao Sun (Alt + H)">Hao Sun</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://sunhao1256.github.io/archives/ title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://sunhao1256.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
<li>
<a href=https://sunhao1256.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://sunhao1256.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://sunhao1256.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Reactor响应式编程
</h1>
<div class=post-meta><span title="2022-01-11 14:43:18 +0800 CST">January 11, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Hao Sun
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#reactive-programming-%e5%93%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b aria-label="Reactive Programming 响应式编程">Reactive Programming 响应式编程</a><ul>
<li>
<a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%93%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b aria-label=为什么要响应式编程>为什么要响应式编程</a><ul>
<li>
<a href=#%e6%af%8f%e4%b8%aa%e8%af%b7%e6%b1%82%e9%83%bd%e9%9c%80%e8%a6%81%e4%b8%80%e4%b8%aa%e7%ba%bf%e7%a8%8b aria-label=每个请求都需要一个线程>每个请求都需要一个线程</a></li>
<li>
<a href=#%e9%98%bb%e5%a1%9eio%e6%93%8d%e4%bd%9c aria-label=阻塞IO操作>阻塞IO操作</a><ul>
<li>
<a href=#%e5%93%8d%e5%ba%94%e6%97%b6%e9%97%b4 aria-label=响应时间>响应时间</a></li></ul>
</li>
<li>
<a href=#%e5%8e%8b%e5%80%92%e5%ae%a2%e6%88%b7%e7%ab%af aria-label=压倒客户端>压倒客户端</a></li>
<li>
<a href=#%e5%b0%8f%e7%bb%93 aria-label=小结>小结</a></li></ul>
</li>
<li>
<a href=#%e4%bb%80%e4%b9%88%e6%98%af%e5%93%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b aria-label=什么是响应式编程>什么是响应式编程</a><ul>
<li>
<a href=#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0 aria-label=如何实现>如何实现</a></li>
<li>
<a href=#%e5%93%8d%e5%ba%94%e5%bc%8f%e7%b3%bb%e7%bb%9f aria-label=响应式系统>响应式系统</a></li></ul>
</li>
<li>
<a href=#%e8%83%8c%e6%99%af aria-label=背景>背景</a><ul>
<li>
<a href=#reactivex aria-label=ReactiveX>ReactiveX</a></li>
<li>
<a href=#%e5%93%8d%e5%ba%94%e5%bc%8f%e6%95%b0%e6%8d%ae%e6%b5%81%e7%9a%84%e5%ae%9a%e4%b9%89 aria-label=响应式数据流的定义>响应式数据流的定义</a></li>
<li>
<a href=#project-reactor aria-label="Project Reactor">Project Reactor</a><ul>
<li>
<a href=#flux%e5%92%8cmono aria-label=Flux和Mono>Flux和Mono</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=reactive-programming-响应式编程>Reactive Programming 响应式编程<a hidden class=anchor aria-hidden=true href=#reactive-programming-响应式编程>#</a></h1>
<h2 id=为什么要响应式编程>为什么要响应式编程<a hidden class=anchor aria-hidden=true href=#为什么要响应式编程>#</a></h2>
<p>传统的编程模式应对如今高并发，高响应的需求有很多限制。现在的web应用，越来越需要更高的并发，更快的响应。</p>
<h3 id=每个请求都需要一个线程>每个请求都需要一个线程<a hidden class=anchor aria-hidden=true href=#每个请求都需要一个线程>#</a></h3>
<p>传统的web请求，每个请求都是使用单个线程贯穿整个流程。如果我们用Spring的生态，对于的就是SpringMvc框架。基于servlet容器，例如tomcat。而tomcat内部会维护一个线程池去，每当请求来的时候，便会从池中分配一个thread来处理请求。这意味着，这个web程序的并发能力只能达到线程池的大小。当然为了提高并发能力，可以增加线程池的大小。但是在Java中一个线程的开销是昂贵的，通常是1MB的内存消耗。更大的线程池大小，则意味着更大的内存。</p>
<h3 id=阻塞io操作>阻塞IO操作<a hidden class=anchor aria-hidden=true href=#阻塞io操作>#</a></h3>
<p>IO操作，如果不做任何处理，势必会阻塞，例如查询数据库、RPC调用其他服务等。一旦发起了一个IO请求，持续等待，直到IO结束，这就是最基础的<strong>阻塞IO</strong></p>
<h4 id=响应时间>响应时间<a hidden class=anchor aria-hidden=true href=#响应时间>#</a></h4>
<p>在实际的场景中，一次请求中可能有不止一个服务调用链。例如A服务除了要调用B、C服务，还需要操作一次数据库。如果什么都不做的话，意味着这次请求花费的时间是下面花费时间之和</p>
<ul>
<li>B服务的响应时间（网络延迟+B服务的处理时间）</li>
<li>C服务的响应时间（网络延迟+C服务的处理时间）</li>
<li>数据的处理时间（网络延迟+处理时间）</li>
</ul>
<p>如果没有业务逻辑上的顺序，如果我们在代码中并发操作的话，那么消耗的时间肯定有所减少。虽然Java提供很多方便的异步回调方法，例如CompletableFutures，但是这极大的增加了代码的复杂性。没人愿意每次都这么复杂，并且并不是每个人都会想到用异步的。</p>
<h3 id=压倒客户端>压倒客户端<a hidden class=anchor aria-hidden=true href=#压倒客户端>#</a></h3>
<p>微服务中可能会出现这样的场景，A服务需要调用B一些信息，例如查一个月的订单，但是这个数据非常庞大，对于A服务来说，一次性无法处理，甚至可能出现OOM导致服务A直接挂了。</p>
<h3 id=小结>小结<a hidden class=anchor aria-hidden=true href=#小结>#</a></h3>
<p>总结上面的一些问题能发现响应式编程能带来的好处：</p>
<ul>
<li>不使用一个线程处理一个请求的模式，可以使用需要更少的线程处理更多的请求</li>
<li>防止线程在进行IO操作的时候被阻塞</li>
<li>能有简洁的并发操作API</li>
<li>提供背压机制，backpress，防止客户端直接被压垮</li>
</ul>
<h2 id=什么是响应式编程>什么是响应式编程<a hidden class=anchor aria-hidden=true href=#什么是响应式编程>#</a></h2>
<blockquote>
<p><em>“In plain terms reactive programming is about non-blocking applications that are asynchronous and event-driven and require a small number of threads to scale. A key aspect of that definition is the concept of backpressure which is a mechanism to ensure producers don’t overwhelm consumers.”</em></p>
</blockquote>
<p>&ldquo;响应式"是指响应围绕着变化的一种编程模型——例如网络组件随着IO事件变化、UI显示随着用户的鼠标点击而变化。从这一点上看，非阻塞就是响应式。因为不同于阻塞式，我们可以在数据准备好之后对通知进行响应，而非等待。</p>
<h3 id=如何实现>如何实现<a hidden class=anchor aria-hidden=true href=#如何实现>#</a></h3>
<p>简单点说就是，通过使用异步数据进行编程。还是A服务想要从B服务获取数据，用响应式编程的方式，服务A发请求到B后，立刻返回（即非阻塞和异步）。而请求的数据将作为A的异步数据流提供给A，B服务为每个数据都发送onNext 事件。当所有的数据都发送完毕的时候，则发送一个Completed事件。一旦有错误发生，则发送一个error事件，并且不会再继续发送数据了</p>
<p>响应式编程使用函数式编程的格式，就行StreamAPI，这种方式可以在数据传输的过程中就行修改，一个数据流可以作为另一个的输入，数据流可以被合并、修改、和过滤。</p>
<h3 id=响应式系统>响应式系统<a hidden class=anchor aria-hidden=true href=#响应式系统>#</a></h3>
<p>一个响应式系统的基础就是响应式编程，基于响应式编程的特性，响应式系统得具备以下特点</p>
<ul>
<li>及时响应</li>
<li>在失败的场景依然可以响应</li>
<li>在不同的负载下，依然保持响应</li>
<li>依赖异步消息传递</li>
</ul>
<h2 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h2>
<h3 id=reactivex>ReactiveX<a hidden class=anchor aria-hidden=true href=#reactivex>#</a></h3>
<blockquote>
<p>2011年微软为.Net开发了Reactive Extension library。提供了一个可以创建异步、事件驱动的编程。很快Reactive Extension在其他语言平台也都完成了实现。Java、JavaScript、Python、C++、Go。而Java的实现，是由Nefix在2014年的时候发布的1.0版本，这个实现被称为ReactiveX</p>
</blockquote>
<h3 id=响应式数据流的定义>响应式数据流的定义<a hidden class=anchor aria-hidden=true href=#响应式数据流的定义>#</a></h3>
<p>随着响应式的影响，Java团队提出了响应式的规范。规范定义了带有背压功能的组件之间如何交互的。Java9通过<a href=https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html>Flow API</a>.采用了响应式数据流，FlowAPi的目的是提供Java的实现标准，而不是像RxJava这样，完全自己实现。</p>
<p>其中定义了2个接口</p>
<p><strong>发布者Publisher：</strong></p>
<p>数据的源头提供一个方法供订阅者去注册。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Publisher</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>Subscriber<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> T<span style=color:#f92672>&gt;</span> s<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>
</code></pre></div><p><strong>订阅者Subcriber：</strong></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Subscriber</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onSubscribe</span><span style=color:#f92672>(</span>Subscription s<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span>T t<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onError</span><span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onComplete</span><span style=color:#f92672>();</span>
<span style=color:#f92672>}</span>
</code></pre></div><ul>
<li>onSubscribe表示，Publisher会将订阅Subcription传给Subcriber</li>
<li>onNext表示数据流中有一个新数据传过来了</li>
<li>onError表示Publisher出异常了，并且不会再继续发送数据</li>
<li>onComplete意味着数据全部发完了</li>
</ul>
<p><strong>订阅Subscription：</strong></p>
<p>订阅提供了方法可以控制Publisher传数据，（即提供了背压功能）</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Subscription</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>request</span><span style=color:#f92672>(</span><span style=color:#66d9ef>long</span> n<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cancel</span><span style=color:#f92672>();</span>
<span style=color:#f92672>}</span>
</code></pre></div><ul>
<li>request允许subscriber控制有多少数据将要被发送</li>
<li>cancel允许subcriber取消publisher继续发送的数据</li>
</ul>
<p><strong>过程Processor：</strong></p>
<p>如果一个实体，把数据接收了，再传给另一个实体。那么这实体既是subcriber也是Publisher</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Processor</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>,</span> R<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>extends</span> Subscriber<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;,</span> Publisher<span style=color:#f92672>&lt;</span>R<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
<span style=color:#f92672>}</span>
</code></pre></div><h3 id=project-reactor>Project Reactor<a hidden class=anchor aria-hidden=true href=#project-reactor>#</a></h3>
<p>Spring在5.0发布后，集成了Project Reactor了。</p>
<p>Project Reactor是一个基于Java定义的响应数据流的非阻塞程序。他是Spring响应式生态的基础。Webflux便是基于他而实现的。</p>
<p>Project Reactor包含了一系列的module，最核心的module Reactor Core里提供了<strong>Flux</strong>和<strong>Mono</strong>，分别实现了之前说的JVM定义响应式数据流中的Publisher接口。</p>
<h4 id=flux和mono>Flux和Mono<a hidden class=anchor aria-hidden=true href=#flux和mono>#</a></h4>
<p>Flux和Mono都是Publisher，Flux定义了一个会发送0或N个数据的Publisher，而Mono定义了会发送0或1个数据的Publisher。他们都会被complete和error终止，并且他们都会调用下游的订阅者的onNext、onComplete、onError方法，除了实现JVM定义个数据流规范，他们还提供了一组可以修改数据的操作符，例如filter、map。</p>
<p><strong>简单使用</strong></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Test</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>test</span><span style=color:#f92672>(){</span>
  Flux<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> fluxNumber <span style=color:#f92672>=</span> Flux<span style=color:#f92672>.</span><span style=color:#a6e22e>just</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;2&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;3&#34;</span><span style=color:#f92672>);</span>
  fluxNumber<span style=color:#f92672>.</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>::</span>println<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>just方法创建了一个Flux会发送数据1，2，3 直到有人订阅了他，我们触发了subscribe方法，然后才会打印每一个被发送的数据。Mono也是一样，区别是Mono的just方法只允许传一个参数</p>
<p><strong>操作符</strong></p>
<p>查看一下 <a href=https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html>Flux API</a> ，发现几乎所有的方法返回值都是Flux或者Mono，这意味着操作符是可以链式调用的。每个操作符都是向flux或者mono中新建一个operate，并将上一个Publisher作为参数从而生成的新实例。数据从最原始的Publisher不断的往下传送，逐步经过每个operate，最终一个subscirber结束了整个流程。如果没有订阅者订阅，则不会发生任何事情。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>log</span><span style=color:#f92672>(){</span>
        Flux<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> fluxNumber <span style=color:#f92672>=</span> Flux<span style=color:#f92672>.</span><span style=color:#a6e22e>just</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;2&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;3&#34;</span><span style=color:#f92672>);</span>
        fluxNumber<span style=color:#f92672>.</span><span style=color:#a6e22e>log</span><span style=color:#f92672>().</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>::</span>println<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
</code></pre></div><p>log操作符，会打印响应式数据流背后的操作细节</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>15:59<span style=color:#f92672>:</span>42<span style=color:#f92672>.</span><span style=color:#a6e22e>580</span> <span style=color:#f92672>[</span>main<span style=color:#f92672>]</span> INFO reactor<span style=color:#f92672>.</span><span style=color:#a6e22e>Flux</span><span style=color:#f92672>.</span><span style=color:#a6e22e>Array</span><span style=color:#f92672>.</span><span style=color:#a6e22e>1</span> <span style=color:#f92672>-</span> <span style=color:#f92672>|</span> onSubscribe<span style=color:#f92672>([</span>Synchronous Fuseable<span style=color:#f92672>]</span> FluxArray<span style=color:#f92672>.</span><span style=color:#a6e22e>ArraySubscription</span><span style=color:#f92672>)</span>
15:59<span style=color:#f92672>:</span>42<span style=color:#f92672>.</span><span style=color:#a6e22e>581</span> <span style=color:#f92672>[</span>main<span style=color:#f92672>]</span> INFO reactor<span style=color:#f92672>.</span><span style=color:#a6e22e>Flux</span><span style=color:#f92672>.</span><span style=color:#a6e22e>Array</span><span style=color:#f92672>.</span><span style=color:#a6e22e>1</span> <span style=color:#f92672>-</span> <span style=color:#f92672>|</span> request<span style=color:#f92672>(</span>unbounded<span style=color:#f92672>)</span>
15:59<span style=color:#f92672>:</span>42<span style=color:#f92672>.</span><span style=color:#a6e22e>582</span> <span style=color:#f92672>[</span>main<span style=color:#f92672>]</span> INFO reactor<span style=color:#f92672>.</span><span style=color:#a6e22e>Flux</span><span style=color:#f92672>.</span><span style=color:#a6e22e>Array</span><span style=color:#f92672>.</span><span style=color:#a6e22e>1</span> <span style=color:#f92672>-</span> <span style=color:#f92672>|</span> onNext<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>
1
15:59<span style=color:#f92672>:</span>42<span style=color:#f92672>.</span><span style=color:#a6e22e>582</span> <span style=color:#f92672>[</span>main<span style=color:#f92672>]</span> INFO reactor<span style=color:#f92672>.</span><span style=color:#a6e22e>Flux</span><span style=color:#f92672>.</span><span style=color:#a6e22e>Array</span><span style=color:#f92672>.</span><span style=color:#a6e22e>1</span> <span style=color:#f92672>-</span> <span style=color:#f92672>|</span> onNext<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span>
2
15:59<span style=color:#f92672>:</span>42<span style=color:#f92672>.</span><span style=color:#a6e22e>582</span> <span style=color:#f92672>[</span>main<span style=color:#f92672>]</span> INFO reactor<span style=color:#f92672>.</span><span style=color:#a6e22e>Flux</span><span style=color:#f92672>.</span><span style=color:#a6e22e>Array</span><span style=color:#f92672>.</span><span style=color:#a6e22e>1</span> <span style=color:#f92672>-</span> <span style=color:#f92672>|</span> onNext<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span>
3
15:59<span style=color:#f92672>:</span>42<span style=color:#f92672>.</span><span style=color:#a6e22e>582</span> <span style=color:#f92672>[</span>main<span style=color:#f92672>]</span> INFO reactor<span style=color:#f92672>.</span><span style=color:#a6e22e>Flux</span><span style=color:#f92672>.</span><span style=color:#a6e22e>Array</span><span style=color:#f92672>.</span><span style=color:#a6e22e>1</span> <span style=color:#f92672>-</span> <span style=color:#f92672>|</span> onComplete<span style=color:#f92672>()</span>
</code></pre></div><ul>
<li>
<p>常见的操作符</p>
<table>
<thead>
<tr>
<th style=text-align:left>OPERATOR CATEGORY</th>
<th style=text-align:left>EXAMPLES</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>Creating a new sequence</td>
<td style=text-align:left>just, fromArray, fromIterable, fromStream</td>
</tr>
<tr>
<td style=text-align:left>Transforming an existing sequence</td>
<td style=text-align:left>map, flatMap, startWith, concatWith</td>
</tr>
<tr>
<td style=text-align:left>Peeking into a sequence</td>
<td style=text-align:left>doOnNext, doOnComplete, doOnError, doOnCancel</td>
</tr>
<tr>
<td style=text-align:left>Filtering a sequence</td>
<td style=text-align:left>filter, ignoreElements, distinct, elementAt, takeLast</td>
</tr>
<tr>
<td style=text-align:left>Handling errors</td>
<td style=text-align:left>onErrorReturn, onErrorResume, retry</td>
</tr>
<tr>
<td style=text-align:left>Working with time</td>
<td style=text-align:left>elapsed, interval, timestamp, timeout</td>
</tr>
<tr>
<td style=text-align:left>Splitting a Flux</td>
<td style=text-align:left>buffer, groupBy, window</td>
</tr>
<tr>
<td style=text-align:left>Going back to the synchronous world</td>
<td style=text-align:left>block, blockFirst, blockLast, toIterable, toStream</td>
</tr>
<tr>
<td style=text-align:left>Multicasting a Flux to several Subscribers</td>
<td style=text-align:left>publish, cache, replay</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>map</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Test</span>
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>mapExample</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    Flux<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> fluxColors <span style=color:#f92672>=</span> Flux<span style=color:#f92672>.</span><span style=color:#a6e22e>just</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;red&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;green&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;blue&#34;</span><span style=color:#f92672>);</span>
    fluxColors<span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>color <span style=color:#f92672>-&gt;</span> color<span style=color:#f92672>.</span><span style=color:#a6e22e>charAt</span><span style=color:#f92672>(</span>0<span style=color:#f92672>)).</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>::</span>println<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>
</code></pre></div></li>
<li>
<p>zip</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Test</span>
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>zipExample</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    Flux<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> fluxFruits <span style=color:#f92672>=</span> Flux<span style=color:#f92672>.</span><span style=color:#a6e22e>just</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;apple&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;pear&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;plum&#34;</span><span style=color:#f92672>);</span>
    Flux<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> fluxColors <span style=color:#f92672>=</span> Flux<span style=color:#f92672>.</span><span style=color:#a6e22e>just</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;red&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;green&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;blue&#34;</span><span style=color:#f92672>);</span>
    Flux<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> fluxAmounts <span style=color:#f92672>=</span> Flux<span style=color:#f92672>.</span><span style=color:#a6e22e>just</span><span style=color:#f92672>(</span>10<span style=color:#f92672>,</span> 20<span style=color:#f92672>,</span> 30<span style=color:#f92672>);</span>
    Flux<span style=color:#f92672>.</span><span style=color:#a6e22e>zip</span><span style=color:#f92672>(</span>fluxFruits<span style=color:#f92672>,</span> fluxColors<span style=color:#f92672>,</span> fluxAmounts<span style=color:#f92672>).</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>::</span>println<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>
</code></pre></div></li>
<li>
<p>error处理</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Test</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onErrorExample</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    Flux<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> fluxCalc <span style=color:#f92672>=</span> Flux<span style=color:#f92672>.</span><span style=color:#a6e22e>just</span><span style=color:#f92672>(-</span>1<span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> 1<span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>i <span style=color:#f92672>-&gt;</span> <span style=color:#e6db74>&#34;10 / &#34;</span> <span style=color:#f92672>+</span> i <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; = &#34;</span> <span style=color:#f92672>+</span> <span style=color:#f92672>(</span>10 <span style=color:#f92672>/</span> i<span style=color:#f92672>));</span>

    fluxCalc<span style=color:#f92672>.</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>value <span style=color:#f92672>-&gt;</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Next: &#34;</span> <span style=color:#f92672>+</span> value<span style=color:#f92672>),</span>
        error <span style=color:#f92672>-&gt;</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>err</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Error: &#34;</span> <span style=color:#f92672>+</span> error<span style=color:#f92672>));</span>
<span style=color:#f92672>}</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Next: 10 <span style=color:#f92672>/</span> <span style=color:#f92672>-</span>1 <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>10
Error: java<span style=color:#f92672>.</span><span style=color:#a6e22e>lang</span><span style=color:#f92672>.</span><span style=color:#a6e22e>ArithmeticException</span><span style=color:#f92672>:</span> <span style=color:#f92672>/</span> by zero
</code></pre></div></li>
<li>
<p>onErrorReturn可以用来处理，operate中间发生的异常</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Test</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onErrorReturnExample</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    Flux<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> fluxCalc <span style=color:#f92672>=</span> Flux<span style=color:#f92672>.</span><span style=color:#a6e22e>just</span><span style=color:#f92672>(-</span>1<span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> 1<span style=color:#f92672>)</span>
	    <span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>i <span style=color:#f92672>-&gt;</span> <span style=color:#e6db74>&#34;10 / &#34;</span> <span style=color:#f92672>+</span> i <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; = &#34;</span> <span style=color:#f92672>+</span> <span style=color:#f92672>(</span>10 <span style=color:#f92672>/</span> i<span style=color:#f92672>))</span>
		<span style=color:#f92672>.</span><span style=color:#a6e22e>onErrorReturn</span><span style=color:#f92672>(</span>ArithmeticException<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;Division by 0 not allowed&#34;</span><span style=color:#f92672>);</span>

    fluxCalc<span style=color:#f92672>.</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>value <span style=color:#f92672>-&gt;</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Next: &#34;</span> <span style=color:#f92672>+</span> value<span style=color:#f92672>),</span>
	    error <span style=color:#f92672>-&gt;</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>err</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Error: &#34;</span> <span style=color:#f92672>+</span> error<span style=color:#f92672>));</span>

<span style=color:#f92672>}</span>
</code></pre></div><p>通常可以使用onErrorReturn来处理异常，但是如果你想再发生异常时，再发送其他的数据而非是默认的数据。则可以使用onErrorResume方法</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#a6e22e>@Test</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onErrorResumeExample</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        Flux<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> fluxCalc <span style=color:#f92672>=</span> Flux<span style=color:#f92672>.</span><span style=color:#a6e22e>just</span><span style=color:#f92672>(-</span>1<span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> 1<span style=color:#f92672>)</span>
                <span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>i <span style=color:#f92672>-&gt;</span> <span style=color:#e6db74>&#34;10 / &#34;</span> <span style=color:#f92672>+</span> i <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; = &#34;</span> <span style=color:#f92672>+</span> <span style=color:#f92672>(</span>10 <span style=color:#f92672>/</span> i<span style=color:#f92672>))</span>
                <span style=color:#f92672>.</span><span style=color:#a6e22e>onErrorResume</span><span style=color:#f92672>((</span>err<span style=color:#f92672>-&gt;{</span>
                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>err <span style=color:#66d9ef>instanceof</span> ArithmeticException<span style=color:#f92672>){</span>
                        <span style=color:#66d9ef>return</span> Flux<span style=color:#f92672>.</span><span style=color:#a6e22e>just</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;110&#34;</span><span style=color:#f92672>,</span><span style=color:#e6db74>&#34;112&#34;</span><span style=color:#f92672>);</span>
                    <span style=color:#f92672>}</span>
                    <span style=color:#66d9ef>return</span> Mono<span style=color:#f92672>.</span><span style=color:#a6e22e>just</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;119&#34;</span><span style=color:#f92672>);</span>
                <span style=color:#f92672>}));</span>

        fluxCalc<span style=color:#f92672>.</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>value <span style=color:#f92672>-&gt;</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Next: &#34;</span> <span style=color:#f92672>+</span> value<span style=color:#f92672>),</span>
                error <span style=color:#f92672>-&gt;</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>err</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Error: &#34;</span> <span style=color:#f92672>+</span> error<span style=color:#f92672>));</span>

    <span style=color:#f92672>}</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Next: 10 <span style=color:#f92672>/</span> <span style=color:#f92672>-</span>1 <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>10
Next: 110
Next: 112
</code></pre></div></li>
<li>
<p>测试</p>
<p>Project Reactor提供了test的module</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Test</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>stepVerifierTest</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    Flux<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> fluxCalc <span style=color:#f92672>=</span> Flux<span style=color:#f92672>.</span><span style=color:#a6e22e>just</span><span style=color:#f92672>(-</span>1<span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> 1<span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>i <span style=color:#f92672>-&gt;</span> <span style=color:#e6db74>&#34;10 / &#34;</span> <span style=color:#f92672>+</span> i <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; = &#34;</span> <span style=color:#f92672>+</span> <span style=color:#f92672>(</span>10 <span style=color:#f92672>/</span> i<span style=color:#f92672>));</span>

    StepVerifier<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>(</span>fluxCalc<span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>expectNextCount</span><span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>expectError</span><span style=color:#f92672>(</span>ArithmeticException<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>verify</span><span style=color:#f92672>();</span>
<span style=color:#f92672>}</span>
</code></pre></div></li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://sunhao1256.github.io/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/>乱七八糟</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://sunhao1256.github.io/posts/netty/>
<span class=title>« Prev Page</span>
<br>
<span>Netty</span>
</a>
<a class=next href=https://sunhao1256.github.io/posts/spring%E6%95%B4%E7%90%86/>
<span class=title>Next Page »</span>
<br>
<span>Spring问题整理</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://sunhao1256.github.io/>Hao Sun</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>