<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Netty | Hao Sun</title>
<meta name=keywords content="Netty">
<meta name=description content="netty是在什么地方创建SeverChannel的 在BootStrap调用bind方法时创建
private ChannelFuture doBind(final SocketAddress localAddress) { final ChannelFuture regFuture = this.initAndRegister(); } initAndRegister方法
final ChannelFuture initAndRegister() { Channel channel = null; try { channel = this.channelFactory.newChannel(); channelFactory是在bootstrap配置class时实例化的
在AbstractBootstrap中
public B channel(Class<? extends C> channelClass) { return this.channelFactory((io.netty.channel.ChannelFactory)(new ReflectiveChannelFactory((Class)ObjectUtil.checkNotNull(channelClass, &#34;channelClass&#34;)))); } 因此是直接通过反射，创建了NioServerSocketChannel.class
public class NioServerSocketChannel extends AbstractNioMessageChannel implements ServerSocketChannel { private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16); private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider(); private static final InternalLogger logger = InternalLoggerFactory.">
<meta name=author content="Hao Sun">
<link rel=canonical href=https://sunhao1256.github.io/posts/netty/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://sunhao1256.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=https://sunhao1256.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://sunhao1256.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://sunhao1256.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://sunhao1256.github.io/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.89.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="Netty">
<meta property="og:description" content="netty是在什么地方创建SeverChannel的 在BootStrap调用bind方法时创建
private ChannelFuture doBind(final SocketAddress localAddress) { final ChannelFuture regFuture = this.initAndRegister(); } initAndRegister方法
final ChannelFuture initAndRegister() { Channel channel = null; try { channel = this.channelFactory.newChannel(); channelFactory是在bootstrap配置class时实例化的
在AbstractBootstrap中
public B channel(Class<? extends C> channelClass) { return this.channelFactory((io.netty.channel.ChannelFactory)(new ReflectiveChannelFactory((Class)ObjectUtil.checkNotNull(channelClass, &#34;channelClass&#34;)))); } 因此是直接通过反射，创建了NioServerSocketChannel.class
public class NioServerSocketChannel extends AbstractNioMessageChannel implements ServerSocketChannel { private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16); private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider(); private static final InternalLogger logger = InternalLoggerFactory.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://sunhao1256.github.io/posts/netty/"><meta property="og:image" content="https://sunhao1256.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-01-11T14:43:18+08:00">
<meta property="article:modified_time" content="2022-01-11T14:43:18+08:00"><meta property="og:site_name" content="Hao Sun">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://sunhao1256.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name=twitter:title content="Netty">
<meta name=twitter:description content="netty是在什么地方创建SeverChannel的 在BootStrap调用bind方法时创建
private ChannelFuture doBind(final SocketAddress localAddress) { final ChannelFuture regFuture = this.initAndRegister(); } initAndRegister方法
final ChannelFuture initAndRegister() { Channel channel = null; try { channel = this.channelFactory.newChannel(); channelFactory是在bootstrap配置class时实例化的
在AbstractBootstrap中
public B channel(Class<? extends C> channelClass) { return this.channelFactory((io.netty.channel.ChannelFactory)(new ReflectiveChannelFactory((Class)ObjectUtil.checkNotNull(channelClass, &#34;channelClass&#34;)))); } 因此是直接通过反射，创建了NioServerSocketChannel.class
public class NioServerSocketChannel extends AbstractNioMessageChannel implements ServerSocketChannel { private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16); private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider(); private static final InternalLogger logger = InternalLoggerFactory.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sunhao1256.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Netty","item":"https://sunhao1256.github.io/posts/netty/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Netty","name":"Netty","description":"netty是在什么地方创建SeverChannel的 在BootStrap调用bind方法时创建\nprivate ChannelFuture doBind(final SocketAddress localAddress) { final ChannelFuture regFuture = this.initAndRegister(); } initAndRegister方法\nfinal ChannelFuture initAndRegister() { Channel channel = null; try { channel = this.channelFactory.newChannel(); channelFactory是在bootstrap配置class时实例化的\n在AbstractBootstrap中\npublic B channel(Class\u0026lt;? extends C\u0026gt; channelClass) { return this.channelFactory((io.netty.channel.ChannelFactory)(new ReflectiveChannelFactory((Class)ObjectUtil.checkNotNull(channelClass, \u0026#34;channelClass\u0026#34;)))); } 因此是直接通过反射，创建了NioServerSocketChannel.class\npublic class NioServerSocketChannel extends AbstractNioMessageChannel implements ServerSocketChannel { private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16); private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider(); private static final InternalLogger logger = InternalLoggerFactory.","keywords":["Netty"],"articleBody":"netty是在什么地方创建SeverChannel的 在BootStrap调用bind方法时创建\nprivate ChannelFuture doBind(final SocketAddress localAddress) { final ChannelFuture regFuture = this.initAndRegister(); } initAndRegister方法\nfinal ChannelFuture initAndRegister() { Channel channel = null; try { channel = this.channelFactory.newChannel(); channelFactory是在bootstrap配置class时实例化的\n在AbstractBootstrap中\npublic B channel(Class extends C channelClass) { return this.channelFactory((io.netty.channel.ChannelFactory)(new ReflectiveChannelFactory((Class)ObjectUtil.checkNotNull(channelClass, \"channelClass\")))); } 因此是直接通过反射，创建了NioServerSocketChannel.class\npublic class NioServerSocketChannel extends AbstractNioMessageChannel implements ServerSocketChannel { private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16); private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider(); private static final InternalLogger logger = InternalLoggerFactory.getInstance(NioServerSocketChannel.class); private final ServerSocketChannelConfig config; private static java.nio.channels.ServerSocketChannel newSocket(SelectorProvider provider) { try { //实际上就是调用了java的方法  return provider.openServerSocketChannel(); } catch (IOException var2) { throw new ChannelException(\"Failed to open a server socket.\", var2); } } public NioServerSocketChannel() { this(newSocket(DEFAULT_SELECTOR_PROVIDER)); } public NioServerSocketChannel(SelectorProvider provider) { this(newSocket(provider)); } //super方法中配置了阻塞  public NioServerSocketChannel(java.nio.channels.ServerSocketChannel channel) { super((Channel)null, channel, 16); this.config = new NioServerSocketChannel.NioServerSocketChannelConfig(this, this.javaChannel().socket()); } protected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) { super(parent); this.ch = ch; this.readInterestOp = readInterestOp; try { //设置阻塞  ch.configureBlocking(false); } catch (IOException var7) { try { ch.close(); } catch (IOException var6) { logger.warn(\"Failed to close a partially initialized socket.\", var6); } throw new ChannelException(\"Failed to enter non-blocking mode.\", var7); } } protected AbstractChannel(Channel parent) { this.parent = parent; this.id = this.newId(); this.unsafe = this.newUnsafe(); this.pipeline = this.newChannelPipeline();//创建了管道 } ServerBootstrapAcceptor 服务端不管之前增加了多少handler，最后都会增加ServerBootstrapAcceptor\n在ServerBootstrap.class中\nvoid init(Channel channel) { setChannelOptions(channel, this.newOptionsArray(), logger); setAttributes(channel, (Entry[])this.attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY)); ChannelPipeline p = channel.pipeline(); final EventLoopGroup currentChildGroup = this.childGroup; final ChannelHandler currentChildHandler = this.childHandler; final Entry[] currentChildOptions; synchronized(this.childOptions) { currentChildOptions = (Entry[])this.childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY); } final EntryAttributeKey, Object[] currentChildAttrs = (Entry[])this.childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY); p.addLast(new ChannelHandler[]{new ChannelInitializerChannel() { public void initChannel(final Channel ch) { final ChannelPipeline pipeline = ch.pipeline(); ChannelHandler handler = ServerBootstrap.this.config.handler(); if (handler != null) { pipeline.addLast(new ChannelHandler[]{handler}); } ch.eventLoop().execute(new Runnable() { public void run() { //在这里加入了默认的  //以后新的请求的都通过这个连接器处理，给新的连接分配一个nio线程  pipeline.addLast(new ChannelHandler[]{new ServerBootstrap.ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)}); } }); } }}); } netty服务端启动的几个过程：创建channel（创建jdk底层channel）、init初始化（最主要是添加连接器serverBootstrapAcceptor）、register（把第一步jdk底层创建channel注册到selector上面，并且把这个NioServerSocketChannel作为attachment添加进去），doBind（绑定端口，实现监听accept事件）\n  1、服务端的socket在哪里初始化？\n在bind方法中，initAndRegister中，实例化SocketChannel，使用的是反射方式，传入的就是bootstrap配置的channel.class。底层还是jdk的ServerSocketChannel对应普通方式的\nserverSocketChannel = ServerSocketChannel.open(); //设置为非阻塞模式 serverSocketChannel.configureBlocking(false); register是把创建好的注册到selector上，但没有监听事件，对应的是\n//监听客户端请求 //0表示只注册，不监听事件 serverSocketChannel.register(selector, 0); private static java.nio.channels.ServerSocketChannel newSocket(SelectorProvider provider) { try { return provider.openServerSocketChannel();//创建jdk的ServerSocketChannel  } catch (IOException var2) { throw new ChannelException(\"Failed to open a server socket.\", var2); } }   2、在哪里进行accept连接？\n还是在bind方法中，doBind最终底层调用了jdk的端口绑定和监听accpet事件\npublic NioServerSocketChannel(java.nio.channels.ServerSocketChannel channel) { super((Channel)null, channel, 16);//16就是SelectionKey.OP_ACCEPT 1 this.config = new NioServerSocketChannel.NioServerSocketChannelConfig(this, this.javaChannel().socket()); } 对应普通的就是\nserverSocketChannel.socket().bind(new InetSocketAddress(port),1024); //监听客户端请求 serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); bind最终是在NioServerSocketChannel执行的\nprotected void doBind(SocketAddress localAddress) throws Exception { if (PlatformDependent.javaVersion() = 7) { this.javaChannel().bind(localAddress, this.config.getBacklog()); } else { this.javaChannel().socket().bind(localAddress, this.config.getBacklog()); } } accpet最终是在AbstractNioChannel的doBeginRead方法中，注册了构造方法传来的16，即accpet事件\nprotected void doBeginRead() throws Exception { SelectionKey selectionKey = this.selectionKey; if (selectionKey.isValid()) { this.readPending = true; int interestOps = selectionKey.interestOps(); if ((interestOps \u0026 this.readInterestOp) == 0) { selectionKey.interestOps(interestOps | this.readInterestOp); } } }   NioEventLoopGroup、NioEventLoop的关系 在NioEventLoopGroup实例化的时候，会做如下动作\n  创建线程创建(执行)器：new ThreadPerTaskExecutor()\nprotected MultithreadEventExecutorGroup(int nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args) { this.terminatedChildren = new AtomicInteger(); this.terminationFuture = new DefaultPromise(GlobalEventExecutor.INSTANCE); if (nThreads  0) { throw new IllegalArgumentException(String.format(\"nThreads: %d (expected:  0)\", nThreads)); } else { if (executor == null) { //创建线程执行器  executor = new ThreadPerTaskExecutor(this.newDefaultThreadFactory()); } this.children = new EventExecutor[nThreads]; int j; for(int i = 0; i  nThreads; ++i) { boolean success = false; boolean var18 = false; try { var18 = true; //填充child  this.children[i] = this.newChild((Executor)executor, args); success = true; var18 = false; } catch (Exception var19) {   构造NioEventLoop：for{newChild()}\nprotected EventLoop newChild(Executor executor, Object... args) throws Exception { //填充的就是nioEventLoop  return new NioEventLoop(this, executor, (SelectorProvider)args[0], ((SelectStrategyFactory)args[1]).newSelectStrategy(), (RejectedExecutionHandler)args[2]); }   创建线程选择器：chooserFactory.newChooser()\nprivate static final class PowerOfTowEventExecutorChooser implements EventExecutorChooser { private final AtomicInteger idx = new AtomicInteger(); private final EventExecutor[] executors; PowerOfTowEventExecutorChooser(EventExecutor[] executors) { this.executors = executors; } @Override public EventExecutor next() { return executors[idx.getAndIncrement() \u0026 executors.length - 1]; } } private static final class GenericEventExecutorChooser implements EventExecutorChooser { private final AtomicInteger idx = new AtomicInteger(); private final EventExecutor[] executors; GenericEventExecutorChooser(EventExecutor[] executors) { this.executors = executors; } @Override public EventExecutor next() { return executors[Math.abs(idx.getAndIncrement() % executors.length)]; } } 模取运算除了%，还可以用\u0026（length-1）\n  线程创建与运行的流程\n  NioEventLoopGroup顾名思义，就是NioEventLoopGroup的集合，内部维护了children数组，数组的内容就是NioEventLoop\n  当调用Loop去execute的时候，实际上是调用线程执行器ThreadPerTaskExecutor去执行，内部DefaultThreadFactory就是创建了FastThreadLocalThread线程。\n  Loop的execute方法，除了用DefaultThreadFactory创建并运行FastThreadLocalThread线程外，还会将任务放入Loop自身维护的一个无锁队列。并且运行自身的run方法\nprivate void doStartThread() { assert thread == null; executor.execute(new Runnable() { @Override public void run() { thread = Thread.currentThread(); if (interrupted) { thread.interrupt(); } boolean success = false; updateLastExecutionTime(); try { SingleThreadEventExecutor.this.run();//调用run方法  // nioEventLoop的run方法,无线循环去消费队列  for(;;) ..... .... .... final int ioRatio = this.ioRatio; boolean ranTasks; if (ioRatio == 100) { try { if (strategy  0) { processSelectedKeys(); } } finally { // Ensure we always run tasks.  ranTasks = runAllTasks(); } } else if (strategy  0) { final long ioStartTime = System.nanoTime(); try { processSelectedKeys(); } finally { // Ensure we always run tasks.  final long ioTime = System.nanoTime() - ioStartTime; ranTasks = runAllTasks(ioTime * (100 - ioRatio) / ioRatio);//通过ioRatio控制消费任务的速度，这里就是不断的循环去消费  } } else { ranTasks = runAllTasks(0); // This will run the minimum number of tasks  }     总结\n在创建NioEventLoopGroup后，内部会维护了一个children，children的内容就是nioEventLoop，并且创建loop的时候为每个loop创建了内部的无锁队列，默认长度是系统核心的2倍，然后调用group的register或者execute方法，都会执行next去取一个loop，next方法就是模取循环下一个线程。\nloop会执行execute方法，实现会将任务Runnable放入队列。然后第一次运行时调用了ThreadFactory去创建了新线程，这个新线程并不是直接就开始执行任务，而是无限循环消费loop内部维护的无锁队列。达到了，一个loop一个线程。\n  NioEventLoop启动 在绑定端口的时候做了启动线程的动作\nchannel.eventLoop().execute(new Runnable() { @Override public void run() { if (regFuture.isSuccess()) { channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE); } else { promise.setFailure(regFuture.cause()); } } }); 这里的channel的eventLoop是通过register方法去绑定的，是在一开始Bootstrap的intAndRegister方法中执行\nfinal ChannelFuture initAndRegister() { Channel channel = null; try { channel = this.channelFactory.newChannel(); this.init(channel); } catch (Throwable var3) { if (channel != null) { channel.unsafe().closeForcibly(); return (new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE)).setFailure(var3); } return (new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE)).setFailure(var3); } //从group取一个loop绑定到channel上  ChannelFuture regFuture = this.config().group().register(channel); if (regFuture.cause() != null) { if (channel.isRegistered()) { channel.close(); } else { channel.unsafe().closeForcibly(); } } return regFuture; } NioEventLoop的run方法   select()检查是否有io事件\nnetty在这里检查是否需要select，需要的话，直接调用jdk的select方法，进行阻塞。\njdk的select方法，在linux下，会发生没有事件，但是select方法被触发导致的空轮训bug\nnetty的解决方式\nlong time = System.nanoTime(); //检查当前时间-本应该阻塞的时间=阻塞之前的时间，即发生阻塞了。没有空轮训 if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) = currentTimeNanos) { selectCnt = 1; //否则，空轮训超过默认的512次，重建selector } else if (SELECTOR_AUTO_REBUILD_THRESHOLD  0 \u0026\u0026 selectCnt = SELECTOR_AUTO_REBUILD_THRESHOLD) { logger.warn(\"Selector.select() returned prematurely {} times in a row; rebuilding Selector {}.\", selectCnt, selector); this.rebuildSelector(); selector = this.selector; selector.selectNow(); selectCnt = 1; break; }  rebuildSelector()方法就是将原来selector上的所有keys，绑定到新的selector上\n   processSelectedKeys()：处理io任务，即selectionKey中ready的事件，如accept、connect、read、write等\n底层取轮询io事件，都是通过NioUnsafe去处理的\nprivate void processSelectedKey(SelectionKey k, AbstractNioChannel ch) { final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe(); if (!k.isValid()) { final EventLoop eventLoop; try { eventLoop = ch.eventLoop(); } catch (Throwable ignored) { // If the channel implementation throws an exception because there is no event loop, we ignore this  // because we are only trying to determine if ch is registered to this event loop and thus has authority  // to close ch.  return; } // Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop  // and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is  // still healthy and should not be closed.  // See https://github.com/netty/netty/issues/5125  if (eventLoop == this) { // close the channel if the key is not valid anymore  unsafe.close(unsafe.voidPromise()); } return; } try { //处理各种事件  int readyOps = k.readyOps(); // We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise  // the NIO JDK channel implementation may throw a NotYetConnectedException.  if ((readyOps \u0026 SelectionKey.OP_CONNECT) != 0) { // remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking  // See https://github.com/netty/netty/issues/924  int ops = k.interestOps(); ops \u0026= ~SelectionKey.OP_CONNECT; k.interestOps(ops); unsafe.finishConnect(); } // Process OP_WRITE first as we may be able to write some queued buffers and so free memory.  if ((readyOps \u0026 SelectionKey.OP_WRITE) != 0) { // Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write  ch.unsafe().forceFlush(); } // Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead  // to a spin loop  if ((readyOps \u0026 (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) { unsafe.read(); } } catch (CancelledKeyException ignored) { unsafe.close(unsafe.voidPromise()); } }   runAllTasks()：处理异步任务队列里面的任务，也就是添加到taskQueue中的任务，如bind、channelActive等\n这里有个ioRatio，就是执行io任务和非io任务的时间比。用户可以自行设置。默认为50，可以看源码。如果是100的话，先执行完io任务，执行完之后才执行非io任务\nselectCnt++; cancelledKeys = 0; needsToSelectAgain = false; final int ioRatio = this.ioRatio; boolean ranTasks; if (ioRatio == 100) { try { if (strategy  0) { processSelectedKeys(); } } finally { // Ensure we always run tasks.  ranTasks = runAllTasks(); } } else if (strategy  0) { final long ioStartTime = System.nanoTime(); try { processSelectedKeys(); } finally { // Ensure we always run tasks.  final long ioTime = System.nanoTime() - ioStartTime; ranTasks = runAllTasks(ioTime * (100 - ioRatio) / ioRatio); } } else { ranTasks = runAllTasks(0); // This will run the minimum number of tasks  } if (ranTasks || strategy  0) { if (selectCnt  MIN_PREMATURE_SELECTOR_RETURNS \u0026\u0026 logger.isDebugEnabled()) { logger.debug(\"Selector.select() returned prematurely {} times in a row for Selector {}.\", selectCnt - 1, selector); } selectCnt = 0; } else if (unexpectedSelectorWakeup(selectCnt)) { // Unexpected wakeup (unusual case)  selectCnt = 0; } protected boolean runAllTasks(long timeoutNanos) { fetchFromScheduledTaskQueue();//将定时任务队列里的到期任务放入队列中，如果队列满了，还放在定时任务队列里  Runnable task = pollTask();//取一个任务出来  if (task == null) { afterRunningAllTasks(); return false; } final long deadline = timeoutNanos  0 ? ScheduledFutureTask.nanoTime() + timeoutNanos : 0; long runTasks = 0; long lastExecutionTime; for (;;) { safeExecute(task); runTasks ++; // Check timeout every 64 tasks because nanoTime() is relatively expensive.  // XXX: Hard-coded value - will make it configurable if it is really a problem.  if ((runTasks \u0026 0x3F) == 0) { lastExecutionTime = ScheduledFutureTask.nanoTime(); if (lastExecutionTime = deadline) { break; } } //不断处理任务  task = pollTask(); if (task == null) { lastExecutionTime = ScheduledFutureTask.nanoTime(); break; } } afterRunningAllTasks(); this.lastExecutionTime = lastExecutionTime; return true; }  定时任务的场景，例如心跳处理\n   服务端创建客户端连接流程 processSelectedKeys方法处理客户端连接，最后是落在底层的unsafe上。\nread方法最后会通知到管道上，通知所有的handler，\npublic void read() { assert eventLoop().inEventLoop(); final ChannelConfig config = config(); final ChannelPipeline pipeline = pipeline(); final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle(); allocHandle.reset(config); boolean closed = false; Throwable exception = null; try { try { do { //创建NioSocketChannel  int localRead = doReadMessages(readBuf); if (localRead == 0) { break; } if (localRead  0) { closed = true; break; } allocHandle.incMessagesRead(localRead); } while (continueReading(allocHandle)); } catch (Throwable t) { exception = t; } int size = readBuf.size(); for (int i = 0; i  size; i ++) { readPending = false; //管道传入NioSocketChannel  pipeline.fireChannelRead(readBuf.get(i)); } 而我们知道在一开始创建NioServerSocketChannel的时候，在init中最后加入了ServerBootstrapAcceptor。而ServerBootstrapAcceptor就是处理客户端连接的\n@Override @SuppressWarnings(\"unchecked\") public void channelRead(ChannelHandlerContext ctx, Object msg) { final Channel child = (Channel) msg; //得到上面的NioSocketChannel  //将一开始代码中的childHandler(new ChannelInitializer() {}传进来  child.pipeline().addLast(childHandler); //设置通道配置  setChannelOptions(child, childOptions, logger); //设置属性  setAttributes(child, childAttrs); try { //worker线程组注册channel  childGroup.register(child).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { if (!future.isSuccess()) { forceClose(child, future.cause()); } } }); } catch (Throwable t) { forceClose(child, t); } }\t  小结\nServer在获取到读事件后，创建了客户端的SocketChannel，并且通过pipeline通知到服务端初始化时创建的ServerBootstrapAcceptor，通过ServerBootstrapAcceptor初始化childHandler，使用worker组进行注册SocketChannel，并且创建客户端Channel默认的监听事件时read，然后就和服务端一样，通过默认的HeadContext进行read方法，默认都是自动读的。然后就是通过group创建新线程去工作。循环调底层的jdk方法。再通过pipeline通知到各个handler\n  Pipeline   netty是如何判断ChannelHandler类型的\n答：通过传入是inbound还是outbound\n  对于ChannelHandler的添加应该遵循什么样的顺序\n答：inbound传播是从Head结点开始的，outbound传播是从Tail节点开始的，所以需要根据需要从这两个方面选择\n  用户手动触发事件传播，不同的触发方式有什么样的区别？\n可以这里回答：ctx.channel().write()和ctx.write()的区别，ctx.channel().write()从tail节点开始传播（对于outBound事件），ctx.write()从当前节点开始传播。\n  初始化 Pipeline是在channel创建的时候进行初始化的，并且维护了双向链表，默认的添加HeadContext和TailContext，节点是AbstractChannelHandlerContext\nprotected AbstractChannel(Channel parent) { this.parent = parent; id = newId(); unsafe = newUnsafe(); pipeline = newChannelPipeline(); } protected DefaultChannelPipeline(Channel channel) { this.channel = ObjectUtil.checkNotNull(channel, \"channel\"); succeededFuture = new SucceededChannelFuture(channel, null); voidPromise = new VoidChannelPromise(channel, true); tail = new TailContext(this); head = new HeadContext(this); head.next = tail; tail.prev = head; } ChannelHandlerContext public interface ChannelHandlerContext extends AttributeMap, ChannelInboundInvoker, ChannelOutboundInvoker { /** * Return the {@link Channel} which is bound to the {@link ChannelHandlerContext}. */ //所在的channel  Channel channel(); /** * Returns the {@link EventExecutor} which is used to execute an arbitrary task. */ //哪一个loop执行的  EventExecutor executor(); /** * The unique name of the {@link ChannelHandlerContext}.The name was used when then {@link ChannelHandler} * was added to the {@link ChannelPipeline}. This name can also be used to access the registered * {@link ChannelHandler} from the {@link ChannelPipeline}. */ String name(); /** * The {@link ChannelHandler} that is bound this {@link ChannelHandlerContext}. */ //干活的业务handler  ChannelHandler handler(); /** * Return {@code true} if the {@link ChannelHandler} which belongs to this context was removed * from the {@link ChannelPipeline}. Note that this method is only meant to be called from with in the * {@link EventLoop}. */ boolean isRemoved(); ... /** * Return the assigned {@link ByteBufAllocator} which will be used to allocate {@link ByteBuf}s. */ // 内存分配器  ByteBufAllocator alloc(); ... } ChannelHandler的添加 DefaultChannelPipeline的addLast方法\n@Override public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) { final AbstractChannelHandlerContext newCtx; synchronized (this) { //检查handler是否重复，如果没@Shareable的话，不可以再添加了  checkMultiplicity(handler); //使用DefaultChannelHandlerContext，内部封装了具体的业务handler  newCtx = newContext(group, filterName(name, handler), handler); //连接到链表上去  addLast0(newCtx); // If the registered is false it means that the channel was not registered on an eventLoop yet.  // In this case we add the context to the pipeline and add a task that will call  // ChannelHandler.handlerAdded(...) once the channel is registered.  if (!registered) { newCtx.setAddPending(); callHandlerCallbackLater(newCtx, true); return this; } EventExecutor executor = newCtx.executor(); if (!executor.inEventLoop()) { callHandlerAddedInEventLoop(newCtx, executor); return this; } } callHandlerAdded0(newCtx); return this; } ChannelHandler删除 private AbstractChannelHandlerContext getContextOrDie(ChannelHandler handler) { AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext) context(handler); if (ctx == null) { throw new NoSuchElementException(handler.getClass().getName()); } else { return ctx; } } //从头到尾找  @Override public final ChannelHandlerContext context(ChannelHandler handler) { if (handler == null) { throw new NullPointerException(\"handler\"); } AbstractChannelHandlerContext ctx = head.next; for (;;) { if (ctx == null) { return null; } if (ctx.handler() == handler) { return ctx; } ctx = ctx.next; } } //不删除head和tail  private AbstractChannelHandlerContext remove(final AbstractChannelHandlerContext ctx) { assert ctx != head \u0026\u0026 ctx != tail; synchronized (this) { remove0(ctx); // If the registered is false it means that the channel was not registered on an eventloop yet.  // In this case we remove the context from the pipeline and add a task that will call  // ChannelHandler.handlerRemoved(...) once the channel is registered.  if (!registered) { callHandlerCallbackLater(ctx, false); return ctx; } EventExecutor executor = ctx.executor(); if (!executor.inEventLoop()) { executor.execute(new Runnable() { @Override public void run() { callHandlerRemoved0(ctx); } }); return ctx; } } callHandlerRemoved0(ctx); return ctx; } //真正的删除  private static void remove0(AbstractChannelHandlerContext ctx) { AbstractChannelHandlerContext prev = ctx.prev; AbstractChannelHandlerContext next = ctx.next; prev.next = next; next.prev = prev; } //通知删除  final void callHandlerRemoved() throws Exception { try { // Only call handlerRemoved(...) if we called handlerAdded(...) before.  if (handlerState == ADD_COMPLETE) { handler().handlerRemoved(this); } } finally { // Mark the handler as removed in any case.  //标记handler删除了  setRemoved(); } } Inboud事件 根据上面的描述，最终loop会绑定到pipeline中，当processSelectedKeys触发后，最后会调用到pipeline的fireChannelRead方法，找到下一个inboundHandlerContext\npublic ChannelHandlerContext fireChannelRead(Object msg) { invokeChannelRead(this.findContextInbound(), msg); return this; } //找到下一个Inbound的handler  private AbstractChannelHandlerContext findContextInbound() { AbstractChannelHandlerContext ctx = this; do { ctx = ctx.next; } while(!ctx.inbound); return ctx; } //创建handlerContext  DefaultChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name, ChannelHandler handler) { //判断是否是inbound  super(pipeline, executor, name, isInbound(handler), isOutbound(handler)); if (handler == null) { throw new NullPointerException(\"handler\"); } else { this.handler = handler; } } private static boolean isInbound(ChannelHandler handler) { return handler instanceof ChannelInboundHandler; } //出发handler的方法，直接到用户的业务代码了  private void invokeChannelRead(Object msg) { if (this.invokeHandler()) { try { ((ChannelInboundHandler)this.handler()).channelRead(this, msg); } catch (Throwable var3) { this.notifyHandlerException(var3); } } else { this.fireChannelRead(msg); } } outBound事件 包含bind、connect、disconnect方法、close、deregister、read、write、flush等方法，这些方法更多的是主动向用户发起的操作。\n（而inBound事件更多的是事件的触发，如register、readComplete、active，比较被动的）\noutBound是从tail反过来在链表上传输的\nctx.channel().write()和ctx.write()的区别 ctx.channel().write()从tail节点开始传播，ctx.write()从当前节点开始传播（不包括当前节点，因为它首先会找到当前节点的下一个节点在执行write操作）。\nByteBuf   Pooled和Unpooled\n池化和不池化\n  Unsafe和非Unsafe\nunsafe通过操作底层unsafe的offset+index的方式去操作数据，非unsafe直接通过一个数组的下标（或者jdk底层的buffer）去操作数据。\n  Heap和Direct\nheap是依赖一个数组，direct是依赖jdk底层的ByteBuffer。\n  ByteBuffAllocator UnpooledByteBufAllocator 分配堆内内存 //如果jdk环境支持unsafe，则用unsafe操作内存空间 //heap 内存空间，底层就是一个数组 protected ByteBuf newHeapBuffer(int initialCapacity, int maxCapacity) { return PlatformDependent.hasUnsafe() ? new InstrumentedUnpooledUnsafeHeapByteBuf(this, initialCapacity, maxCapacity) : new InstrumentedUnpooledHeapByteBuf(this, initialCapacity, maxCapacity); } public UnpooledHeapByteBuf(ByteBufAllocator alloc, int initialCapacity, int maxCapacity) { super(maxCapacity); if (initialCapacity  maxCapacity) { throw new IllegalArgumentException(String.format( \"initialCapacity(%d)  maxCapacity(%d)\", initialCapacity, maxCapacity)); } this.alloc = checkNotNull(alloc, \"alloc\"); //声明数组  setArray(allocateArray(initialCapacity)); setIndex(0, 0); } //创建数组  protected byte[] allocateArray(int initialCapacity) { return new byte[initialCapacity]; } 分配堆外内存 底层调用jdk的DirectBuffer\n@Override protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) { final ByteBuf buf; if (PlatformDependent.hasUnsafe()) { buf = noCleaner ? new InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf(this, initialCapacity, maxCapacity) : new InstrumentedUnpooledUnsafeDirectByteBuf(this, initialCapacity, maxCapacity); } else { buf = new InstrumentedUnpooledDirectByteBuf(this, initialCapacity, maxCapacity); } return disableLeakDetector ? buf : toLeakAwareBuffer(buf); } public UnpooledDirectByteBuf(ByteBufAllocator alloc, int initialCapacity, int maxCapacity) { super(maxCapacity); ObjectUtil.checkNotNull(alloc, \"alloc\"); checkPositiveOrZero(initialCapacity, \"initialCapacity\"); checkPositiveOrZero(maxCapacity, \"maxCapacity\"); if (initialCapacity  maxCapacity) { throw new IllegalArgumentException(String.format( \"initialCapacity(%d)  maxCapacity(%d)\", initialCapacity, maxCapacity)); } this.alloc = alloc; setByteBuffer(allocateDirect(initialCapacity), false); } protected ByteBuffer allocateDirect(int initialCapacity) { return ByteBuffer.allocateDirect(initialCapacity); } public static ByteBuffer allocateDirect(int capacity) { return new DirectByteBuffer(capacity); } void setByteBuffer(ByteBuffer buffer, boolean tryFree) { if (tryFree) { ByteBuffer oldBuffer = this.buffer; if (oldBuffer != null) { if (doNotFree) { doNotFree = false; } else { freeDirect(oldBuffer); } } } this.buffer = buffer; tmpNioBuf = null; capacity = buffer.remaining(); } final void setByteBuffer(ByteBuffer buffer, boolean tryFree) { super.setByteBuffer(buffer, tryFree); //计算内存地址，使用Unsafe去操作  memoryAddress = PlatformDependent.directBufferAddress(buffer); } //非 unsafe，直接调用jdk方法  protected byte _getByte(int index) { return buffer.get(index); } //获取内存地址，在用unsafe去调用  @Override protected byte _getByte(int index) { return UnsafeByteBufUtil.getByte(addr(index)); } //计算地址  final long addr(int index) { return memoryAddress + index; } PooledByteBufAllocator 分配堆内内存 @Override protected ByteBuf newHeapBuffer(int initialCapacity, int maxCapacity) { PoolThreadCache cache = threadCache.get();//取出当前线程的缓存，多线程情况下的处理  PoolArenabyte[] heapArena = cache.heapArena; //取出当前缓存里的arena  final ByteBuf buf; if (heapArena != null) { buf = heapArena.allocate(cache, initialCapacity, maxCapacity); } else { buf = PlatformDependent.hasUnsafe() ? new UnpooledUnsafeHeapByteBuf(this, initialCapacity, maxCapacity) : new UnpooledHeapByteBuf(this, initialCapacity, maxCapacity); } return toLeakAwareBuffer(buf); } final class PoolThreadLocalCache extends FastThreadLocalPoolThreadCache { @Override protected synchronized PoolThreadCache initialValue() { final PoolArenabyte[] heapArena = leastUsedArena(heapArenas); final PoolArenaByteBuffer directArena = leastUsedArena(directArenas); //FastThreadLocal就是ThreacLocal的快速版本，首次没有取到缓存的时候，会进行初始化动作  return new PoolThreadCache( heapArena, directArena, tinyCacheSize, smallCacheSize, normalCacheSize, DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL); } ... } ByteToMessageDecoder 抽象的字节解码器\n@Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { if (msg instanceof ByteBuf) { CodecOutputList out = CodecOutputList.newInstance(); try { first = cumulation == null; //检查是否要扩容，默认netty实现是合并到一个ByteBuf上，需要内存复制，另一种是直接创建一个新的compositeByteBuf  cumulation = cumulator.cumulate(ctx.alloc(), first ? Unpooled.EMPTY_BUFFER : cumulation, (ByteBuf) msg); callDecode(ctx, cumulation, out); } catch (DecoderException e) { throw e; } catch (Exception e) { throw new DecoderException(e); } finally { try { if (cumulation != null \u0026\u0026 !cumulation.isReadable()) { numReads = 0; cumulation.release(); cumulation = null; } else if (++numReads = discardAfterReads) { // We did enough reads already try to discard some bytes so we not risk to see a OOME.  // See https://github.com/netty/netty/issues/4275  numReads = 0; discardSomeReadBytes(); } int size = out.size(); firedChannelRead |= out.insertSinceRecycled(); fireChannelRead(ctx, out, size); } finally { out.recycle(); } } } else { ctx.fireChannelRead(msg); } } //默认Cumulator实现，内存复制到一个ByteBuf上  public static final Cumulator MERGE_CUMULATOR = new Cumulator() { @Override public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) { if (!cumulation.isReadable() \u0026\u0026 in.isContiguous()) { // If cumulation is empty and input buffer is contiguous, use it directly  cumulation.release(); return in; } try { final int required = in.readableBytes(); if (required  cumulation.maxWritableBytes() || (required  cumulation.maxFastWritableBytes() \u0026\u0026 cumulation.refCnt()  1) || cumulation.isReadOnly()) { // Expand cumulation (by replacing it) under the following conditions:  // - cumulation cannot be resized to accommodate the additional data  // - cumulation can be expanded with a reallocation operation to accommodate but the buffer is  // assumed to be shared (e.g. refCnt()  1) and the reallocation may not be safe.  return expandCumulation(alloc, cumulation, in); } cumulation.writeBytes(in, in.readerIndex(), required); in.readerIndex(in.writerIndex()); return cumulation; } finally { // We must release in in all cases as otherwise it may produce a leak if writeBytes(...) throw  // for whatever release (for example because of OutOfMemoryError)  in.release(); } } }; protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, ListObject out) { try { while (in.isReadable()) { final int outSize = out.size(); //解析到了数据  if (outSize  0) { //通知到下一个handler  fireChannelRead(ctx, out, outSize); out.clear(); // Check if this handler was removed before continuing with decoding.  // If it was removed, it is not safe to continue to operate on the buffer.  //  // See:  // - https://github.com/netty/netty/issues/4635  if (ctx.isRemoved()) { break; } } int oldInputLength = in.readableBytes(); //子类实现decode  decodeRemovalReentryProtection(ctx, in, out); // Check if this handler was removed before continuing the loop.  // If it was removed, it is not safe to continue to operate on the buffer.  //  // See https://github.com/netty/netty/issues/1664  if (ctx.isRemoved()) { break; } //如果子类没有解析到对象  // 1 数据不够解析道对象的  // 2  if (out.isEmpty()) { //数据不够解析的，跳出while，等下一次继续  if (oldInputLength == in.readableBytes()) { break; } else { // 解析出来的东西，不够合成一个对象的，继续解析  continue; } } // 解析出对象了，但是数据没有减少，有问题啊，明显对象你自己搞出来的，不是从数据里拿的，你有问题  if (oldInputLength == in.readableBytes()) { throw new DecoderException( StringUtil.simpleClassName(getClass()) + \".decode() did not read anything but decoded a message.\"); } // 如果只要解析一个，直接跳出  if (isSingleDecode()) { break; } } } catch (DecoderException e) { throw e; } catch (Exception cause) { throw new DecoderException(cause); } } ","wordCount":"3065","inLanguage":"en","datePublished":"2022-01-11T14:43:18+08:00","dateModified":"2022-01-11T14:43:18+08:00","author":{"@type":"Person","name":"Hao Sun"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sunhao1256.github.io/posts/netty/"},"publisher":{"@type":"Organization","name":"Hao Sun","logo":{"@type":"ImageObject","url":"https://sunhao1256.github.io/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://sunhao1256.github.io/ accesskey=h title="Hao Sun (Alt + H)">Hao Sun</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://sunhao1256.github.io/archives/ title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://sunhao1256.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
<li>
<a href=https://sunhao1256.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://sunhao1256.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://sunhao1256.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Netty
</h1>
<div class=post-meta><span title="2022-01-11 14:43:18 +0800 CST">January 11, 2022</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Hao Sun
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#netty%e6%98%af%e5%9c%a8%e4%bb%80%e4%b9%88%e5%9c%b0%e6%96%b9%e5%88%9b%e5%bb%baseverchannel%e7%9a%84 aria-label=netty是在什么地方创建SeverChannel的>netty是在什么地方创建SeverChannel的</a></li>
<li>
<a href=#serverbootstrapacceptor aria-label=ServerBootstrapAcceptor>ServerBootstrapAcceptor</a></li>
<li>
<a href=#nioeventloopgroupnioeventloop%e7%9a%84%e5%85%b3%e7%b3%bb aria-label=NioEventLoopGroup、NioEventLoop的关系>NioEventLoopGroup、NioEventLoop的关系</a></li>
<li>
<a href=#nioeventloop%e5%90%af%e5%8a%a8 aria-label=NioEventLoop启动>NioEventLoop启动</a></li>
<li>
<a href=#nioeventloop%e7%9a%84run%e6%96%b9%e6%b3%95 aria-label=NioEventLoop的run方法>NioEventLoop的run方法</a></li>
<li>
<a href=#%e6%9c%8d%e5%8a%a1%e7%ab%af%e5%88%9b%e5%bb%ba%e5%ae%a2%e6%88%b7%e7%ab%af%e8%bf%9e%e6%8e%a5%e6%b5%81%e7%a8%8b aria-label=服务端创建客户端连接流程>服务端创建客户端连接流程</a></li>
<li>
<a href=#pipeline aria-label=Pipeline>Pipeline</a><ul>
<li>
<a href=#%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label=初始化>初始化</a></li>
<li>
<a href=#channelhandlercontext aria-label=ChannelHandlerContext>ChannelHandlerContext</a></li>
<li>
<a href=#channelhandler%e7%9a%84%e6%b7%bb%e5%8a%a0 aria-label=ChannelHandler的添加>ChannelHandler的添加</a></li>
<li>
<a href=#channelhandler%e5%88%a0%e9%99%a4 aria-label=ChannelHandler删除>ChannelHandler删除</a></li>
<li>
<a href=#inboud%e4%ba%8b%e4%bb%b6 aria-label=Inboud事件>Inboud事件</a></li>
<li>
<a href=#outbound%e4%ba%8b%e4%bb%b6 aria-label=outBound事件>outBound事件</a></li>
<li>
<a href=#ctxchannelwrite%e5%92%8cctxwrite%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=ctx.channel().write()和ctx.write()的区别>ctx.channel().write()和ctx.write()的区别</a></li></ul>
</li>
<li>
<a href=#bytebuf aria-label=ByteBuf>ByteBuf</a></li>
<li>
<a href=#bytebuffallocator aria-label=ByteBuffAllocator>ByteBuffAllocator</a><ul>
<li>
<a href=#unpooledbytebufallocator aria-label=UnpooledByteBufAllocator>UnpooledByteBufAllocator</a><ul>
<li>
<a href=#%e5%88%86%e9%85%8d%e5%a0%86%e5%86%85%e5%86%85%e5%ad%98 aria-label=分配堆内内存>分配堆内内存</a></li>
<li>
<a href=#%e5%88%86%e9%85%8d%e5%a0%86%e5%a4%96%e5%86%85%e5%ad%98 aria-label=分配堆外内存>分配堆外内存</a></li></ul>
</li>
<li>
<a href=#pooledbytebufallocator aria-label=PooledByteBufAllocator>PooledByteBufAllocator</a><ul>
<li>
<a href=#%e5%88%86%e9%85%8d%e5%a0%86%e5%86%85%e5%86%85%e5%ad%98-1 aria-label=分配堆内内存>分配堆内内存</a></li></ul>
</li></ul>
</li>
<li>
<a href=#bytetomessagedecoder aria-label=ByteToMessageDecoder>ByteToMessageDecoder</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=netty是在什么地方创建severchannel的>netty是在什么地方创建SeverChannel的<a hidden class=anchor aria-hidden=true href=#netty是在什么地方创建severchannel的>#</a></h1>
<p>在BootStrap调用bind方法时创建</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>private</span> ChannelFuture <span style=color:#a6e22e>doBind</span><span style=color:#f92672>(</span><span style=color:#66d9ef>final</span> SocketAddress localAddress<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>final</span> ChannelFuture regFuture <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>initAndRegister</span><span style=color:#f92672>();</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>initAndRegister方法</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>final</span> ChannelFuture <span style=color:#a6e22e>initAndRegister</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    Channel channel <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>

    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
        channel <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>channelFactory</span><span style=color:#f92672>.</span><span style=color:#a6e22e>newChannel</span><span style=color:#f92672>();</span>
</code></pre></div><p>channelFactory是在bootstrap配置class时实例化的</p>
<p>在AbstractBootstrap中</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> B <span style=color:#a6e22e>channel</span><span style=color:#f92672>(</span>Class<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> C<span style=color:#f92672>&gt;</span> channelClass<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>channelFactory</span><span style=color:#f92672>((</span>io<span style=color:#f92672>.</span><span style=color:#a6e22e>netty</span><span style=color:#f92672>.</span><span style=color:#a6e22e>channel</span><span style=color:#f92672>.</span><span style=color:#a6e22e>ChannelFactory</span><span style=color:#f92672>)(</span><span style=color:#66d9ef>new</span> ReflectiveChannelFactory<span style=color:#f92672>((</span>Class<span style=color:#f92672>)</span>ObjectUtil<span style=color:#f92672>.</span><span style=color:#a6e22e>checkNotNull</span><span style=color:#f92672>(</span>channelClass<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;channelClass&#34;</span><span style=color:#f92672>))));</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>因此是直接通过反射，创建了NioServerSocketChannel.class</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NioServerSocketChannel</span> <span style=color:#66d9ef>extends</span> AbstractNioMessageChannel <span style=color:#66d9ef>implements</span> ServerSocketChannel <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> ChannelMetadata METADATA <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ChannelMetadata<span style=color:#f92672>(</span><span style=color:#66d9ef>false</span><span style=color:#f92672>,</span> 16<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> SelectorProvider DEFAULT_SELECTOR_PROVIDER <span style=color:#f92672>=</span> SelectorProvider<span style=color:#f92672>.</span><span style=color:#a6e22e>provider</span><span style=color:#f92672>();</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> InternalLogger logger <span style=color:#f92672>=</span> InternalLoggerFactory<span style=color:#f92672>.</span><span style=color:#a6e22e>getInstance</span><span style=color:#f92672>(</span>NioServerSocketChannel<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> ServerSocketChannelConfig config<span style=color:#f92672>;</span>

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> java<span style=color:#f92672>.</span><span style=color:#a6e22e>nio</span><span style=color:#f92672>.</span><span style=color:#a6e22e>channels</span><span style=color:#f92672>.</span><span style=color:#a6e22e>ServerSocketChannel</span> <span style=color:#a6e22e>newSocket</span><span style=color:#f92672>(</span>SelectorProvider provider<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
          <span style=color:#75715e>//实际上就是调用了java的方法
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> provider<span style=color:#f92672>.</span><span style=color:#a6e22e>openServerSocketChannel</span><span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>IOException var2<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ChannelException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Failed to open a server socket.&#34;</span><span style=color:#f92672>,</span> var2<span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>NioServerSocketChannel</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>(</span>newSocket<span style=color:#f92672>(</span>DEFAULT_SELECTOR_PROVIDER<span style=color:#f92672>));</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>NioServerSocketChannel</span><span style=color:#f92672>(</span>SelectorProvider provider<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>(</span>newSocket<span style=color:#f92672>(</span>provider<span style=color:#f92672>));</span>
    <span style=color:#f92672>}</span>
  <span style=color:#75715e>//super方法中配置了阻塞
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>NioServerSocketChannel</span><span style=color:#f92672>(</span>java<span style=color:#f92672>.</span><span style=color:#a6e22e>nio</span><span style=color:#f92672>.</span><span style=color:#a6e22e>channels</span><span style=color:#f92672>.</span><span style=color:#a6e22e>ServerSocketChannel</span> channel<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>super</span><span style=color:#f92672>((</span>Channel<span style=color:#f92672>)</span><span style=color:#66d9ef>null</span><span style=color:#f92672>,</span> channel<span style=color:#f92672>,</span> 16<span style=color:#f92672>);</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>config</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NioServerSocketChannel<span style=color:#f92672>.</span><span style=color:#a6e22e>NioServerSocketChannelConfig</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>javaChannel</span><span style=color:#f92672>().</span><span style=color:#a6e22e>socket</span><span style=color:#f92672>());</span>
    <span style=color:#f92672>}</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>protected</span> <span style=color:#a6e22e>AbstractNioChannel</span><span style=color:#f92672>(</span>Channel parent<span style=color:#f92672>,</span> SelectableChannel ch<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> readInterestOp<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>super</span><span style=color:#f92672>(</span>parent<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>ch</span> <span style=color:#f92672>=</span> ch<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>readInterestOp</span> <span style=color:#f92672>=</span> readInterestOp<span style=color:#f92672>;</span>

    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
      <span style=color:#75715e>//设置阻塞
</span><span style=color:#75715e></span>        ch<span style=color:#f92672>.</span><span style=color:#a6e22e>configureBlocking</span><span style=color:#f92672>(</span><span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>IOException var7<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
            ch<span style=color:#f92672>.</span><span style=color:#a6e22e>close</span><span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>IOException var6<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            logger<span style=color:#f92672>.</span><span style=color:#a6e22e>warn</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Failed to close a partially initialized socket.&#34;</span><span style=color:#f92672>,</span> var6<span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span>

        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ChannelException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Failed to enter non-blocking mode.&#34;</span><span style=color:#f92672>,</span> var7<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>protected</span> <span style=color:#a6e22e>AbstractChannel</span><span style=color:#f92672>(</span>Channel parent<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>parent</span> <span style=color:#f92672>=</span> parent<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>id</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>newId</span><span style=color:#f92672>();</span>
    <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>unsafe</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>newUnsafe</span><span style=color:#f92672>();</span>
    <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>pipeline</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>newChannelPipeline</span><span style=color:#f92672>();</span><span style=color:#75715e>//创建了管道
</span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</code></pre></div><h1 id=serverbootstrapacceptor>ServerBootstrapAcceptor<a hidden class=anchor aria-hidden=true href=#serverbootstrapacceptor>#</a></h1>
<p>服务端不管之前增加了多少handler，最后都会增加ServerBootstrapAcceptor</p>
<p>在ServerBootstrap.class中</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init</span><span style=color:#f92672>(</span>Channel channel<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    setChannelOptions<span style=color:#f92672>(</span>channel<span style=color:#f92672>,</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>newOptionsArray</span><span style=color:#f92672>(),</span> logger<span style=color:#f92672>);</span>
    setAttributes<span style=color:#f92672>(</span>channel<span style=color:#f92672>,</span> <span style=color:#f92672>(</span>Entry<span style=color:#f92672>[])</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>attrs0</span><span style=color:#f92672>().</span><span style=color:#a6e22e>entrySet</span><span style=color:#f92672>().</span><span style=color:#a6e22e>toArray</span><span style=color:#f92672>(</span>EMPTY_ATTRIBUTE_ARRAY<span style=color:#f92672>));</span>
    ChannelPipeline p <span style=color:#f92672>=</span> channel<span style=color:#f92672>.</span><span style=color:#a6e22e>pipeline</span><span style=color:#f92672>();</span>
    <span style=color:#66d9ef>final</span> EventLoopGroup currentChildGroup <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>childGroup</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>final</span> ChannelHandler currentChildHandler <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>childHandler</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>final</span> Entry<span style=color:#f92672>[]</span> currentChildOptions<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>synchronized</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>childOptions</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        currentChildOptions <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>Entry<span style=color:#f92672>[])</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>childOptions</span><span style=color:#f92672>.</span><span style=color:#a6e22e>entrySet</span><span style=color:#f92672>().</span><span style=color:#a6e22e>toArray</span><span style=color:#f92672>(</span>EMPTY_OPTION_ARRAY<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>final</span> Entry<span style=color:#f92672>&lt;</span>AttributeKey<span style=color:#f92672>&lt;?&gt;,</span> Object<span style=color:#f92672>&gt;[]</span> currentChildAttrs <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>Entry<span style=color:#f92672>[])</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>childAttrs</span><span style=color:#f92672>.</span><span style=color:#a6e22e>entrySet</span><span style=color:#f92672>().</span><span style=color:#a6e22e>toArray</span><span style=color:#f92672>(</span>EMPTY_ATTRIBUTE_ARRAY<span style=color:#f92672>);</span>
    p<span style=color:#f92672>.</span><span style=color:#a6e22e>addLast</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ChannelHandler<span style=color:#f92672>[]{</span><span style=color:#66d9ef>new</span> ChannelInitializer<span style=color:#f92672>&lt;</span>Channel<span style=color:#f92672>&gt;()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initChannel</span><span style=color:#f92672>(</span><span style=color:#66d9ef>final</span> Channel ch<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>final</span> ChannelPipeline pipeline <span style=color:#f92672>=</span> ch<span style=color:#f92672>.</span><span style=color:#a6e22e>pipeline</span><span style=color:#f92672>();</span>
            ChannelHandler handler <span style=color:#f92672>=</span> ServerBootstrap<span style=color:#f92672>.</span><span style=color:#a6e22e>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>config</span><span style=color:#f92672>.</span><span style=color:#a6e22e>handler</span><span style=color:#f92672>();</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>handler <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                pipeline<span style=color:#f92672>.</span><span style=color:#a6e22e>addLast</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ChannelHandler<span style=color:#f92672>[]{</span>handler<span style=color:#f92672>});</span>
            <span style=color:#f92672>}</span>

            ch<span style=color:#f92672>.</span><span style=color:#a6e22e>eventLoop</span><span style=color:#f92672>().</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Runnable<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
                  <span style=color:#75715e>//在这里加入了默认的
</span><span style=color:#75715e></span>                  <span style=color:#75715e>//以后新的请求的都通过这个连接器处理，给新的连接分配一个nio线程
</span><span style=color:#75715e></span>                    pipeline<span style=color:#f92672>.</span><span style=color:#a6e22e>addLast</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ChannelHandler<span style=color:#f92672>[]{</span><span style=color:#66d9ef>new</span> ServerBootstrap<span style=color:#f92672>.</span><span style=color:#a6e22e>ServerBootstrapAcceptor</span><span style=color:#f92672>(</span>ch<span style=color:#f92672>,</span> currentChildGroup<span style=color:#f92672>,</span> currentChildHandler<span style=color:#f92672>,</span> currentChildOptions<span style=color:#f92672>,</span> currentChildAttrs<span style=color:#f92672>)});</span>
                <span style=color:#f92672>}</span>
            <span style=color:#f92672>});</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}});</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>netty服务端启动的几个过程：创建channel（创建jdk底层channel）、init初始化（最主要是添加连接器serverBootstrapAcceptor）、register（把第一步jdk底层创建channel注册到selector上面，并且把这个NioServerSocketChannel作为attachment添加进去），doBind（绑定端口，实现监听accept事件）</p>
<ul>
<li>
<p>1、服务端的socket在哪里初始化？</p>
<p>在bind方法中，initAndRegister中，实例化SocketChannel，使用的是反射方式，传入的就是bootstrap配置的channel.class。底层还是jdk的ServerSocketChannel对应普通方式的</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>serverSocketChannel <span style=color:#f92672>=</span> ServerSocketChannel<span style=color:#f92672>.</span><span style=color:#a6e22e>open</span><span style=color:#f92672>();</span>
<span style=color:#75715e>//设置为非阻塞模式
</span><span style=color:#75715e></span>serverSocketChannel<span style=color:#f92672>.</span><span style=color:#a6e22e>configureBlocking</span><span style=color:#f92672>(</span><span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
</code></pre></div><p>register是把创建好的注册到selector上，但没有监听事件，对应的是</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>//监听客户端请求
</span><span style=color:#75715e>//0表示只注册，不监听事件
</span><span style=color:#75715e></span>serverSocketChannel<span style=color:#f92672>.</span><span style=color:#a6e22e>register</span><span style=color:#f92672>(</span>selector<span style=color:#f92672>,</span> 0<span style=color:#f92672>);</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> java<span style=color:#f92672>.</span><span style=color:#a6e22e>nio</span><span style=color:#f92672>.</span><span style=color:#a6e22e>channels</span><span style=color:#f92672>.</span><span style=color:#a6e22e>ServerSocketChannel</span> <span style=color:#a6e22e>newSocket</span><span style=color:#f92672>(</span>SelectorProvider provider<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>return</span> provider<span style=color:#f92672>.</span><span style=color:#a6e22e>openServerSocketChannel</span><span style=color:#f92672>();</span><span style=color:#75715e>//创建jdk的ServerSocketChannel
</span><span style=color:#75715e></span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>IOException var2<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ChannelException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Failed to open a server socket.&#34;</span><span style=color:#f92672>,</span> var2<span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>
</code></pre></div></li>
<li>
<p>2、在哪里进行accept连接？</p>
<p>还是在bind方法中，doBind最终底层调用了jdk的端口绑定和监听accpet事件</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>NioServerSocketChannel</span><span style=color:#f92672>(</span>java<span style=color:#f92672>.</span><span style=color:#a6e22e>nio</span><span style=color:#f92672>.</span><span style=color:#a6e22e>channels</span><span style=color:#f92672>.</span><span style=color:#a6e22e>ServerSocketChannel</span> channel<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>super</span><span style=color:#f92672>((</span>Channel<span style=color:#f92672>)</span><span style=color:#66d9ef>null</span><span style=color:#f92672>,</span> channel<span style=color:#f92672>,</span> 16<span style=color:#f92672>);</span><span style=color:#75715e>//16就是SelectionKey.OP_ACCEPT 1&lt;&lt;4
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>config</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NioServerSocketChannel<span style=color:#f92672>.</span><span style=color:#a6e22e>NioServerSocketChannelConfig</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>javaChannel</span><span style=color:#f92672>().</span><span style=color:#a6e22e>socket</span><span style=color:#f92672>());</span>
    <span style=color:#f92672>}</span>
</code></pre></div><p>对应普通的就是</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>serverSocketChannel<span style=color:#f92672>.</span><span style=color:#a6e22e>socket</span><span style=color:#f92672>().</span><span style=color:#a6e22e>bind</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> InetSocketAddress<span style=color:#f92672>(</span>port<span style=color:#f92672>),</span>1024<span style=color:#f92672>);</span>
<span style=color:#75715e>//监听客户端请求
</span><span style=color:#75715e></span>serverSocketChannel<span style=color:#f92672>.</span><span style=color:#a6e22e>register</span><span style=color:#f92672>(</span>selector<span style=color:#f92672>,</span> SelectionKey<span style=color:#f92672>.</span><span style=color:#a6e22e>OP_ACCEPT</span><span style=color:#f92672>);</span>
</code></pre></div><p>bind最终是在NioServerSocketChannel执行的</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doBind</span><span style=color:#f92672>(</span>SocketAddress localAddress<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>PlatformDependent<span style=color:#f92672>.</span><span style=color:#a6e22e>javaVersion</span><span style=color:#f92672>()</span> <span style=color:#f92672>&gt;=</span> 7<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>javaChannel</span><span style=color:#f92672>().</span><span style=color:#a6e22e>bind</span><span style=color:#f92672>(</span>localAddress<span style=color:#f92672>,</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>config</span><span style=color:#f92672>.</span><span style=color:#a6e22e>getBacklog</span><span style=color:#f92672>());</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>javaChannel</span><span style=color:#f92672>().</span><span style=color:#a6e22e>socket</span><span style=color:#f92672>().</span><span style=color:#a6e22e>bind</span><span style=color:#f92672>(</span>localAddress<span style=color:#f92672>,</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>config</span><span style=color:#f92672>.</span><span style=color:#a6e22e>getBacklog</span><span style=color:#f92672>());</span>
    <span style=color:#f92672>}</span>

<span style=color:#f92672>}</span>
</code></pre></div><p>accpet最终是在AbstractNioChannel的doBeginRead方法中，注册了构造方法传来的16，即accpet事件</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doBeginRead</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
    SelectionKey selectionKey <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>selectionKey</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>selectionKey<span style=color:#f92672>.</span><span style=color:#a6e22e>isValid</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>readPending</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
        <span style=color:#66d9ef>int</span> interestOps <span style=color:#f92672>=</span> selectionKey<span style=color:#f92672>.</span><span style=color:#a6e22e>interestOps</span><span style=color:#f92672>();</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>interestOps <span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>readInterestOp</span><span style=color:#f92672>)</span> <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            selectionKey<span style=color:#f92672>.</span><span style=color:#a6e22e>interestOps</span><span style=color:#f92672>(</span>interestOps <span style=color:#f92672>|</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>readInterestOp</span><span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span>

    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div></li>
</ul>
<h1 id=nioeventloopgroupnioeventloop的关系>NioEventLoopGroup、NioEventLoop的关系<a hidden class=anchor aria-hidden=true href=#nioeventloopgroupnioeventloop的关系>#</a></h1>
<p>在NioEventLoopGroup实例化的时候，会做如下动作</p>
<ul>
<li>
<p>创建线程创建(执行)器：new ThreadPerTaskExecutor()</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>protected</span> <span style=color:#a6e22e>MultithreadEventExecutorGroup</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> nThreads<span style=color:#f92672>,</span> Executor executor<span style=color:#f92672>,</span> EventExecutorChooserFactory chooserFactory<span style=color:#f92672>,</span> Object<span style=color:#f92672>...</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>terminatedChildren</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AtomicInteger<span style=color:#f92672>();</span>
    <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>terminationFuture</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DefaultPromise<span style=color:#f92672>(</span>GlobalEventExecutor<span style=color:#f92672>.</span><span style=color:#a6e22e>INSTANCE</span><span style=color:#f92672>);</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>nThreads <span style=color:#f92672>&lt;=</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException<span style=color:#f92672>(</span>String<span style=color:#f92672>.</span><span style=color:#a6e22e>format</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;nThreads: %d (expected: &gt; 0)&#34;</span><span style=color:#f92672>,</span> nThreads<span style=color:#f92672>));</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>executor <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
          <span style=color:#75715e>//创建线程执行器
</span><span style=color:#75715e></span>            executor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ThreadPerTaskExecutor<span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>newDefaultThreadFactory</span><span style=color:#f92672>());</span>
        <span style=color:#f92672>}</span>

            <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>children</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> EventExecutor<span style=color:#f92672>[</span>nThreads<span style=color:#f92672>];</span>

            <span style=color:#66d9ef>int</span> j<span style=color:#f92672>;</span>
            <span style=color:#66d9ef>for</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> nThreads<span style=color:#f92672>;</span> <span style=color:#f92672>++</span>i<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>boolean</span> success <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
                <span style=color:#66d9ef>boolean</span> var18 <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>

                <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
                    var18 <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
                  <span style=color:#75715e>//填充child
</span><span style=color:#75715e></span>                    <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>children</span><span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>newChild</span><span style=color:#f92672>((</span>Executor<span style=color:#f92672>)</span>executor<span style=color:#f92672>,</span> args<span style=color:#f92672>);</span>
                    success <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
                    var18 <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
                <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Exception var19<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>

</code></pre></div></li>
<li>
<p>构造NioEventLoop：for{newChild()}</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#66d9ef>protected</span> EventLoop <span style=color:#a6e22e>newChild</span><span style=color:#f92672>(</span>Executor executor<span style=color:#f92672>,</span> Object<span style=color:#f92672>...</span> args<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
      <span style=color:#75715e>//填充的就是nioEventLoop 
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> NioEventLoop<span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> executor<span style=color:#f92672>,</span> <span style=color:#f92672>(</span>SelectorProvider<span style=color:#f92672>)</span>args<span style=color:#f92672>[</span>0<span style=color:#f92672>],</span> <span style=color:#f92672>((</span>SelectStrategyFactory<span style=color:#f92672>)</span>args<span style=color:#f92672>[</span>1<span style=color:#f92672>]).</span><span style=color:#a6e22e>newSelectStrategy</span><span style=color:#f92672>(),</span> <span style=color:#f92672>(</span>RejectedExecutionHandler<span style=color:#f92672>)</span>args<span style=color:#f92672>[</span>2<span style=color:#f92672>]);</span>
    <span style=color:#f92672>}</span>
</code></pre></div></li>
<li>
<p>创建线程选择器：chooserFactory.newChooser()</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PowerOfTowEventExecutorChooser</span> <span style=color:#66d9ef>implements</span> EventExecutorChooser <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> AtomicInteger idx <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AtomicInteger<span style=color:#f92672>();</span>
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> EventExecutor<span style=color:#f92672>[]</span> executors<span style=color:#f92672>;</span>

        PowerOfTowEventExecutorChooser<span style=color:#f92672>(</span>EventExecutor<span style=color:#f92672>[]</span> executors<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>executors</span> <span style=color:#f92672>=</span> executors<span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>

        <span style=color:#a6e22e>@Override</span>
        <span style=color:#66d9ef>public</span> EventExecutor <span style=color:#a6e22e>next</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>return</span> executors<span style=color:#f92672>[</span>idx<span style=color:#f92672>.</span><span style=color:#a6e22e>getAndIncrement</span><span style=color:#f92672>()</span> <span style=color:#f92672>&amp;</span> executors<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1<span style=color:#f92672>];</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GenericEventExecutorChooser</span> <span style=color:#66d9ef>implements</span> EventExecutorChooser <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> AtomicInteger idx <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AtomicInteger<span style=color:#f92672>();</span>
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> EventExecutor<span style=color:#f92672>[]</span> executors<span style=color:#f92672>;</span>

        GenericEventExecutorChooser<span style=color:#f92672>(</span>EventExecutor<span style=color:#f92672>[]</span> executors<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>executors</span> <span style=color:#f92672>=</span> executors<span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>

        <span style=color:#a6e22e>@Override</span>
        <span style=color:#66d9ef>public</span> EventExecutor <span style=color:#a6e22e>next</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>return</span> executors<span style=color:#f92672>[</span>Math<span style=color:#f92672>.</span><span style=color:#a6e22e>abs</span><span style=color:#f92672>(</span>idx<span style=color:#f92672>.</span><span style=color:#a6e22e>getAndIncrement</span><span style=color:#f92672>()</span> <span style=color:#f92672>%</span> executors<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>)];</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>
</code></pre></div><p>模取运算除了%，还可以用&（length-1）</p>
</li>
<li>
<p>线程创建与运行的流程</p>
<ul>
<li>
<p>NioEventLoopGroup顾名思义，就是NioEventLoopGroup的集合，内部维护了children数组，数组的内容就是NioEventLoop</p>
</li>
<li>
<p>当调用Loop去execute的时候，实际上是调用线程执行器ThreadPerTaskExecutor去执行，内部DefaultThreadFactory就是创建了FastThreadLocalThread线程。</p>
</li>
<li>
<p>Loop的execute方法，除了用DefaultThreadFactory创建并运行FastThreadLocalThread线程外，还会将任务放入Loop自身维护的一个无锁队列。并且运行自身的run方法</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doStartThread</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>assert</span> thread <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
    executor<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Runnable<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#a6e22e>@Override</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
            thread <span style=color:#f92672>=</span> Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>();</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>interrupted<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                thread<span style=color:#f92672>.</span><span style=color:#a6e22e>interrupt</span><span style=color:#f92672>();</span>
            <span style=color:#f92672>}</span>

            <span style=color:#66d9ef>boolean</span> success <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
            updateLastExecutionTime<span style=color:#f92672>();</span>
            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
                SingleThreadEventExecutor<span style=color:#f92672>.</span><span style=color:#a6e22e>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>run</span><span style=color:#f92672>();</span><span style=color:#75715e>//调用run方法
</span><span style=color:#75715e></span>

<span style=color:#75715e>// nioEventLoop的run方法,无线循环去消费队列
</span><span style=color:#75715e></span>             <span style=color:#66d9ef>for</span><span style=color:#f92672>(;;)</span>
               <span style=color:#f92672>.....</span>
               <span style=color:#f92672>....</span>
               <span style=color:#f92672>....</span>
              <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> ioRatio <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>ioRatio</span><span style=color:#f92672>;</span>
              <span style=color:#66d9ef>boolean</span> ranTasks<span style=color:#f92672>;</span>
              <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>ioRatio <span style=color:#f92672>==</span> 100<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
                  <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>strategy <span style=color:#f92672>&gt;</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                    processSelectedKeys<span style=color:#f92672>();</span>
                  <span style=color:#f92672>}</span>
                <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
                  <span style=color:#75715e>// Ensure we always run tasks.
</span><span style=color:#75715e></span>                  ranTasks <span style=color:#f92672>=</span> runAllTasks<span style=color:#f92672>();</span>
                <span style=color:#f92672>}</span>
              <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>strategy <span style=color:#f92672>&gt;</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>long</span> ioStartTime <span style=color:#f92672>=</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>nanoTime</span><span style=color:#f92672>();</span>
                <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
                  processSelectedKeys<span style=color:#f92672>();</span>
                <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
                  <span style=color:#75715e>// Ensure we always run tasks.
</span><span style=color:#75715e></span>                  <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>long</span> ioTime <span style=color:#f92672>=</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>nanoTime</span><span style=color:#f92672>()</span> <span style=color:#f92672>-</span> ioStartTime<span style=color:#f92672>;</span>
                  ranTasks <span style=color:#f92672>=</span> runAllTasks<span style=color:#f92672>(</span>ioTime <span style=color:#f92672>*</span> <span style=color:#f92672>(</span>100 <span style=color:#f92672>-</span> ioRatio<span style=color:#f92672>)</span> <span style=color:#f92672>/</span> ioRatio<span style=color:#f92672>);</span><span style=color:#75715e>//通过ioRatio控制消费任务的速度，这里就是不断的循环去消费
</span><span style=color:#75715e></span>                <span style=color:#f92672>}</span>
              <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
                ranTasks <span style=color:#f92672>=</span> runAllTasks<span style=color:#f92672>(</span>0<span style=color:#f92672>);</span> <span style=color:#75715e>// This will run the minimum number of tasks
</span><span style=color:#75715e></span>              <span style=color:#f92672>}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>总结</p>
<p>在创建NioEventLoopGroup后，内部会维护了一个children，children的内容就是nioEventLoop，并且创建loop的时候为每个loop创建了内部的无锁队列，默认长度是系统核心的2倍，然后调用group的register或者execute方法，都会执行next去取一个loop，next方法就是模取循环下一个线程。</p>
<p>loop会执行execute方法，实现会将任务Runnable放入队列。然后第一次运行时调用了ThreadFactory去创建了新线程，这个新线程并不是直接就开始执行任务，而是无限循环消费loop内部维护的无锁队列。达到了，一个loop一个线程。</p>
</li>
</ul>
<h1 id=nioeventloop启动>NioEventLoop启动<a hidden class=anchor aria-hidden=true href=#nioeventloop启动>#</a></h1>
<p>在绑定端口的时候做了启动线程的动作</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>channel<span style=color:#f92672>.</span><span style=color:#a6e22e>eventLoop</span><span style=color:#f92672>().</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Runnable<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
            <span style=color:#a6e22e>@Override</span>
            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>regFuture<span style=color:#f92672>.</span><span style=color:#a6e22e>isSuccess</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
                    channel<span style=color:#f92672>.</span><span style=color:#a6e22e>bind</span><span style=color:#f92672>(</span>localAddress<span style=color:#f92672>,</span> promise<span style=color:#f92672>).</span><span style=color:#a6e22e>addListener</span><span style=color:#f92672>(</span>ChannelFutureListener<span style=color:#f92672>.</span><span style=color:#a6e22e>CLOSE_ON_FAILURE</span><span style=color:#f92672>);</span>
                <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
                    promise<span style=color:#f92672>.</span><span style=color:#a6e22e>setFailure</span><span style=color:#f92672>(</span>regFuture<span style=color:#f92672>.</span><span style=color:#a6e22e>cause</span><span style=color:#f92672>());</span>
                <span style=color:#f92672>}</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>});</span>
</code></pre></div><p>这里的channel的eventLoop是通过register方法去绑定的，是在一开始Bootstrap的intAndRegister方法中执行</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>
    <span style=color:#66d9ef>final</span> ChannelFuture <span style=color:#a6e22e>initAndRegister</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        Channel channel <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>

        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
            channel <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>channelFactory</span><span style=color:#f92672>.</span><span style=color:#a6e22e>newChannel</span><span style=color:#f92672>();</span>
            <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>init</span><span style=color:#f92672>(</span>channel<span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable var3<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>channel <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                channel<span style=color:#f92672>.</span><span style=color:#a6e22e>unsafe</span><span style=color:#f92672>().</span><span style=color:#a6e22e>closeForcibly</span><span style=color:#f92672>();</span>
                <span style=color:#66d9ef>return</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> DefaultChannelPromise<span style=color:#f92672>(</span>channel<span style=color:#f92672>,</span> GlobalEventExecutor<span style=color:#f92672>.</span><span style=color:#a6e22e>INSTANCE</span><span style=color:#f92672>)).</span><span style=color:#a6e22e>setFailure</span><span style=color:#f92672>(</span>var3<span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span>

            <span style=color:#66d9ef>return</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> DefaultChannelPromise<span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> FailedChannel<span style=color:#f92672>(),</span> GlobalEventExecutor<span style=color:#f92672>.</span><span style=color:#a6e22e>INSTANCE</span><span style=color:#f92672>)).</span><span style=color:#a6e22e>setFailure</span><span style=color:#f92672>(</span>var3<span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span>

      <span style=color:#75715e>//从group取一个loop绑定到channel上
</span><span style=color:#75715e></span>        ChannelFuture regFuture <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>config</span><span style=color:#f92672>().</span><span style=color:#a6e22e>group</span><span style=color:#f92672>().</span><span style=color:#a6e22e>register</span><span style=color:#f92672>(</span>channel<span style=color:#f92672>);</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>regFuture<span style=color:#f92672>.</span><span style=color:#a6e22e>cause</span><span style=color:#f92672>()</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>channel<span style=color:#f92672>.</span><span style=color:#a6e22e>isRegistered</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
                channel<span style=color:#f92672>.</span><span style=color:#a6e22e>close</span><span style=color:#f92672>();</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
                channel<span style=color:#f92672>.</span><span style=color:#a6e22e>unsafe</span><span style=color:#f92672>().</span><span style=color:#a6e22e>closeForcibly</span><span style=color:#f92672>();</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>

        <span style=color:#66d9ef>return</span> regFuture<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
</code></pre></div><h1 id=nioeventloop的run方法>NioEventLoop的run方法<a hidden class=anchor aria-hidden=true href=#nioeventloop的run方法>#</a></h1>
<ul>
<li>
<p>select()检查是否有io事件</p>
<p>netty在这里检查是否需要select，需要的话，直接调用jdk的select方法，进行阻塞。</p>
<p>jdk的select方法，在linux下，会发生没有事件，但是select方法被触发导致的空轮训bug</p>
<p>netty的解决方式</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>long</span> time <span style=color:#f92672>=</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>nanoTime</span><span style=color:#f92672>();</span>
<span style=color:#75715e>//检查当前时间-本应该阻塞的时间&gt;=阻塞之前的时间，即发生阻塞了。没有空轮训
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>time <span style=color:#f92672>-</span> TimeUnit<span style=color:#f92672>.</span><span style=color:#a6e22e>MILLISECONDS</span><span style=color:#f92672>.</span><span style=color:#a6e22e>toNanos</span><span style=color:#f92672>(</span>timeoutMillis<span style=color:#f92672>)</span> <span style=color:#f92672>&gt;=</span> currentTimeNanos<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    selectCnt <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span>
  <span style=color:#75715e>//否则，空轮训超过默认的512次，重建selector
</span><span style=color:#75715e></span><span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>SELECTOR_AUTO_REBUILD_THRESHOLD <span style=color:#f92672>&gt;</span> 0 <span style=color:#f92672>&amp;&amp;</span> selectCnt <span style=color:#f92672>&gt;=</span> SELECTOR_AUTO_REBUILD_THRESHOLD<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    logger<span style=color:#f92672>.</span><span style=color:#a6e22e>warn</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Selector.select() returned prematurely {} times in a row; rebuilding Selector {}.&#34;</span><span style=color:#f92672>,</span> selectCnt<span style=color:#f92672>,</span> selector<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>rebuildSelector</span><span style=color:#f92672>();</span>
    selector <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>selector</span><span style=color:#f92672>;</span>
    selector<span style=color:#f92672>.</span><span style=color:#a6e22e>selectNow</span><span style=color:#f92672>();</span>
    selectCnt <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>
</code></pre></div><blockquote>
<p>rebuildSelector()方法就是将原来selector上的所有keys，绑定到新的selector上</p>
</blockquote>
</li>
<li>
<p>processSelectedKeys()：处理io任务，即selectionKey中ready的事件，如accept、connect、read、write等</p>
<p>底层取轮询io事件，都是通过NioUnsafe去处理的</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>processSelectedKey</span><span style=color:#f92672>(</span>SelectionKey k<span style=color:#f92672>,</span> AbstractNioChannel ch<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>final</span> AbstractNioChannel<span style=color:#f92672>.</span><span style=color:#a6e22e>NioUnsafe</span> unsafe <span style=color:#f92672>=</span> ch<span style=color:#f92672>.</span><span style=color:#a6e22e>unsafe</span><span style=color:#f92672>();</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>k<span style=color:#f92672>.</span><span style=color:#a6e22e>isValid</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>final</span> EventLoop eventLoop<span style=color:#f92672>;</span>
            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
                eventLoop <span style=color:#f92672>=</span> ch<span style=color:#f92672>.</span><span style=color:#a6e22e>eventLoop</span><span style=color:#f92672>();</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable ignored<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                <span style=color:#75715e>// If the channel implementation throws an exception because there is no event loop, we ignore this
</span><span style=color:#75715e></span>                <span style=color:#75715e>// because we are only trying to determine if ch is registered to this event loop and thus has authority
</span><span style=color:#75715e></span>                <span style=color:#75715e>// to close ch.
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span>
            <span style=color:#75715e>// Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop
</span><span style=color:#75715e></span>            <span style=color:#75715e>// and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is
</span><span style=color:#75715e></span>            <span style=color:#75715e>// still healthy and should not be closed.
</span><span style=color:#75715e></span>            <span style=color:#75715e>// See https://github.com/netty/netty/issues/5125
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>eventLoop <span style=color:#f92672>==</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                <span style=color:#75715e>// close the channel if the key is not valid anymore
</span><span style=color:#75715e></span>                unsafe<span style=color:#f92672>.</span><span style=color:#a6e22e>close</span><span style=color:#f92672>(</span>unsafe<span style=color:#f92672>.</span><span style=color:#a6e22e>voidPromise</span><span style=color:#f92672>());</span>
            <span style=color:#f92672>}</span>
            <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>

        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
          <span style=color:#75715e>//处理各种事件
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>int</span> readyOps <span style=color:#f92672>=</span> k<span style=color:#f92672>.</span><span style=color:#a6e22e>readyOps</span><span style=color:#f92672>();</span>
            <span style=color:#75715e>// We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise
</span><span style=color:#75715e></span>            <span style=color:#75715e>// the NIO JDK channel implementation may throw a NotYetConnectedException.
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>readyOps <span style=color:#f92672>&amp;</span> SelectionKey<span style=color:#f92672>.</span><span style=color:#a6e22e>OP_CONNECT</span><span style=color:#f92672>)</span> <span style=color:#f92672>!=</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                <span style=color:#75715e>// remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking
</span><span style=color:#75715e></span>                <span style=color:#75715e>// See https://github.com/netty/netty/issues/924
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>int</span> ops <span style=color:#f92672>=</span> k<span style=color:#f92672>.</span><span style=color:#a6e22e>interestOps</span><span style=color:#f92672>();</span>
                ops <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>SelectionKey<span style=color:#f92672>.</span><span style=color:#a6e22e>OP_CONNECT</span><span style=color:#f92672>;</span>
                k<span style=color:#f92672>.</span><span style=color:#a6e22e>interestOps</span><span style=color:#f92672>(</span>ops<span style=color:#f92672>);</span>

                unsafe<span style=color:#f92672>.</span><span style=color:#a6e22e>finishConnect</span><span style=color:#f92672>();</span>
            <span style=color:#f92672>}</span>

            <span style=color:#75715e>// Process OP_WRITE first as we may be able to write some queued buffers and so free memory.
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>readyOps <span style=color:#f92672>&amp;</span> SelectionKey<span style=color:#f92672>.</span><span style=color:#a6e22e>OP_WRITE</span><span style=color:#f92672>)</span> <span style=color:#f92672>!=</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                <span style=color:#75715e>// Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write
</span><span style=color:#75715e></span>                ch<span style=color:#f92672>.</span><span style=color:#a6e22e>unsafe</span><span style=color:#f92672>().</span><span style=color:#a6e22e>forceFlush</span><span style=color:#f92672>();</span>
            <span style=color:#f92672>}</span>

            <span style=color:#75715e>// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead
</span><span style=color:#75715e></span>            <span style=color:#75715e>// to a spin loop
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>readyOps <span style=color:#f92672>&amp;</span> <span style=color:#f92672>(</span>SelectionKey<span style=color:#f92672>.</span><span style=color:#a6e22e>OP_READ</span> <span style=color:#f92672>|</span> SelectionKey<span style=color:#f92672>.</span><span style=color:#a6e22e>OP_ACCEPT</span><span style=color:#f92672>))</span> <span style=color:#f92672>!=</span> 0 <span style=color:#f92672>||</span> readyOps <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                unsafe<span style=color:#f92672>.</span><span style=color:#a6e22e>read</span><span style=color:#f92672>();</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>CancelledKeyException ignored<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            unsafe<span style=color:#f92672>.</span><span style=color:#a6e22e>close</span><span style=color:#f92672>(</span>unsafe<span style=color:#f92672>.</span><span style=color:#a6e22e>voidPromise</span><span style=color:#f92672>());</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>
</code></pre></div></li>
<li>
<p>runAllTasks()：处理异步任务队列里面的任务，也就是添加到taskQueue中的任务，如bind、channelActive等</p>
<p>这里有个ioRatio，就是执行io任务和非io任务的时间比。用户可以自行设置。默认为50，可以看源码。如果是100的话，先执行完io任务，执行完之后才执行非io任务</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>                selectCnt<span style=color:#f92672>++;</span>
                cancelledKeys <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
                needsToSelectAgain <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
                <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> ioRatio <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>ioRatio</span><span style=color:#f92672>;</span>
                <span style=color:#66d9ef>boolean</span> ranTasks<span style=color:#f92672>;</span>
                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>ioRatio <span style=color:#f92672>==</span> 100<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>strategy <span style=color:#f92672>&gt;</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                            processSelectedKeys<span style=color:#f92672>();</span>
                        <span style=color:#f92672>}</span>
                    <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
                        <span style=color:#75715e>// Ensure we always run tasks.
</span><span style=color:#75715e></span>                        ranTasks <span style=color:#f92672>=</span> runAllTasks<span style=color:#f92672>();</span>
                    <span style=color:#f92672>}</span>
                <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>strategy <span style=color:#f92672>&gt;</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>long</span> ioStartTime <span style=color:#f92672>=</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>nanoTime</span><span style=color:#f92672>();</span>
                    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
                        processSelectedKeys<span style=color:#f92672>();</span>
                    <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
                        <span style=color:#75715e>// Ensure we always run tasks.
</span><span style=color:#75715e></span>                        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>long</span> ioTime <span style=color:#f92672>=</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>nanoTime</span><span style=color:#f92672>()</span> <span style=color:#f92672>-</span> ioStartTime<span style=color:#f92672>;</span>
                        ranTasks <span style=color:#f92672>=</span> runAllTasks<span style=color:#f92672>(</span>ioTime <span style=color:#f92672>*</span> <span style=color:#f92672>(</span>100 <span style=color:#f92672>-</span> ioRatio<span style=color:#f92672>)</span> <span style=color:#f92672>/</span> ioRatio<span style=color:#f92672>);</span>
                    <span style=color:#f92672>}</span>
                <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
                    ranTasks <span style=color:#f92672>=</span> runAllTasks<span style=color:#f92672>(</span>0<span style=color:#f92672>);</span> <span style=color:#75715e>// This will run the minimum number of tasks
</span><span style=color:#75715e></span>                <span style=color:#f92672>}</span>

                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>ranTasks <span style=color:#f92672>||</span> strategy <span style=color:#f92672>&gt;</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>selectCnt <span style=color:#f92672>&gt;</span> MIN_PREMATURE_SELECTOR_RETURNS <span style=color:#f92672>&amp;&amp;</span> logger<span style=color:#f92672>.</span><span style=color:#a6e22e>isDebugEnabled</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
                        logger<span style=color:#f92672>.</span><span style=color:#a6e22e>debug</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Selector.select() returned prematurely {} times in a row for Selector {}.&#34;</span><span style=color:#f92672>,</span>
                                selectCnt <span style=color:#f92672>-</span> 1<span style=color:#f92672>,</span> selector<span style=color:#f92672>);</span>
                    <span style=color:#f92672>}</span>
                    selectCnt <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
                <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>unexpectedSelectorWakeup<span style=color:#f92672>(</span>selectCnt<span style=color:#f92672>))</span> <span style=color:#f92672>{</span> <span style=color:#75715e>// Unexpected wakeup (unusual case)
</span><span style=color:#75715e></span>                    selectCnt <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
                <span style=color:#f92672>}</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>runAllTasks</span><span style=color:#f92672>(</span><span style=color:#66d9ef>long</span> timeoutNanos<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    fetchFromScheduledTaskQueue<span style=color:#f92672>();</span><span style=color:#75715e>//将定时任务队列里的到期任务放入队列中，如果队列满了，还放在定时任务队列里
</span><span style=color:#75715e></span>    Runnable task <span style=color:#f92672>=</span> pollTask<span style=color:#f92672>();</span><span style=color:#75715e>//取一个任务出来
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>task <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        afterRunningAllTasks<span style=color:#f92672>();</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>long</span> deadline <span style=color:#f92672>=</span> timeoutNanos <span style=color:#f92672>&gt;</span> 0 <span style=color:#f92672>?</span> ScheduledFutureTask<span style=color:#f92672>.</span><span style=color:#a6e22e>nanoTime</span><span style=color:#f92672>()</span> <span style=color:#f92672>+</span> timeoutNanos <span style=color:#f92672>:</span> 0<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>long</span> runTasks <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>long</span> lastExecutionTime<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(;;)</span> <span style=color:#f92672>{</span>
        safeExecute<span style=color:#f92672>(</span>task<span style=color:#f92672>);</span>

        runTasks <span style=color:#f92672>++;</span>

        <span style=color:#75715e>// Check timeout every 64 tasks because nanoTime() is relatively expensive.
</span><span style=color:#75715e></span>        <span style=color:#75715e>// XXX: Hard-coded value - will make it configurable if it is really a problem.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>runTasks <span style=color:#f92672>&amp;</span> 0x3F<span style=color:#f92672>)</span> <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            lastExecutionTime <span style=color:#f92672>=</span> ScheduledFutureTask<span style=color:#f92672>.</span><span style=color:#a6e22e>nanoTime</span><span style=color:#f92672>();</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>lastExecutionTime <span style=color:#f92672>&gt;=</span> deadline<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>

      <span style=color:#75715e>//不断处理任务
</span><span style=color:#75715e></span>        task <span style=color:#f92672>=</span> pollTask<span style=color:#f92672>();</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>task <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            lastExecutionTime <span style=color:#f92672>=</span> ScheduledFutureTask<span style=color:#f92672>.</span><span style=color:#a6e22e>nanoTime</span><span style=color:#f92672>();</span>
            <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>

    afterRunningAllTasks<span style=color:#f92672>();</span>
    <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>lastExecutionTime</span> <span style=color:#f92672>=</span> lastExecutionTime<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>
</code></pre></div><blockquote>
<p>定时任务的场景，例如心跳处理</p>
</blockquote>
</li>
</ul>
<h1 id=服务端创建客户端连接流程>服务端创建客户端连接流程<a hidden class=anchor aria-hidden=true href=#服务端创建客户端连接流程>#</a></h1>
<p>processSelectedKeys方法处理客户端连接，最后是落在底层的unsafe上。</p>
<p>read方法最后会通知到管道上，通知所有的handler，</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>read</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>assert</span> eventLoop<span style=color:#f92672>().</span><span style=color:#a6e22e>inEventLoop</span><span style=color:#f92672>();</span>
    <span style=color:#66d9ef>final</span> ChannelConfig config <span style=color:#f92672>=</span> config<span style=color:#f92672>();</span>
    <span style=color:#66d9ef>final</span> ChannelPipeline pipeline <span style=color:#f92672>=</span> pipeline<span style=color:#f92672>();</span>
    <span style=color:#66d9ef>final</span> RecvByteBufAllocator<span style=color:#f92672>.</span><span style=color:#a6e22e>Handle</span> allocHandle <span style=color:#f92672>=</span> unsafe<span style=color:#f92672>().</span><span style=color:#a6e22e>recvBufAllocHandle</span><span style=color:#f92672>();</span>
    allocHandle<span style=color:#f92672>.</span><span style=color:#a6e22e>reset</span><span style=color:#f92672>(</span>config<span style=color:#f92672>);</span>

    <span style=color:#66d9ef>boolean</span> closed <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
    Throwable exception <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>do</span> <span style=color:#f92672>{</span>
              <span style=color:#75715e>//创建NioSocketChannel
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>int</span> localRead <span style=color:#f92672>=</span> doReadMessages<span style=color:#f92672>(</span>readBuf<span style=color:#f92672>);</span>
                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>localRead <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                    <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
                <span style=color:#f92672>}</span>
                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>localRead <span style=color:#f92672>&lt;</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                    closed <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
                    <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
                <span style=color:#f92672>}</span>

                allocHandle<span style=color:#f92672>.</span><span style=color:#a6e22e>incMessagesRead</span><span style=color:#f92672>(</span>localRead<span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>continueReading<span style=color:#f92672>(</span>allocHandle<span style=color:#f92672>));</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            exception <span style=color:#f92672>=</span> t<span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>

        <span style=color:#66d9ef>int</span> size <span style=color:#f92672>=</span> readBuf<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>();</span>
        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> size<span style=color:#f92672>;</span> i <span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
            readPending <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
          <span style=color:#75715e>//管道传入NioSocketChannel
</span><span style=color:#75715e></span>            pipeline<span style=color:#f92672>.</span><span style=color:#a6e22e>fireChannelRead</span><span style=color:#f92672>(</span>readBuf<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>i<span style=color:#f92672>));</span>
        <span style=color:#f92672>}</span>
</code></pre></div><p>而我们知道在一开始创建NioServerSocketChannel的时候，在init中最后加入了ServerBootstrapAcceptor。而ServerBootstrapAcceptor就是处理客户端连接的</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>        <span style=color:#a6e22e>@Override</span>
        <span style=color:#a6e22e>@SuppressWarnings</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;unchecked&#34;</span><span style=color:#f92672>)</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>channelRead</span><span style=color:#f92672>(</span>ChannelHandlerContext ctx<span style=color:#f92672>,</span> Object msg<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>final</span> Channel child <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>Channel<span style=color:#f92672>)</span> msg<span style=color:#f92672>;</span>

          <span style=color:#75715e>//得到上面的NioSocketChannel
</span><span style=color:#75715e></span>          <span style=color:#75715e>//将一开始代码中的childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {}传进来
</span><span style=color:#75715e></span>            child<span style=color:#f92672>.</span><span style=color:#a6e22e>pipeline</span><span style=color:#f92672>().</span><span style=color:#a6e22e>addLast</span><span style=color:#f92672>(</span>childHandler<span style=color:#f92672>);</span>
          <span style=color:#75715e>//设置通道配置
</span><span style=color:#75715e></span>            setChannelOptions<span style=color:#f92672>(</span>child<span style=color:#f92672>,</span> childOptions<span style=color:#f92672>,</span> logger<span style=color:#f92672>);</span>
          <span style=color:#75715e>//设置属性  
</span><span style=color:#75715e></span>          setAttributes<span style=color:#f92672>(</span>child<span style=color:#f92672>,</span> childAttrs<span style=color:#f92672>);</span>

            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
              <span style=color:#75715e>//worker线程组注册channel
</span><span style=color:#75715e></span>                childGroup<span style=color:#f92672>.</span><span style=color:#a6e22e>register</span><span style=color:#f92672>(</span>child<span style=color:#f92672>).</span><span style=color:#a6e22e>addListener</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ChannelFutureListener<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
                    <span style=color:#a6e22e>@Override</span>
                    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operationComplete</span><span style=color:#f92672>(</span>ChannelFuture future<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>future<span style=color:#f92672>.</span><span style=color:#a6e22e>isSuccess</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
                            forceClose<span style=color:#f92672>(</span>child<span style=color:#f92672>,</span> future<span style=color:#f92672>.</span><span style=color:#a6e22e>cause</span><span style=color:#f92672>());</span>
                        <span style=color:#f92672>}</span>
                    <span style=color:#f92672>}</span>
                <span style=color:#f92672>});</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                forceClose<span style=color:#f92672>(</span>child<span style=color:#f92672>,</span> t<span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>		
</code></pre></div><ul>
<li>
<p>小结</p>
<p>Server在获取到读事件后，创建了客户端的SocketChannel，并且通过pipeline通知到服务端初始化时创建的ServerBootstrapAcceptor，<strong>通过ServerBootstrapAcceptor初始化childHandler</strong>，使用worker组进行注册SocketChannel，并且创建客户端Channel默认的监听事件时read，然后就和服务端一样，通过默认的HeadContext进行read方法，默认都是自动读的。然后就是通过group创建新线程去工作。循环调底层的jdk方法。再通过pipeline通知到各个handler</p>
</li>
</ul>
<h1 id=pipeline>Pipeline<a hidden class=anchor aria-hidden=true href=#pipeline>#</a></h1>
<ul>
<li>
<p>netty是如何判断ChannelHandler类型的</p>
<p>答：通过传入是inbound还是outbound</p>
</li>
<li>
<p>对于ChannelHandler的添加应该遵循什么样的顺序</p>
<p>答：inbound传播是从Head结点开始的，outbound传播是从Tail节点开始的，所以需要根据需要从这两个方面选择</p>
</li>
<li>
<p>用户手动触发事件传播，不同的触发方式有什么样的区别？</p>
<p>可以这里回答：ctx.channel().write()和ctx.write()的区别，ctx.channel().write()从tail节点开始传播（对于outBound事件），ctx.write()从当前节点开始传播。</p>
</li>
</ul>
<h2 id=初始化>初始化<a hidden class=anchor aria-hidden=true href=#初始化>#</a></h2>
<p>Pipeline是在channel创建的时候进行初始化的，并且维护了双向链表，默认的添加HeadContext和TailContext，节点是AbstractChannelHandlerContext</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#66d9ef>protected</span> <span style=color:#a6e22e>AbstractChannel</span><span style=color:#f92672>(</span>Channel parent<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>parent</span> <span style=color:#f92672>=</span> parent<span style=color:#f92672>;</span>
        id <span style=color:#f92672>=</span> newId<span style=color:#f92672>();</span>
        unsafe <span style=color:#f92672>=</span> newUnsafe<span style=color:#f92672>();</span>
        pipeline <span style=color:#f92672>=</span> newChannelPipeline<span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>protected</span> <span style=color:#a6e22e>DefaultChannelPipeline</span><span style=color:#f92672>(</span>Channel channel<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>channel</span> <span style=color:#f92672>=</span> ObjectUtil<span style=color:#f92672>.</span><span style=color:#a6e22e>checkNotNull</span><span style=color:#f92672>(</span>channel<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;channel&#34;</span><span style=color:#f92672>);</span>
        succeededFuture <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SucceededChannelFuture<span style=color:#f92672>(</span>channel<span style=color:#f92672>,</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
        voidPromise <span style=color:#f92672>=</span>  <span style=color:#66d9ef>new</span> VoidChannelPromise<span style=color:#f92672>(</span>channel<span style=color:#f92672>,</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>);</span>

        tail <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TailContext<span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>);</span>
        head <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HeadContext<span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>);</span>

        head<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> tail<span style=color:#f92672>;</span>
        tail<span style=color:#f92672>.</span><span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> head<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
</code></pre></div><h2 id=channelhandlercontext>ChannelHandlerContext<a hidden class=anchor aria-hidden=true href=#channelhandlercontext>#</a></h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ChannelHandlerContext</span> <span style=color:#66d9ef>extends</span> AttributeMap<span style=color:#f92672>,</span> ChannelInboundInvoker<span style=color:#f92672>,</span> ChannelOutboundInvoker <span style=color:#f92672>{</span>
 
    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Return the {@link Channel} which is bound to the {@link ChannelHandlerContext}.
</span><span style=color:#75715e>     */</span>
  <span style=color:#75715e>//所在的channel
</span><span style=color:#75715e></span>    Channel <span style=color:#a6e22e>channel</span><span style=color:#f92672>();</span>
 
    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Returns the {@link EventExecutor} which is used to execute an arbitrary task.
</span><span style=color:#75715e>     */</span>
  <span style=color:#75715e>//哪一个loop执行的
</span><span style=color:#75715e></span>    EventExecutor <span style=color:#a6e22e>executor</span><span style=color:#f92672>();</span>
 
    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * The unique name of the {@link ChannelHandlerContext}.The name was used when then {@link ChannelHandler}
</span><span style=color:#75715e>     * was added to the {@link ChannelPipeline}. This name can also be used to access the registered
</span><span style=color:#75715e>     * {@link ChannelHandler} from the {@link ChannelPipeline}.
</span><span style=color:#75715e>     */</span>
    String <span style=color:#a6e22e>name</span><span style=color:#f92672>();</span>
 
    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * The {@link ChannelHandler} that is bound this {@link ChannelHandlerContext}.
</span><span style=color:#75715e>     */</span>
  <span style=color:#75715e>//干活的业务handler
</span><span style=color:#75715e></span>    ChannelHandler <span style=color:#a6e22e>handler</span><span style=color:#f92672>();</span>
 
    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Return {@code true} if the {@link ChannelHandler} which belongs to this context was removed
</span><span style=color:#75715e>     * from the {@link ChannelPipeline}. Note that this method is only meant to be called from with in the
</span><span style=color:#75715e>     * {@link EventLoop}.
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isRemoved</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>...</span>
    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Return the assigned {@link ByteBufAllocator} which will be used to allocate {@link ByteBuf}s.
</span><span style=color:#75715e>     */</span>
    <span style=color:#75715e>// 内存分配器
</span><span style=color:#75715e></span>    ByteBufAllocator <span style=color:#a6e22e>alloc</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>...</span>
<span style=color:#f92672>}</span>

</code></pre></div><h2 id=channelhandler的添加>ChannelHandler的添加<a hidden class=anchor aria-hidden=true href=#channelhandler的添加>#</a></h2>
<p>DefaultChannelPipeline的addLast方法</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Override</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> ChannelPipeline <span style=color:#a6e22e>addLast</span><span style=color:#f92672>(</span>EventExecutorGroup group<span style=color:#f92672>,</span> String name<span style=color:#f92672>,</span> ChannelHandler handler<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>final</span> AbstractChannelHandlerContext newCtx<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
      <span style=color:#75715e>//检查handler是否重复，如果没@Shareable的话，不可以再添加了
</span><span style=color:#75715e></span>        checkMultiplicity<span style=color:#f92672>(</span>handler<span style=color:#f92672>);</span>

      <span style=color:#75715e>//使用DefaultChannelHandlerContext，内部封装了具体的业务handler
</span><span style=color:#75715e></span>        newCtx <span style=color:#f92672>=</span> newContext<span style=color:#f92672>(</span>group<span style=color:#f92672>,</span> filterName<span style=color:#f92672>(</span>name<span style=color:#f92672>,</span> handler<span style=color:#f92672>),</span> handler<span style=color:#f92672>);</span>

      <span style=color:#75715e>//连接到链表上去
</span><span style=color:#75715e></span>        addLast0<span style=color:#f92672>(</span>newCtx<span style=color:#f92672>);</span>

        <span style=color:#75715e>// If the registered is false it means that the channel was not registered on an eventLoop yet.
</span><span style=color:#75715e></span>        <span style=color:#75715e>// In this case we add the context to the pipeline and add a task that will call
</span><span style=color:#75715e></span>        <span style=color:#75715e>// ChannelHandler.handlerAdded(...) once the channel is registered.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>registered<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            newCtx<span style=color:#f92672>.</span><span style=color:#a6e22e>setAddPending</span><span style=color:#f92672>();</span>
            callHandlerCallbackLater<span style=color:#f92672>(</span>newCtx<span style=color:#f92672>,</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>);</span>
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>

        EventExecutor executor <span style=color:#f92672>=</span> newCtx<span style=color:#f92672>.</span><span style=color:#a6e22e>executor</span><span style=color:#f92672>();</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>executor<span style=color:#f92672>.</span><span style=color:#a6e22e>inEventLoop</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
            callHandlerAddedInEventLoop<span style=color:#f92672>(</span>newCtx<span style=color:#f92672>,</span> executor<span style=color:#f92672>);</span>
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>
    callHandlerAdded0<span style=color:#f92672>(</span>newCtx<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>
</code></pre></div><h2 id=channelhandler删除>ChannelHandler删除<a hidden class=anchor aria-hidden=true href=#channelhandler删除>#</a></h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>private</span> AbstractChannelHandlerContext <span style=color:#a6e22e>getContextOrDie</span><span style=color:#f92672>(</span>ChannelHandler handler<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    AbstractChannelHandlerContext ctx <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>AbstractChannelHandlerContext<span style=color:#f92672>)</span> context<span style=color:#f92672>(</span>handler<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>ctx <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NoSuchElementException<span style=color:#f92672>(</span>handler<span style=color:#f92672>.</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>().</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>());</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> ctx<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>

<span style=color:#75715e>//从头到尾找
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> ChannelHandlerContext <span style=color:#a6e22e>context</span><span style=color:#f92672>(</span>ChannelHandler handler<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>handler <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;handler&#34;</span><span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span>
 
        AbstractChannelHandlerContext ctx <span style=color:#f92672>=</span> head<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>;</span>
        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(;;)</span> <span style=color:#f92672>{</span>
 
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>ctx <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span>
 
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>ctx<span style=color:#f92672>.</span><span style=color:#a6e22e>handler</span><span style=color:#f92672>()</span> <span style=color:#f92672>==</span> handler<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>return</span> ctx<span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span>
 
            ctx <span style=color:#f92672>=</span> ctx<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>

<span style=color:#75715e>//不删除head和tail
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> AbstractChannelHandlerContext <span style=color:#a6e22e>remove</span><span style=color:#f92672>(</span><span style=color:#66d9ef>final</span> AbstractChannelHandlerContext ctx<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>assert</span> ctx <span style=color:#f92672>!=</span> head <span style=color:#f92672>&amp;&amp;</span> ctx <span style=color:#f92672>!=</span> tail<span style=color:#f92672>;</span>
 
        <span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            remove0<span style=color:#f92672>(</span>ctx<span style=color:#f92672>);</span>
 
            <span style=color:#75715e>// If the registered is false it means that the channel was not registered on an eventloop yet.
</span><span style=color:#75715e></span>            <span style=color:#75715e>// In this case we remove the context from the pipeline and add a task that will call
</span><span style=color:#75715e></span>            <span style=color:#75715e>// ChannelHandler.handlerRemoved(...) once the channel is registered.
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>registered<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
           
                callHandlerCallbackLater<span style=color:#f92672>(</span>ctx<span style=color:#f92672>,</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
                <span style=color:#66d9ef>return</span> ctx<span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span>
 
            EventExecutor executor <span style=color:#f92672>=</span> ctx<span style=color:#f92672>.</span><span style=color:#a6e22e>executor</span><span style=color:#f92672>();</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>executor<span style=color:#f92672>.</span><span style=color:#a6e22e>inEventLoop</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
                executor<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Runnable<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
                    <span style=color:#a6e22e>@Override</span>
                    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
                        callHandlerRemoved0<span style=color:#f92672>(</span>ctx<span style=color:#f92672>);</span>
                    <span style=color:#f92672>}</span>
                <span style=color:#f92672>});</span>
                <span style=color:#66d9ef>return</span> ctx<span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>
        callHandlerRemoved0<span style=color:#f92672>(</span>ctx<span style=color:#f92672>);</span>
        <span style=color:#66d9ef>return</span> ctx<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#75715e>//真正的删除
</span><span style=color:#75715e></span> <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>remove0</span><span style=color:#f92672>(</span>AbstractChannelHandlerContext ctx<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        AbstractChannelHandlerContext prev <span style=color:#f92672>=</span> ctx<span style=color:#f92672>.</span><span style=color:#a6e22e>prev</span><span style=color:#f92672>;</span>
        AbstractChannelHandlerContext next <span style=color:#f92672>=</span> ctx<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>;</span>
        prev<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> next<span style=color:#f92672>;</span>
        next<span style=color:#f92672>.</span><span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> prev<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>



<span style=color:#75715e>//通知删除
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>callHandlerRemoved</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
            <span style=color:#75715e>// Only call handlerRemoved(...) if we called handlerAdded(...) before.
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>handlerState <span style=color:#f92672>==</span> ADD_COMPLETE<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                handler<span style=color:#f92672>().</span><span style=color:#a6e22e>handlerRemoved</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
            <span style=color:#75715e>// Mark the handler as removed in any case.
</span><span style=color:#75715e></span>          <span style=color:#75715e>//标记handler删除了  
</span><span style=color:#75715e></span>          setRemoved<span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>



</code></pre></div><h2 id=inboud事件>Inboud事件<a hidden class=anchor aria-hidden=true href=#inboud事件>#</a></h2>
<p>根据上面的描述，最终loop会绑定到pipeline中，当processSelectedKeys触发后，最后会调用到pipeline的fireChannelRead方法，找到下一个inboundHandlerContext</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#66d9ef>public</span> ChannelHandlerContext <span style=color:#a6e22e>fireChannelRead</span><span style=color:#f92672>(</span>Object msg<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        invokeChannelRead<span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>findContextInbound</span><span style=color:#f92672>(),</span> msg<span style=color:#f92672>);</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>


<span style=color:#75715e>//找到下一个Inbound的handler
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> AbstractChannelHandlerContext <span style=color:#a6e22e>findContextInbound</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        AbstractChannelHandlerContext ctx <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>;</span>

        <span style=color:#66d9ef>do</span> <span style=color:#f92672>{</span>
            ctx <span style=color:#f92672>=</span> ctx<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>while</span><span style=color:#f92672>(!</span>ctx<span style=color:#f92672>.</span><span style=color:#a6e22e>inbound</span><span style=color:#f92672>);</span>

        <span style=color:#66d9ef>return</span> ctx<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

<span style=color:#75715e>//创建handlerContext
</span><span style=color:#75715e></span>    DefaultChannelHandlerContext<span style=color:#f92672>(</span>DefaultChannelPipeline pipeline<span style=color:#f92672>,</span> EventExecutor executor<span style=color:#f92672>,</span> String name<span style=color:#f92672>,</span> ChannelHandler handler<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
      															<span style=color:#75715e>//判断是否是inbound 
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>super</span><span style=color:#f92672>(</span>pipeline<span style=color:#f92672>,</span> executor<span style=color:#f92672>,</span> name<span style=color:#f92672>,</span> isInbound<span style=color:#f92672>(</span>handler<span style=color:#f92672>),</span> isOutbound<span style=color:#f92672>(</span>handler<span style=color:#f92672>));</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>handler <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;handler&#34;</span><span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>handler</span> <span style=color:#f92672>=</span> handler<span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isInbound</span><span style=color:#f92672>(</span>ChannelHandler handler<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> handler <span style=color:#66d9ef>instanceof</span> ChannelInboundHandler<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

<span style=color:#75715e>//出发handler的方法，直接到用户的业务代码了
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>invokeChannelRead</span><span style=color:#f92672>(</span>Object msg<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>invokeHandler</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
                <span style=color:#f92672>((</span>ChannelInboundHandler<span style=color:#f92672>)</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>handler</span><span style=color:#f92672>()).</span><span style=color:#a6e22e>channelRead</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> msg<span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable var3<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>notifyHandlerException</span><span style=color:#f92672>(</span>var3<span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>fireChannelRead</span><span style=color:#f92672>(</span>msg<span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span>

    <span style=color:#f92672>}</span>

</code></pre></div><h2 id=outbound事件>outBound事件<a hidden class=anchor aria-hidden=true href=#outbound事件>#</a></h2>
<p>包含bind、connect、disconnect方法、close、deregister、read、write、flush等方法，这些方法更多的是主动向用户发起的操作。</p>
<p>（而inBound事件更多的是事件的触发，如register、readComplete、active，比较被动的）</p>
<p><strong>outBound是从tail反过来在链表上传输的</strong></p>
<h2 id=ctxchannelwrite和ctxwrite的区别>ctx.channel().write()和ctx.write()的区别<a hidden class=anchor aria-hidden=true href=#ctxchannelwrite和ctxwrite的区别>#</a></h2>
<p>ctx.channel().write()从tail节点开始传播，ctx.write()从当前节点开始传播（不包括当前节点，因为它首先会找到当前节点的下一个节点在执行write操作）。</p>
<h1 id=bytebuf>ByteBuf<a hidden class=anchor aria-hidden=true href=#bytebuf>#</a></h1>
<ul>
<li>
<p>Pooled和Unpooled</p>
<p>池化和不池化</p>
</li>
<li>
<p>Unsafe和非Unsafe</p>
<p><strong>unsafe通过操作底层unsafe的offset+index的方式去操作数据，非unsafe直接通过一个数组的下标（或者jdk底层的buffer）去操作数据</strong>。</p>
</li>
<li>
<p>Heap和Direct</p>
<p><strong>heap是依赖一个数组，direct是依赖jdk底层的ByteBuffer</strong>。</p>
</li>
</ul>
<h1 id=bytebuffallocator>ByteBuffAllocator<a hidden class=anchor aria-hidden=true href=#bytebuffallocator>#</a></h1>
<h2 id=unpooledbytebufallocator>UnpooledByteBufAllocator<a hidden class=anchor aria-hidden=true href=#unpooledbytebufallocator>#</a></h2>
<h3 id=分配堆内内存>分配堆内内存<a hidden class=anchor aria-hidden=true href=#分配堆内内存>#</a></h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>
<span style=color:#75715e>//如果jdk环境支持unsafe，则用unsafe操作内存空间
</span><span style=color:#75715e>//heap 内存空间，底层就是一个数组
</span><span style=color:#75715e></span><span style=color:#66d9ef>protected</span> ByteBuf <span style=color:#a6e22e>newHeapBuffer</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> initialCapacity<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> maxCapacity<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>return</span> PlatformDependent<span style=color:#f92672>.</span><span style=color:#a6e22e>hasUnsafe</span><span style=color:#f92672>()</span> <span style=color:#f92672>?</span>
            <span style=color:#66d9ef>new</span> InstrumentedUnpooledUnsafeHeapByteBuf<span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> initialCapacity<span style=color:#f92672>,</span> maxCapacity<span style=color:#f92672>)</span> <span style=color:#f92672>:</span>
            <span style=color:#66d9ef>new</span> InstrumentedUnpooledHeapByteBuf<span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> initialCapacity<span style=color:#f92672>,</span> maxCapacity<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>UnpooledHeapByteBuf</span><span style=color:#f92672>(</span>ByteBufAllocator alloc<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> initialCapacity<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> maxCapacity<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>super</span><span style=color:#f92672>(</span>maxCapacity<span style=color:#f92672>);</span>

        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>initialCapacity <span style=color:#f92672>&gt;</span> maxCapacity<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException<span style=color:#f92672>(</span>String<span style=color:#f92672>.</span><span style=color:#a6e22e>format</span><span style=color:#f92672>(</span>
                    <span style=color:#e6db74>&#34;initialCapacity(%d) &gt; maxCapacity(%d)&#34;</span><span style=color:#f92672>,</span> initialCapacity<span style=color:#f92672>,</span> maxCapacity<span style=color:#f92672>));</span>
        <span style=color:#f92672>}</span>

        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>alloc</span> <span style=color:#f92672>=</span> checkNotNull<span style=color:#f92672>(</span>alloc<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;alloc&#34;</span><span style=color:#f92672>);</span>
      <span style=color:#75715e>//声明数组
</span><span style=color:#75715e></span>        setArray<span style=color:#f92672>(</span>allocateArray<span style=color:#f92672>(</span>initialCapacity<span style=color:#f92672>));</span>
        setIndex<span style=color:#f92672>(</span>0<span style=color:#f92672>,</span> 0<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>


<span style=color:#75715e>//创建数组
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> <span style=color:#a6e22e>allocateArray</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> initialCapacity<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[</span>initialCapacity<span style=color:#f92672>];</span>
    <span style=color:#f92672>}</span>

</code></pre></div><h3 id=分配堆外内存>分配堆外内存<a hidden class=anchor aria-hidden=true href=#分配堆外内存>#</a></h3>
<p>底层调用jdk的<strong>DirectBuffer</strong></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Override</span>
<span style=color:#66d9ef>protected</span> ByteBuf <span style=color:#a6e22e>newDirectBuffer</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> initialCapacity<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> maxCapacity<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>final</span> ByteBuf buf<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>PlatformDependent<span style=color:#f92672>.</span><span style=color:#a6e22e>hasUnsafe</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
        buf <span style=color:#f92672>=</span> noCleaner <span style=color:#f92672>?</span> <span style=color:#66d9ef>new</span> InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf<span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> initialCapacity<span style=color:#f92672>,</span> maxCapacity<span style=color:#f92672>)</span> <span style=color:#f92672>:</span>
                <span style=color:#66d9ef>new</span> InstrumentedUnpooledUnsafeDirectByteBuf<span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> initialCapacity<span style=color:#f92672>,</span> maxCapacity<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
        buf <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> InstrumentedUnpooledDirectByteBuf<span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> initialCapacity<span style=color:#f92672>,</span> maxCapacity<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>return</span> disableLeakDetector <span style=color:#f92672>?</span> buf <span style=color:#f92672>:</span> toLeakAwareBuffer<span style=color:#f92672>(</span>buf<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>UnpooledDirectByteBuf</span><span style=color:#f92672>(</span>ByteBufAllocator alloc<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> initialCapacity<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> maxCapacity<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>super</span><span style=color:#f92672>(</span>maxCapacity<span style=color:#f92672>);</span>
        ObjectUtil<span style=color:#f92672>.</span><span style=color:#a6e22e>checkNotNull</span><span style=color:#f92672>(</span>alloc<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;alloc&#34;</span><span style=color:#f92672>);</span>
        checkPositiveOrZero<span style=color:#f92672>(</span>initialCapacity<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;initialCapacity&#34;</span><span style=color:#f92672>);</span>
        checkPositiveOrZero<span style=color:#f92672>(</span>maxCapacity<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;maxCapacity&#34;</span><span style=color:#f92672>);</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>initialCapacity <span style=color:#f92672>&gt;</span> maxCapacity<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException<span style=color:#f92672>(</span>String<span style=color:#f92672>.</span><span style=color:#a6e22e>format</span><span style=color:#f92672>(</span>
                    <span style=color:#e6db74>&#34;initialCapacity(%d) &gt; maxCapacity(%d)&#34;</span><span style=color:#f92672>,</span> initialCapacity<span style=color:#f92672>,</span> maxCapacity<span style=color:#f92672>));</span>
        <span style=color:#f92672>}</span>

        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>alloc</span> <span style=color:#f92672>=</span> alloc<span style=color:#f92672>;</span>
        setByteBuffer<span style=color:#f92672>(</span>allocateDirect<span style=color:#f92672>(</span>initialCapacity<span style=color:#f92672>),</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>protected</span> ByteBuffer <span style=color:#a6e22e>allocateDirect</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> initialCapacity<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> ByteBuffer<span style=color:#f92672>.</span><span style=color:#a6e22e>allocateDirect</span><span style=color:#f92672>(</span>initialCapacity<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> ByteBuffer <span style=color:#a6e22e>allocateDirect</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> capacity<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> DirectByteBuffer<span style=color:#f92672>(</span>capacity<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setByteBuffer</span><span style=color:#f92672>(</span>ByteBuffer buffer<span style=color:#f92672>,</span> <span style=color:#66d9ef>boolean</span> tryFree<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>tryFree<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            ByteBuffer oldBuffer <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>buffer</span><span style=color:#f92672>;</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>oldBuffer <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>doNotFree<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                    doNotFree <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
                <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
                    freeDirect<span style=color:#f92672>(</span>oldBuffer<span style=color:#f92672>);</span>
                <span style=color:#f92672>}</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>

        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>buffer</span> <span style=color:#f92672>=</span> buffer<span style=color:#f92672>;</span>
        tmpNioBuf <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
        capacity <span style=color:#f92672>=</span> buffer<span style=color:#f92672>.</span><span style=color:#a6e22e>remaining</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setByteBuffer</span><span style=color:#f92672>(</span>ByteBuffer buffer<span style=color:#f92672>,</span> <span style=color:#66d9ef>boolean</span> tryFree<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>setByteBuffer</span><span style=color:#f92672>(</span>buffer<span style=color:#f92672>,</span> tryFree<span style=color:#f92672>);</span>
      <span style=color:#75715e>//计算内存地址，使用Unsafe去操作
</span><span style=color:#75715e></span>        memoryAddress <span style=color:#f92672>=</span> PlatformDependent<span style=color:#f92672>.</span><span style=color:#a6e22e>directBufferAddress</span><span style=color:#f92672>(</span>buffer<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

		<span style=color:#75715e>//非 unsafe，直接调用jdk方法
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>byte</span> <span style=color:#a6e22e>_getByte</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> index<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> buffer<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>index<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

	<span style=color:#75715e>//获取内存地址，在用unsafe去调用
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>byte</span> <span style=color:#a6e22e>_getByte</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> index<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> UnsafeByteBufUtil<span style=color:#f92672>.</span><span style=color:#a6e22e>getByte</span><span style=color:#f92672>(</span>addr<span style=color:#f92672>(</span>index<span style=color:#f92672>));</span>
    <span style=color:#f92672>}</span>

	<span style=color:#75715e>//计算地址
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>addr</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> index<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> memoryAddress <span style=color:#f92672>+</span> index<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>


</code></pre></div><h2 id=pooledbytebufallocator>PooledByteBufAllocator<a hidden class=anchor aria-hidden=true href=#pooledbytebufallocator>#</a></h2>
<h3 id=分配堆内内存-1>分配堆内内存<a hidden class=anchor aria-hidden=true href=#分配堆内内存-1>#</a></h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Override</span>
<span style=color:#66d9ef>protected</span> ByteBuf <span style=color:#a6e22e>newHeapBuffer</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> initialCapacity<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> maxCapacity<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    PoolThreadCache cache <span style=color:#f92672>=</span> threadCache<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>();</span><span style=color:#75715e>//取出当前线程的缓存，多线程情况下的处理
</span><span style=color:#75715e></span>    PoolArena<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>byte</span><span style=color:#f92672>[]&gt;</span> heapArena <span style=color:#f92672>=</span> cache<span style=color:#f92672>.</span><span style=color:#a6e22e>heapArena</span><span style=color:#f92672>;</span> <span style=color:#75715e>//取出当前缓存里的arena
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>final</span> ByteBuf buf<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>heapArena <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        buf <span style=color:#f92672>=</span> heapArena<span style=color:#f92672>.</span><span style=color:#a6e22e>allocate</span><span style=color:#f92672>(</span>cache<span style=color:#f92672>,</span> initialCapacity<span style=color:#f92672>,</span> maxCapacity<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
        buf <span style=color:#f92672>=</span> PlatformDependent<span style=color:#f92672>.</span><span style=color:#a6e22e>hasUnsafe</span><span style=color:#f92672>()</span> <span style=color:#f92672>?</span>
                <span style=color:#66d9ef>new</span> UnpooledUnsafeHeapByteBuf<span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> initialCapacity<span style=color:#f92672>,</span> maxCapacity<span style=color:#f92672>)</span> <span style=color:#f92672>:</span>
                <span style=color:#66d9ef>new</span> UnpooledHeapByteBuf<span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> initialCapacity<span style=color:#f92672>,</span> maxCapacity<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>return</span> toLeakAwareBuffer<span style=color:#f92672>(</span>buf<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>



    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PoolThreadLocalCache</span> <span style=color:#66d9ef>extends</span> FastThreadLocal<span style=color:#f92672>&lt;</span>PoolThreadCache<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
 
        <span style=color:#a6e22e>@Override</span>
        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>synchronized</span> PoolThreadCache <span style=color:#a6e22e>initialValue</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>final</span> PoolArena<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>byte</span><span style=color:#f92672>[]&gt;</span> heapArena <span style=color:#f92672>=</span> leastUsedArena<span style=color:#f92672>(</span>heapArenas<span style=color:#f92672>);</span>
            <span style=color:#66d9ef>final</span> PoolArena<span style=color:#f92672>&lt;</span>ByteBuffer<span style=color:#f92672>&gt;</span> directArena <span style=color:#f92672>=</span> leastUsedArena<span style=color:#f92672>(</span>directArenas<span style=color:#f92672>);</span>
 
          <span style=color:#75715e>//FastThreadLocal就是ThreacLocal的快速版本，首次没有取到缓存的时候，会进行初始化动作
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> PoolThreadCache<span style=color:#f92672>(</span>
                    heapArena<span style=color:#f92672>,</span> directArena<span style=color:#f92672>,</span> tinyCacheSize<span style=color:#f92672>,</span> smallCacheSize<span style=color:#f92672>,</span> normalCacheSize<span style=color:#f92672>,</span>
                    DEFAULT_MAX_CACHED_BUFFER_CAPACITY<span style=color:#f92672>,</span> DEFAULT_CACHE_TRIM_INTERVAL<span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span>
     <span style=color:#f92672>...</span>
<span style=color:#f92672>}</span>


</code></pre></div><h1 id=bytetomessagedecoder>ByteToMessageDecoder<a hidden class=anchor aria-hidden=true href=#bytetomessagedecoder>#</a></h1>
<p>抽象的字节解码器</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Override</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>channelRead</span><span style=color:#f92672>(</span>ChannelHandlerContext ctx<span style=color:#f92672>,</span> Object msg<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>msg <span style=color:#66d9ef>instanceof</span> ByteBuf<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        CodecOutputList out <span style=color:#f92672>=</span> CodecOutputList<span style=color:#f92672>.</span><span style=color:#a6e22e>newInstance</span><span style=color:#f92672>();</span>
        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
            first <span style=color:#f92672>=</span> cumulation <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
          <span style=color:#75715e>//检查是否要扩容，默认netty实现是合并到一个ByteBuf上，需要内存复制，另一种是直接创建一个新的compositeByteBuf
</span><span style=color:#75715e></span>            cumulation <span style=color:#f92672>=</span> cumulator<span style=color:#f92672>.</span><span style=color:#a6e22e>cumulate</span><span style=color:#f92672>(</span>ctx<span style=color:#f92672>.</span><span style=color:#a6e22e>alloc</span><span style=color:#f92672>(),</span>
                    first <span style=color:#f92672>?</span> Unpooled<span style=color:#f92672>.</span><span style=color:#a6e22e>EMPTY_BUFFER</span> <span style=color:#f92672>:</span> cumulation<span style=color:#f92672>,</span> <span style=color:#f92672>(</span>ByteBuf<span style=color:#f92672>)</span> msg<span style=color:#f92672>);</span>
            callDecode<span style=color:#f92672>(</span>ctx<span style=color:#f92672>,</span> cumulation<span style=color:#f92672>,</span> out<span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>DecoderException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>throw</span> e<span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Exception e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> DecoderException<span style=color:#f92672>(</span>e<span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>cumulation <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>cumulation<span style=color:#f92672>.</span><span style=color:#a6e22e>isReadable</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
                    numReads <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
                    cumulation<span style=color:#f92672>.</span><span style=color:#a6e22e>release</span><span style=color:#f92672>();</span>
                    cumulation <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
                <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(++</span>numReads <span style=color:#f92672>&gt;=</span> discardAfterReads<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                    <span style=color:#75715e>// We did enough reads already try to discard some bytes so we not risk to see a OOME.
</span><span style=color:#75715e></span>                    <span style=color:#75715e>// See https://github.com/netty/netty/issues/4275
</span><span style=color:#75715e></span>                    numReads <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
                    discardSomeReadBytes<span style=color:#f92672>();</span>
                <span style=color:#f92672>}</span>

                <span style=color:#66d9ef>int</span> size <span style=color:#f92672>=</span> out<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>();</span>
                firedChannelRead <span style=color:#f92672>|=</span> out<span style=color:#f92672>.</span><span style=color:#a6e22e>insertSinceRecycled</span><span style=color:#f92672>();</span>
                fireChannelRead<span style=color:#f92672>(</span>ctx<span style=color:#f92672>,</span> out<span style=color:#f92672>,</span> size<span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
                out<span style=color:#f92672>.</span><span style=color:#a6e22e>recycle</span><span style=color:#f92672>();</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
        ctx<span style=color:#f92672>.</span><span style=color:#a6e22e>fireChannelRead</span><span style=color:#f92672>(</span>msg<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>


<span style=color:#75715e>//默认Cumulator实现，内存复制到一个ByteBuf上
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Cumulator MERGE_CUMULATOR <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Cumulator<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#a6e22e>@Override</span>
        <span style=color:#66d9ef>public</span> ByteBuf <span style=color:#a6e22e>cumulate</span><span style=color:#f92672>(</span>ByteBufAllocator alloc<span style=color:#f92672>,</span> ByteBuf cumulation<span style=color:#f92672>,</span> ByteBuf in<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>cumulation<span style=color:#f92672>.</span><span style=color:#a6e22e>isReadable</span><span style=color:#f92672>()</span> <span style=color:#f92672>&amp;&amp;</span> in<span style=color:#f92672>.</span><span style=color:#a6e22e>isContiguous</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
                <span style=color:#75715e>// If cumulation is empty and input buffer is contiguous, use it directly
</span><span style=color:#75715e></span>                cumulation<span style=color:#f92672>.</span><span style=color:#a6e22e>release</span><span style=color:#f92672>();</span>
                <span style=color:#66d9ef>return</span> in<span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span>
            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> required <span style=color:#f92672>=</span> in<span style=color:#f92672>.</span><span style=color:#a6e22e>readableBytes</span><span style=color:#f92672>();</span>
                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>required <span style=color:#f92672>&gt;</span> cumulation<span style=color:#f92672>.</span><span style=color:#a6e22e>maxWritableBytes</span><span style=color:#f92672>()</span> <span style=color:#f92672>||</span>
                        <span style=color:#f92672>(</span>required <span style=color:#f92672>&gt;</span> cumulation<span style=color:#f92672>.</span><span style=color:#a6e22e>maxFastWritableBytes</span><span style=color:#f92672>()</span> <span style=color:#f92672>&amp;&amp;</span> cumulation<span style=color:#f92672>.</span><span style=color:#a6e22e>refCnt</span><span style=color:#f92672>()</span> <span style=color:#f92672>&gt;</span> 1<span style=color:#f92672>)</span> <span style=color:#f92672>||</span>
                        cumulation<span style=color:#f92672>.</span><span style=color:#a6e22e>isReadOnly</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
                    <span style=color:#75715e>// Expand cumulation (by replacing it) under the following conditions:
</span><span style=color:#75715e></span>                    <span style=color:#75715e>// - cumulation cannot be resized to accommodate the additional data
</span><span style=color:#75715e></span>                    <span style=color:#75715e>// - cumulation can be expanded with a reallocation operation to accommodate but the buffer is
</span><span style=color:#75715e></span>                    <span style=color:#75715e>//   assumed to be shared (e.g. refCnt() &gt; 1) and the reallocation may not be safe.
</span><span style=color:#75715e></span>                    <span style=color:#66d9ef>return</span> expandCumulation<span style=color:#f92672>(</span>alloc<span style=color:#f92672>,</span> cumulation<span style=color:#f92672>,</span> in<span style=color:#f92672>);</span>
                <span style=color:#f92672>}</span>
                cumulation<span style=color:#f92672>.</span><span style=color:#a6e22e>writeBytes</span><span style=color:#f92672>(</span>in<span style=color:#f92672>,</span> in<span style=color:#f92672>.</span><span style=color:#a6e22e>readerIndex</span><span style=color:#f92672>(),</span> required<span style=color:#f92672>);</span>
                in<span style=color:#f92672>.</span><span style=color:#a6e22e>readerIndex</span><span style=color:#f92672>(</span>in<span style=color:#f92672>.</span><span style=color:#a6e22e>writerIndex</span><span style=color:#f92672>());</span>
                <span style=color:#66d9ef>return</span> cumulation<span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
                <span style=color:#75715e>// We must release in in all cases as otherwise it may produce a leak if writeBytes(...) throw
</span><span style=color:#75715e></span>                <span style=color:#75715e>// for whatever release (for example because of OutOfMemoryError)
</span><span style=color:#75715e></span>                in<span style=color:#f92672>.</span><span style=color:#a6e22e>release</span><span style=color:#f92672>();</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>};</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>callDecode</span><span style=color:#f92672>(</span>ChannelHandlerContext ctx<span style=color:#f92672>,</span> ByteBuf in<span style=color:#f92672>,</span> List<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> out<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>in<span style=color:#f92672>.</span><span style=color:#a6e22e>isReadable</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> outSize <span style=color:#f92672>=</span> out<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>();</span>

          <span style=color:#75715e>//解析到了数据
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>outSize <span style=color:#f92672>&gt;</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
              <span style=color:#75715e>//通知到下一个handler
</span><span style=color:#75715e></span>                fireChannelRead<span style=color:#f92672>(</span>ctx<span style=color:#f92672>,</span> out<span style=color:#f92672>,</span> outSize<span style=color:#f92672>);</span>
                out<span style=color:#f92672>.</span><span style=color:#a6e22e>clear</span><span style=color:#f92672>();</span>

                <span style=color:#75715e>// Check if this handler was removed before continuing with decoding.
</span><span style=color:#75715e></span>                <span style=color:#75715e>// If it was removed, it is not safe to continue to operate on the buffer.
</span><span style=color:#75715e></span>                <span style=color:#75715e>//
</span><span style=color:#75715e></span>                <span style=color:#75715e>// See:
</span><span style=color:#75715e></span>                <span style=color:#75715e>// - https://github.com/netty/netty/issues/4635
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>ctx<span style=color:#f92672>.</span><span style=color:#a6e22e>isRemoved</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
                    <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
                <span style=color:#f92672>}</span>
            <span style=color:#f92672>}</span>

            <span style=color:#66d9ef>int</span> oldInputLength <span style=color:#f92672>=</span> in<span style=color:#f92672>.</span><span style=color:#a6e22e>readableBytes</span><span style=color:#f92672>();</span>
          <span style=color:#75715e>//子类实现decode
</span><span style=color:#75715e></span>            decodeRemovalReentryProtection<span style=color:#f92672>(</span>ctx<span style=color:#f92672>,</span> in<span style=color:#f92672>,</span> out<span style=color:#f92672>);</span>

            <span style=color:#75715e>// Check if this handler was removed before continuing the loop.
</span><span style=color:#75715e></span>            <span style=color:#75715e>// If it was removed, it is not safe to continue to operate on the buffer.
</span><span style=color:#75715e></span>            <span style=color:#75715e>//
</span><span style=color:#75715e></span>            <span style=color:#75715e>// See https://github.com/netty/netty/issues/1664
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>ctx<span style=color:#f92672>.</span><span style=color:#a6e22e>isRemoved</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span>

          <span style=color:#75715e>//如果子类没有解析到对象
</span><span style=color:#75715e></span>          <span style=color:#75715e>//  1 数据不够解析道对象的
</span><span style=color:#75715e></span>          <span style=color:#75715e>//  2 
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>out<span style=color:#f92672>.</span><span style=color:#a6e22e>isEmpty</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
              
              <span style=color:#75715e>//数据不够解析的，跳出while，等下一次继续
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>oldInputLength <span style=color:#f92672>==</span> in<span style=color:#f92672>.</span><span style=color:#a6e22e>readableBytes</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
                    <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
                <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
                  <span style=color:#75715e>// 解析出来的东西，不够合成一个对象的，继续解析
</span><span style=color:#75715e></span>                    <span style=color:#66d9ef>continue</span><span style=color:#f92672>;</span>
                <span style=color:#f92672>}</span>
            <span style=color:#f92672>}</span>

          <span style=color:#75715e>// 解析出对象了，但是数据没有减少，有问题啊，明显对象你自己搞出来的，不是从数据里拿的，你有问题
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>oldInputLength <span style=color:#f92672>==</span> in<span style=color:#f92672>.</span><span style=color:#a6e22e>readableBytes</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> DecoderException<span style=color:#f92672>(</span>
                        StringUtil<span style=color:#f92672>.</span><span style=color:#a6e22e>simpleClassName</span><span style=color:#f92672>(</span>getClass<span style=color:#f92672>())</span> <span style=color:#f92672>+</span>
                                <span style=color:#e6db74>&#34;.decode() did not read anything but decoded a message.&#34;</span><span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span>
				
          <span style=color:#75715e>// 如果只要解析一个，直接跳出
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>isSingleDecode<span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>DecoderException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>throw</span> e<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Exception cause<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> DecoderException<span style=color:#f92672>(</span>cause<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://sunhao1256.github.io/tags/netty/>Netty</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://sunhao1256.github.io/posts/go/>
<span class=title>« Prev Page</span>
<br>
<span>Go包管理</span>
</a>
<a class=next href=https://sunhao1256.github.io/posts/reactor/>
<span class=title>Next Page »</span>
<br>
<span>Reactor响应式编程</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://sunhao1256.github.io/>Hao Sun</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>