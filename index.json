[{"content":"Redis redis如何做到限流的 限流的几个方式\n  计数器\n计数器即是计算在单位时间窗口内请求访问的次数是否超过阀值。\n窗口分为：固定窗口、滑动窗口\n  固定窗口java实现：\nprivate final AtomicInteger cur = new AtomicInteger(0); private Long startTime; public boolean isAllowed(int maxCount, int interval) { //如果没有第一次时间，则当下为第一次时间  if (startTime == null) startTime = System.currentTimeMillis(); //新增一次  cur.addAndGet(1); //如果当前时间减去开始时间，大于间隙了，说明进入新一轮计算  if (System.currentTimeMillis() - interval * 1000L \u0026gt; startTime) { //重置开始时间  startTime = System.currentTimeMillis(); //重置计数  cur.set(1); return true; } //还在时间内  return cur.get() \u0026lt;= maxCount; } 固定窗口解决了在单位时间内流量次数不会超过阀值，但是在临界点会出现问题。\n在前一个一秒内，0.8秒到1秒，访问了5次，没有超过阀值，1秒到1.2秒访问了5次，没有超过阀值。0.8秒到1.2秒之间的0.4秒访问了10次，超过了阀值。没有达到目的。这样的问题原因是窗口没有“滑动”。\n  滑动窗口\n滑动窗口是一种算法思想\n 滑动窗口算法（Sliding Window Algorithm）\n  Sliding window algorithm is used to perform required operation on specific window size of given large buffer or array.\n滑动窗口算法是在给定特定窗口大小的数组或字符串上执行要求的操作。\n  This technique shows how a nested for loop in few problems can be converted to single for loop and hence reducing the time complexity.\n该技术可以将一部分问题中的嵌套循环转变为一个单循环，因此它可以减少时间复杂度。\n 简而言之，滑动窗口算法在一个特定大小的字符串或数组上进行操作，而不在整个字符串和数组上操作，这样就降低了问题的复杂度，从而也达到降低了循环的嵌套深度。其实这里就可以看出来滑动窗口主要应用在数组和字符串上。\n常见的算法题，找到A字符串中，包含T个字符的最小覆盖子串\n//找到字符串EBBANCF中包含ABC三个字符的最小子串  //往往类似于“ 请找到满足 xx 的最 x 的区间（子串、子数组）的 xx ”这类问题都可以使用该方法进行解决。  public String noFixed(String str,String target){ String[] s = str.split(\u0026#34;\u0026#34;); String[] t = target.split(\u0026#34;\u0026#34;); //定义两个指针，在s上滑动  int left=0,right=0; String res=null; List window=new ArrayList(); //一直滑动，直到右指针到头了  while (right\u0026lt;s.length){ //移动右指针，一直到包含了所有的目标元素  window.add(s[right]); right++; //如果window满足要求了，就移动左指针  while (window.containsAll(Arrays.asList(t))){ if(res==null){ //第一次得到结果  res=String.join(\u0026#34;\u0026#34;,window); }else{ //比较当前的长度大小和目前最小的结果  res=(window.size()\u0026gt;res.length())?String.join(\u0026#34;\u0026#34;,window):res; } //移动左指针,直至窗口不满足  window.remove(s[left]); left++; } } return res; } /** * 固定窗口大小为f */ public String fixed(Integer f, String str) { String result = null; int right = 0; //寻找字符串中长度为f的包含最多元音字母的子串  String[] s = str.split(\u0026#34;\u0026#34;); List window = new ArrayList(); while (right \u0026lt; s.length) { //滑动右指针  window.add(s[right]); right++; //达到目标窗口的大小  if (right \u0026gt;= f) { //检查条件  String cur = String.join(\u0026#34;\u0026#34;, window); if (result == null) { //满足条件的话  if (countOfVowel(cur) \u0026gt; 0) result = cur; } else { int i = countOfVowel(result); int j = countOfVowel(cur); result = i \u0026gt; j ? result : cur; } //移动左指针，因为窗口固定，删除左边right-f个字符  window.remove(s[right-f]); } } return result; } private int countOfVowel(String s) { String[] split = s.split(\u0026#34;\u0026#34;); List\u0026lt;String\u0026gt; vowels = Arrays.asList(\u0026#34;A\u0026#34;, \u0026#34;E\u0026#34;, \u0026#34;I\u0026#34;, \u0026#34;O\u0026#34;, \u0026#34;U\u0026#34;); int res = 0; for (int i = 0; i \u0026lt; split.length; i++) { if (vowels.contains(split[i].toUpperCase())) { res++; } } return res; } 滑动窗口解决了临界的问题，但是当在窗口内达到了阀值，剩余的请求都会被拒绝，这样处理不好。\n    漏桶\npublic class LeakBucketLimit { /** * 出水率 */ private final long rate=5L;//1秒出水5个请求  /** * 桶的容量 */ private final long capacity=10L; /** * 当前水量 */ private long currentWater; /** * 最后刷新时间 */ private long refreshTime; public boolean tryAcquire(){ /** * 获取当前时间 */ long currentTime = System.currentTimeMillis(); /** * 流出去的水 */ long outWater = (currentTime-refreshTime)/1000*rate; /** * 当前 */ currentWater = Math.max(0,currentWater-outWater); System.out.println(currentWater); refreshTime=currentTime; if(currentWater\u0026gt;=capacity){ //不够流了  return false; } //加水  currentWater++; return true; } } 缺陷：不管是什么流量，桶都会按照rate一点一点消费，如果来了爆炸的流量，依然一点一点消费，实际情况中，我们希望能快速消费。而平时就按照rate消费。\n  令牌桶\n令牌桶就是为了解决漏桶的缺点。\n  有一个令牌管理员，根据限流大小，定速往令牌桶里放令牌。 如果令牌数量满了，超过令牌桶容量的限制，那就丢弃。 系统在接受到一个用户请求时，都会先去令牌桶要一个令牌。如果拿到令牌，那么就处理这个请求的业务逻辑； 如果拿不到令牌，就直接拒绝这个请求。   /** * 令牌桶发放速度 */ private final long tokenRate=5L; /** * 桶的容量 */ private final long capacity=10; /** * 上一次刷新的时间 */ private long refreshTime; /** * 当前桶里的令牌 */ private long currentToken; public boolean tryAcquire(){ //当前时间  long currentTime=System.currentTimeMillis(); //更新当前桶里的令牌个数  //当前token个数=原来当前个数+间隙之间生产出来的token个数（可能为0）  currentToken =Math.min (capacity,(currentToken+currentTime - refreshTime) / 1000 * tokenRate); refreshTime=currentTime; if(currentToken\u0026gt;0){ //还有令牌  currentToken--; return true; } return false; }   redis是单线程的吗 redis为什么这么块 redis的持久化 redis布隆过滤器 redis分布式锁 redis为什么选用跳表 redis防击穿、雪崩、穿透 redis是先删缓存还是先写库，怎么解决缓存一致性 问题排查 arthas jdk自带命令 Kafka Kafka的推还是拉 Kafka如何做到消息不丢失的 Kafka为什么可以有这么大的吞吐量 MySql mysql的索引数据结构为什么用B+树 最左匹配原则是什么 说出你如何调优的 常见的优化手段 MVVC 事务特性，隔离级别，怎么解决幻读？ 为什么要分库分表，有什么方案 Mybatis Spring Spring的Bean注入过程讲一下 Spring中常见的设计模式说一说 Spring是怎么解决Bean之间的循环依赖问题 SpringMvc的流程 SpringBoot的启动原理 SpringCloud了解多少 AOP怎么实现的 微服务 为什么要用dubbo 分布式事务、分布式锁 ES 为什么ES能查询的这么快 Zookeeper Zookeeper是干什么的 Java并发 你知道哪几种锁 讲一下线程的生命周期 AQS是什么？ wait()、notify()、sleep()、yield()、join()这几个方法的作用 实现线程安全的方法 公平锁和非公平锁的区别,ReentrantLock是怎么实现的 CAS是什么，怎么解决ABA问题 ConcurrentHashMap的分段锁 你用过哪些Java.util.concurrent下的类 讲一下线程池的几个参数含义 synchronized关键字，怎么优化的，膨胀的流程 volatile关键字 Java内存模型 ThreadLocal Java基础 说一说你理解的多态 来个简单的，Java作用域有哪些，为什么要考虑作用域 讲一下泛型和注解 讲一下反射和动态代理 Java的几种引用，你用过几种 说说进程和线程的区别 Java集合 讲一讲集合类，常用的集合，以及在多线程下你是如何保集合安全的 讲讲HashMap JVM JVM是什么 JVM内存模型 Java编译到执行的过程 双亲委派机制是干什么的 JVM是怎么进行垃圾回收的，垃圾回收机制是如何的，怎么判断是不是垃圾 平时如何调优 一个对象到底有多大，“对象在内存中长什么样子” 网络 讲一下TCP/IP 讲一下HTTP Netty干什么的，用过吗 你知道哪些网络模型？ BIO、NIO、AIO都是什么 讲一下Https 什么是多路复用 代码书写 聊聊设计模式，你知道哪些，用过哪些，为什么要用设计模式 数据结构 你知道哪些数据结构 红黑树、B树、B+树、二叉树、完全平衡二叉树 手写一个链表，实现正向输出，反向输出，找到最中间的元素 算法 常见的8个排序算法，你能写出几个 操作系统 零拷贝是什么 ","permalink":"https://sunhao1256.github.io/posts/%E5%85%AB%E8%82%A1%E6%96%87/","summary":"Redis redis如何做到限流的 限流的几个方式\n  计数器\n计数器即是计算在单位时间窗口内请求访问的次数是否超过阀值。\n窗口分为：固定窗口、滑动窗口\n  固定窗口java实现：\nprivate final AtomicInteger cur = new AtomicInteger(0); private Long startTime; public boolean isAllowed(int maxCount, int interval) { //如果没有第一次时间，则当下为第一次时间  if (startTime == null) startTime = System.currentTimeMillis(); //新增一次  cur.addAndGet(1); //如果当前时间减去开始时间，大于间隙了，说明进入新一轮计算  if (System.currentTimeMillis() - interval * 1000L \u0026gt; startTime) { //重置开始时间  startTime = System.currentTimeMillis(); //重置计数  cur.set(1); return true; } //还在时间内  return cur.get() \u0026lt;= maxCount; } 固定窗口解决了在单位时间内流量次数不会超过阀值，但是在临界点会出现问题。","title":"八股文"},{"content":"壁纸 ","permalink":"https://sunhao1256.github.io/posts/%E6%B5%8B%E8%AF%95%E4%B8%80%E5%BC%A0%E5%A3%81%E7%BA%B8/","summary":"壁纸 ","title":"测试一张壁纸"}]